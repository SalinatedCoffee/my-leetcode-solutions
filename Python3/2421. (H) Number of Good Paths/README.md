## 2421. (H) Number of Good Paths

### `solution.py`
Immediately we know that a brute force solution would take too long since there may be at most 30000 nodes, and such a solution would take $O(n^2)$ time (need to traverse all paths starting at a node, for all nodes). To come up with a faster method, we should first look at the constraints to see if we could use them to our advantage. A 'good path' is a path that starts and ends at nodes with the same value, and has intermediary nodes that have values smaller than the terminating nodes. Within that path the values can be any order, but if we build subgraphs from nodes in ascending order of their values we can guarantee that any path in that subgraph starting and ending with nodes with the same value is valid. Because of this guarantee we can compute the number of valid paths given a subgraph and the number of nodes with the largest value of that subgraph. For example, say we have a subgraph with nodes a, b, c, and d with the same value (which is the largest value in that subgraph). Looking at a there are 4 valid paths - a itself, a-b, a-c, and a-d. Looking at b there are 3 valid paths - b itself, b-c, and b-d. Reversed paths are considered the same, so including b-a here would be overcounting. For c, there are 2 paths - c itself, and c-d. The pattern here is that the total number of good paths is $4+(4-1)+(4-2)+(4-3)$. Generalizing for $n$ number of nodes the expression becomes $n+(n-1)+(n-2)+\dots+2+1 = n(n+1)/2$.  
Now that we have a formula for the number of good paths given the aforementioned constraints we need to implement a way to represent the subgraph(s). Here we may use union find mainly due to three reasons. First, it naturally represents multiple disconnected subgraphs. Second, it supports fast finding of a set given a node which is useful when counting the number of nodes in a subgraph. Third, it supports fast set merges which is used when adding a new node would result in two subgraphs becoming connected. We implement an arbitrary rank-based union find supporting the two operations mentioned previously.
After we instantiate a union find object, we incrementally build up subgraph(s) of the original graphs based on the value of the nodes in ascending order. This is accomplished by iterating through a node's neighbors and performaing a set merge whenever a neighbor has a value less than or equal to that of the node. At each value, we count the number of nodes with that value in each subgraph which allows us to compute the number of good paths for that subgraph and node value using the formula we derived earlier. An adjacency list and map from value to a set of nodes are required for this step, and in this solution are generated accordingly prior to the union find object instantiation.  
  
#### Conclusion
The solution runs in $O(n\log n)$ time since the sorting step on line 15 takes $O(n\log n)$ time, and is the dominating factor (refer to the code for more granular runtimes). The space complexity is $O(n)$, since `adj`, `values_to_nodes`, `obj = UFind()`, and `group` all uses $O(n)$ memory.  
  
