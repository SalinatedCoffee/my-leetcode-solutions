## 2751. (H) Robot Collisions

### `solution.py`
Given the lists `positions` and `healths`, along with the string `directions`, we are asked to return the health of all surviving robots. `positions[i]`, `healths[i]`, and `directions[i]` are the position, health, and direction of the `i`th robot. The robots move along a line, and they all start moving simultaneously starting at their positions and move towards either the left(denoted with the character `'L'` in `directions`) or right(`'R'`). If two robots occupy the same position at any point in time, they will collide. When they do, 3 things can happen depending on the health value of each robot. If  robot A has more health than robot B, robot B is destroyed and robot A's health is reduced by `1`(and vice versa). If both robots have the same amount of health, they are both destroyed. One thing to notice is that since all robots move at the same speed, two robots will only ever collide if they are moving towards each other. That is, if there are two 'adjacent' robots, they will only collide if the robot in the left is moving towards the right and the one on the right is moving towards the left. Because we are only interested in this specific case, which is not unlike matching a pair of parentheses, we can use a stack to store all surviving robots. We first sort the list of robots by their position, after which we iterate over the sorted list. If the robot on the top of the stack collides with the robot currently being considered, we update their healths accordingly and remove any robots that have reached `0` health. If the current robot is still alive and collides with the one on top of the stack again, we update their healths again, repeating this process until either there are no robots on the stack or the two robots do not collide. The current robot is pushed onto the stack if it is still alive, and we then move on to the next robot in the sorted list.  
Once we have finished simulating the collisions, `healths` will contain the most up-to-date values for all robots. Since the problem asks us to include the health values of the surviving robots, we filter `healths` before returning it.  

#### Conclusion
This solution has a time complexity of $O(n\log n)$ where $n$ is the number of robots. Initializing a list of indices takes $O(n)$ time, and the sorting step that follows requires $O(n\log n)$ time to complete. Simulating the collisions is a $O(n)$ time process as processing each robot takes $O(1)$ time, with each robot interacting with the stack at most twice. Hence the overall time complexity is $O(n\log n)$. The space complexity is $O(n)$, due to the sorting step and the lists `stack` and `idx`.  
  

