## 368. (M) Largest Divisible Subset

### `solution.py`
This is one of the more trickier medium difficulty problems. We need to first come up with a way to quickly check whether an integer can be added to a subset, without resorting to the brute force method. The problem says that items in a subset must satisfy `i % j == 0` *or* `j % i == 0` for all possible pairs of items `i` and `j`. If we think about this in reverse, if some pair of numbers `i` and `j` satisfy this condition, it is also implied that `i` is a multiple of `j` (or vice versa). And because all pairs of items in a subset must satisfy this condition, it means that in order to check whether an item can be added to a subset, we only need to verify whether that item is divisible by the largest item in the subset(or vice versa). So for example, if we have the subset `[1, 2, 4, 8]` and wanted to check whether `16` can be added to it, we only need to evaluate the expression `16 % 8 == 0 or 8 % 16 == 0`, which evaluates to `True`. Now the problem becomes figuring out how to retrieve a subset's largest value without iterating over its contents. As we obviously want to avoid actually storing the subsets in memory, we can take a similar approach to [problem #300](https://leetcode.com/problems/longest-increasing-subsequence/)(longest increasing subsequence) and instead refer to elements by their indices. If we sort `nums` before iterating over it, we can guarantee that any value that comes after some other value will be greater or equal than it. In order to determine whether we should be adding a value to a subset, we need the size of the subset in question. We initialize the list `size`, where the value of `size[i]` is the size of the largest subset ending with `nums[i]`(after it is sorted). As the problem asks us to return the actual elements of the largest subset, we also need some way of keeping track of which elements belong to what subset. Instead of explicitly storing this information, we can instead store the index of the previous element for each items in `nums`, and backtrack from the largest value to retrieve the contents of that subset. Finally, we need to know which element in `nums` we should start backtracking from, which we can do by keeping track of the index of the value with the largest subset size.  

#### Conclusion
This solution has a time complexity of $O(n^2)$ where $n$ is the length of `nums`. Sorting `nums` takes $O(n\log n)$ time, but determining the subsets takes $O(n^2)$ time; hence the overall time complexity of $O(n^2)$. The space complexity is $O(n)$, as `size` and `prev` are both lists of integers that have a length of $n$.  
  

