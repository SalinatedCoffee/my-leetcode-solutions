## 37. (H) Sudoku Solver

### `solution.py`
Given a 9 by 9 2D list of strings `board` representing an incomplete Sudoku board, we are asked to find the answer to that board and fill it in `board` in-place. In order to determine which values can be used in an empty square, we need to keep track of the numbers already in that row, column, and 3 by 3 subgrid. This can be achieved by using a set to store the values that are *not* in a row, column, or subgrid, which will allow us to simply compute the intersection of these 3 sets for an empty square to retrieve the list of values that can be placed in that square. To actually solve the Sudoku board we can use backtracking, exiting out of a recursion branch whenever it is determined that an empty square cannot be filled. That is, if `row[i]`, `col[j]`, and `sub[i//3][j//3]` are sets that contain the available values for the `i`th row, `j`th column, and corresponding subgrid respectively, we immediately exit out of the current recursive call whenever the intersection of these three sets is the empty set. Otherwise, we try filling in the current square with all possible values, returning `True` whenever we find a valid solution. One thing to note that the order in which the empty squares are filled does not matter, which allows us to get away with picking a single square for each recursive call.  
`row` and `col` are lists of length 9 that contain sets which in turn contains strings from `'1'` to `'9'`. `sub` is practially the same, with the difference being that it is a 3 by 3 2D list. While iterating over each square in `board`, the appropriate value is removed from the corresponding sets, with the coordinate of the square being added to `empty` instead if the value is `'.'`(an empty square). The function `recurse(i)` is then implemented, where `recurse(i)` returns `True` whenever a solution is found using the empty squares `empty[i:]`. The base case for `recurse` is when `i == len(empty)`, which means that all squares have been filled. Otherwise, we try filling the current square with all possible values, returning `False` when a solution has not been found even after exhausting all options. By definition of `recurse`, we want to initially call `recurse(0)` to start the backtracking, after which `board` will be filled with the solution.  

#### Conclusion
The time complexity of this solution is $O(9^n)$, where $n$ is the number of empty squares in `board`. For each empty square, there are at most `9` possible values that we can fill it with. Since filling in a value takes $O(1)$ time(as well as updating `row`, `col`, and `sub`) the overall time complexity comes out to be $O(9^n)$. Of course, one could also argue that the time complexity is $O(1)$ since the board has a fixed size. The space complexity is $O(1)$, since we can have 27 sets each containing 9 elements at most(when `board` is completely empty).  
  

