## 179. (M) Largest Number

### `solution.py`
`nums` is a list of non-negative integers, and we are asked to return the string representation of the largest possible number that can be formed by concatenating the contents of `nums`. For example if `nums = [1, 30]`, the returned string would be `"310"`. We obviously want to arrange the elements of `nums` in a way that maximizes the resulting concatenated number, and there is only one optimal order. This means that we can sort the elements of `nums` by using a custom comparator function that will order the elements in the desired way. If we reduce the problem into determining the ordering for a single pair of integers, we know that there are only 2 possible ways for the values to be ordered. Either the integers `A` and `B` are concatenated in that order to produce the value `AB`, or they are concatenated in reverse, resulting in the value `BA`. Among the two choices, we would obviously want to choose the larger value. Thus we can compare two integers by comparing the values of both concatenations; that is, the ordering of integers `A` and `B` can be decided by evaluating the expression `AB > BA`. Proving the correctness of this claim involves proving that the transitive property holds for this inequality(if `A > B` and `B > C`, `A > C`), but we will not go into further details here(for those interested, consult the editorial or [this](https://leetcode.com/problems/largest-number/description/comments/1564593) excellent comment).  
We first convert the elements of `nums` into strings since we are asked to return the concatenated number as a string. `nums` is then sorted in reverse order, using the adapter function `functools.cmp_to_key()` to convert a custom comparator lambda into an absolute key function that Python 3's built in sorting module expects. The elements of `nums` should now be in the desired order, allowing us to concatenate them into a single string and returning it after stripping it of any leading zeros.  

#### Conclusion
This solution takes $O(n\log n)$ time to run, where $n$ is the length of `nums`. If we consider the conversion from an integer to a string as requiring $O(1)$ time to complete, the initial conversion of `nums` takes $O(n)$ time, and the sorting step that follows finishes in $O(n\log n)$ time since Python implements Timsort for its built in sorting module. The space complexity is $O(n)$, due to the sorting step.  
  

