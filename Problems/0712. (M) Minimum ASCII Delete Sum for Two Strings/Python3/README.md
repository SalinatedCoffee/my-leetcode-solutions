## 712. (M) Minimum ASCII Delete Sum for Two Strings

### `solution.py`
By intuition, we know that we should be taking a dynamic programming approach to this problem. As such, let's first try coming up with a recursive solution that we can later convert into a top-down DP solution.  
Say we have two substrings of `s1` and `s2`, `ss1` and `ss2`. Examining the last character of these substrings at index `i` and `j` respectively, there are a few choices we can make depending on the characters `ss1[i]` and `ss2[j]`. If they are equal, neither character needs to be deleted, and we can try determining the cost between `ss1[:-1]` and `ss2[:-1]`. If they are not equal, we must delete at least one character from either string. At this point, we can either delete a character from `ss1`, delete one from `ss2`, or delete from both `ss1` and `ss2`. Among these choices, we would like to choose the one that results in the smallest cost. The base cases would be when either string is empty, or both are empty. When a string is empty the cost is the sum of all character's ASCII codes in the other string. When they are both empty the strings are already equal, so the cost is simply `0`. The last case however is redundant, since removing a character from both strings is essentially the same as removing a character from one string, and removing one from the other in the next recursive call. Thus, we can reduce the base case from 3 cases to 2. Similarly, the base cases where only one string is empty can be delegated to further recursive calls. Instead of computing the ASCII code sum and returning immediatly, we can instead return the sum of the ASCII code value of the last character and the return value of a recursive call on a shorter string. So if `i == -1` and `j >= 0` where `i` and `j` represent the position of the last character in strings `s1` and `s2` respectively, we return `ord(s2[j]) + f(i, j-1)`. This will recursively compute the ASCII sum of the substring `s2[:j+1]` instead of doing it explicitly(this could also be optimized by precomputing prefix ASCII code sums for `s1` and `s2`).  
Now that we have devised a recursive solution, we see that it only has two integer parameters and can be trivially modified into a top-down solution.  

#### Conclusion
This solution has a time complexity of $O(mn)$ where $m$ and $n$ are the length of `s1` and `s2`, respectively. Each state is represented by two parameters, in which one is in the range $[0,m]$ and the other in $[0,n]$. Thus there are $m\times n$ possible states, hence the overall running time of $O(mn)$. The space complexity is also $O(mn)$, since we are storing the return value of all possible states in memory.  
  


### `solution_2.py`
A bottom-up approach is also feasable by building on the first solution. We have already established that each state is represented by two parameters, each of which represent the position of the last character of the prefix substring of `s1` and `s2`. The value for state where both substrings are empty (`0,0`) is trivially `0`, and we eventually want the value of the state where both strings contain the entierety of `s1` and `s2` (`m,n`), thus it stands to reason that we should be starting at state `0,0` and build up to state `m,n`. We may store these values in a 2D $(m+1)\times (n+1)$ list `dp`, where `dp[i][j]` is the minimum ASCII sum to match the first $m$ characters of `s1` and the first $n$ characters of `s2`. The states where one of the strings is empty (`dp[0][i]` and `dp[i][0]`) are simply the prefix ASCII sum up to the `i`th character, as described in the previous solution. For `dp[i][j]` then, there are three things that could have happened in the previous step. Either both characters were equal and no cost was incurred, or they were not equal and one character was removed from one string; whichever resulted in a lower cost. That is, the value of `dp[i][j]` is `dp[i-1][j-1]` if `s1[i-1] == s2[j-1]`, or `min(ord(s1[i-1])+dp[i-1][j], ord(s2[j-1])+dp[i][j-1])` if `s1[i-1] != s2[j-1]`. In a nutshell, the state represented by `(i, j)` depends on the value of `(i-1, j-1)`, `(i-1, j)`, and `(i, j-1)`, which tells us the direction in which we should popluate `dp`. In this solution, we have elected to fill `dp` row-first, from left to right, and top to bottom.  

#### Conclusion
Like the first solution, the time and space complexity is $O(mn)$. Since the entierety of `dp` is not required to compute the value for a state however, this solution could be further optimized to reduce the space complexity to $O(\text{min}(m,n))$.  
  

