## 979. (M) Distribute Coins in Binary Tree

### `solution.py`
Given a tree with nodes containing a non-negative number of coins, we are asked to return the minimum number of moves required to allocate 1 coin to every node. The total number of coins in the tree is exactly equal to the number of nodes, and only 1 coin can be moved during a single move. Say we are currently considering some random node in the tree. We can trivially check whether the current node either needs a coin, already has one, or has an excess by simply looking at its value. However, there is no way to determine the next course of action as we have no information regarding the node's subtrees. In order to make an informed decision then, we need to traverse the node's children first, which can be achieved by performing a postorder(LRN) traversal of the tree. The number of coins for a subtree can be represented as an integer; if it is negative, there are not enough coins to distribute among the nodes in that subtree. If it is positive, there is an excess of coins that can be sent outside of the subtree. We first start by examining the number of coins of a leaf node. Coins can be passed on from a parent to a child, but also from a child to its parent. Leaf nodes however, do not have any children, and thus there is only one way through which they can send and receive coins. The function `recurse` takes a single argument `node`, and returns the number of coins required/left over from the subtree rooted at `node`. This value is simply the sum of the values returned by calling `recurse` on its children, plus the value of `node.val - 1`(as opposed to `node.val`, as the current node also needs to keep 1 coin). We now have a function that counts the number of coins within a subtree. How can we use this to compute the number of moves? This can be implemented fairly easily after realizing that the number of coins are *exactly* equal to the number of nodes in the tree - that is, each node will have `1` coin after all coins have been distributed. Thus, all of the excess(or deficient) coins from a subtree *must* be moved out(or into) said subtree. And because only 1 coin can be moved per move, the number of moves required to move `i` coins is simply `abs(i)`. Hence, within our function `recurse`, we can also compute the number of moves required by computing the sum of absolute values of `node`'s children.  
As we want the number of moves for the tree rooted at `root`, we simply call `recurse(root)` before returning the sum of required moves.  

#### Conclusion
The time and space complexity of this solution is $O(n)$, where $n$ is the number of nodes in the tree rooted at `root`. Performing a DFS traversal on a tree with $n$ nodes takes $O(n)$ time, and because each node takes $O(1)$ time to process, the overall time complexity comes out to be $O(n)$. Regarding space complexity, the only component that scales with the size of the input is the recursion stack of `recurse`. This can be at most $O(h)$ tall, with $h$ being the height of the tree being traversed. As the given tree is not guaranteed to be balanced, this value is bound by $n$, putting the overall space complexity at $O(n)$.  
  

