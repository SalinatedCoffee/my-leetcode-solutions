## 3203. (H) Find Minimum Diameter After Merging Two Trees

### `solution.py`
Given 2 tree-shaped undirected graphs in the form of 2 lists of edges `edges1` and `edges2`, we are allowed to add a single edge to connect the two graphs. Our task is to determine the smallest diameter of the resulting graph after adding the edge. If we think about this problem visually, it is not that difficult to come to the conclusion that we should be connecting the two trees by the 'center' node(s) in their respective 'diameter path'(longest path between two nodes in the tree). When the trees are connected, we can think of 2 possibilities regarding the diameter path of the new tree. It can either go through the newly added edges, or it may not. For the former, we can say that the new path would be created by connecting half of one tree's diameter path to the half of the diameter path of the other tree. That is, if the diameter of each tree was `d1` and `d2`, the new diameter would be `ceil(d1 / 2) + ceil(d2 / 2) + 1` since we would be adding 1 new edge to connect the two halves. For the latter, it would mean that the diameter of the new tree is simply the larger value among the diameter of the 2 given trees.  
Now that we have come up with a method to determine the diameter of the new tree, we need to actually implement this algorithm in code. First off, we need to determine the diameter of each tree. One naive method is to make 2 BFS passes over a given graph. The graph is first traversed starting at an arbitrary node to determine the node farthest away from the source. A second pass is then made from the node identified from the first pass to determine the distance between that node and node farthest away from it. This distance will be the diameter of the graph. Since we will be running this algorithm twice(once for each tree), we implement several helper functions to avoid having to repeat blocks of code. `build_adjacency(edges)` will return an adjacency list using the list of edges in `edges`. `farthest_node_of(node, adj)` will return the node farthest away from node `node` in the graph represented by the adjacency list `adj`, along with the distance. Finally, `diameter_of(adj)` will return the diameter of the graph represented by `adj` by calling `farthest_node_of` twice. Once we determine the diameter of each tree, we return the largest value among the two diameters and the 'new' diameter using the expression previously described.   

#### Conclusion
This solution has a time complexity of $O(m+n)$, where $m$ and $n$ are the number of nodes in each graph, respectively. Generating the adjacency list for a tree with $n$ nodes requires $O(n)$ time, as the number of edges in said tree is $O(n)$. A single BFS traversal over the same tree will also complete in $O(n)$ time, bringing the overall time complexity fo $O(m+n)$ as both trees are put through the same sequence of steps. The space complexity is also $O(m+n)$, due to the adjacency lists `adj1` and `adj2`.  
  

