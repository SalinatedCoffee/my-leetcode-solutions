## 407. (H) Trapping Rain Water II

### `solution.py`
Given the `m*n` 2D list of integers `heightMap`, which represents the height of each cell in an elevation map, we are asked to return the volume of water it can trap after raining. For example, if `heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]]`, the grid can hold 10 units of water as illustrated by the image below:  

![Grid containing 10 units of water](./trap2-3d.jpg)  

First, we begin by thinking about how a cell would trap water above it. The trivial case would be it being surrounded by neighbors that all have a strictly taller height than itself. In this case, the number of trapped units of water would be the difference between the height of the current cell and the smallest height of its neighbors. But what if one of its neighbors has a height equal to or less than that of the current cell? In this case, the number of units would depend on the neighbors of the neighbor - and so on. We can greatly simplify the problem by realizing that the 'water trapping capacity' of a cell depends on the **smallest** height of its neighbors. That is, if we can visit a cell from its neighbor that has the smallest height, we can compute the number of units that the cell can trap. To do this, we use a min heap as a priority queue using the height of the cell as the key. This priority queue is initialized with the cells bordering the grid, as a trapped body of water must have at least 1 solid cell along its perimeter. We then start traversing the grid by popping off an item off of the priority queue. For each neighbor `nxt` of the current cell `cur`, it is *guaranteed* that `cur` has the *smallest height among the 4 neighbors of `nxt`* as we have popped `cur` off of a min heap. Thus, if the height of `nxt` `nxt_h` is strictly less than the height `cur_h` of `cur`, it is also guaranteed that `nxt` will trap `cur_h - nxt_h` units of water. At this point, we should be thinking about how we would add `nxt` to the min heap. There are 3 cases for `cur_h` and `nxt_h`. `cur_h` can be either greater than, equal to, or less than `nxt_h`. If `cur_h > nxt_h`, the neighbors of `nxt` are affected by the value of `cur_h`. If `cur_h == nxt_h`, it does not matter which height we decide to add to the min heap. If `cur_h < nxt_h`, the neighbors of `nxt` are affected by the value of `nxt_h`. Summarizing, the height of `nxt` that should be pushed into the min heap should be `max(cur_h, nxt_h)`. While the logic may seem confusing at first, we can try visualizing it as setting an initial boundary and slowly shrinking it as we traverse the height map. For each cell, we first compute the number of units of water trapped by it(if any) and 'freeze' it after, making it a part of the boundary. Since we are traversing the grid by moving to the adjacent neighbors of each cell, we can implement our solution by slightly modifying the iterative flavor of BFS. Instead of using a deque we use a min heap to store boundary cells, which consists of a tuple containing the height of the cell and another tuple representing the cell's coordinates on the grid. Once all cells have been processed, we simply return the total amount of water.  

#### Conclusion
This solution has a time complexity of $O(mn\log(mn))$, where $m$ and $n$ are the dimensions of `heightMap`. Initializing `visited` and `boundary` each take $O(mn)$ and $O(m+n)$ time, respectively. 'Heapify'ing `boundary` requires $O(\log(m+n))$ time. For the BFS step, each cell is visited exactly once, and there are $mn$ cells total. This also means that a cell is added and removed from the min heap once. As the heap can contain $O(mn)$ elements, a single remove/add operation should be considered a $O(\log(mn))$ time operation. Thus, the overall time complexity of this solution is $O(mn + \log(m+n) + mn\log(mn)) = O(mn\log(mn))$. The space complexity is $O(mn)$, due to `visited` and `boundary`.  
  

