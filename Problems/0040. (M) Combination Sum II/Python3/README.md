## 40. (M) Combination Sum II

### `solution.py`
Given a list of integers `candidates`, we are asked to find and return all unique combinations of `candidates` that sums up to `target`. A value in `candidates` may only be used once, but `candidates` can contain duplicates of the same number. For example if `candidates = [1, 2, 2, 2]` and `target = 5`, we may use multiple `2`s in the combination `[1, 2, 2]`, but selecting the first and second `2`s and the second and third `2`s should be considered the same combination and appear in the list of combinations only once. To do this, we want to be able to recurse on a list of the unique values of `candidates`, while being able to determine the number of times each unique value appears in the list. Intuition tells us that we can achieve this by using a dictionary, using the unique values as keys and the number of their appearances as values. We can then iterate over the list of keys while incrementally adding available instances of each key, which will allow us to avoid generating duplicate combinations.  
We first initialize a `Counter` using `candidates` as the argument. The list of keys is then retrieved, after which we define the function `recurse`. `recurse` takes 2 arguments `i` and `r`. `i` is the index of the current key being considered, and `r` is the remainder of `target`. The two base cases for `recurse` is when `i` is equal to the number of keys(no more keys left to examine) or `r` is equal to `0`(the sum of the current combination is exactly `target`). In either case we immediately exit out of the function, but when `r == 0` we first add the current combination to the return list `self.ret` before doing so. For the non-base cases, we simply try incrementally adding the current value to the combination before recursing on the next value. If we either run out of duplicate values to add or adding another value would result in `r` becoming negative, we stop adding any more and revert the combination to its original state before exiting.  

#### Conclusion
This solution has a time complexity of $O(2^n+n)$ where $n$ is the length of `candidates`. Each value in `candidates` can either be included in a combination, or excluded. Since `recurse` explores all possible combinations of the values in `candidates`, of which there are $O(2^n)$ of, `recurse(0, 0)` will take $O(2^n)$ time to complete. Counting the occurrances of each unique value of `candidates` takes $O(n)$ time, bringing the overall time complexity to $O(2^n+n) = O(2^n)$. The space complexity is $O(n)$, due to the dictionary `c_freq` and the recursion stack.  
  

