## 2551. (H) Put Marbles in Bags

### `solution.py`
 At first glance this problem seems like it could be solved with dynamic programming, since it seems like the problem can be broken down into smaller subproblems with clearly defined state transitions between them. However in this case the states will have two parameters `n` (length of `weights`) and `k`, and since `k` can at most be equal to `n` this will result in a overall running time of $O(n^2)$ which would fail with TLE(size range is $10^5$ so worst case $(10^5)^2 = 10^{10}$.  
Let's go back and examine the problem more deliberately. The score of a bag of marbles is simply the sum of the first marble and the last marble(which can be the same marble if the bag contains 1 marble). Because a bag can only contain one 'interval' of marbles, a bag is essentially a non-empty subarray of `weights`. We want to partition `weights` into `k` subarrays, which means that there are `k-1` partitions we will have to make in total. The goal is to optimize the total score, which is influenced by the scores of the individual subarrays, which is again influenced by the values of the first and last values in a subarray. That is, we are essentially optimizing the sum of these 'edge' values. This sum will contain the first and last values of `weights`, as well as the pair of bordering values that contains a partition between them. For example if `weights = [1, 2, 3, 4, 5, 6]` and `k = 2`, and we arbitrarily decide to partition `weights` into `[1, 2, 3]` and `[4, 5, 6]`, `3` and `4` will be a pair of bordering values since they have a partition between them. Of course the partition can be made between any pair of values - but because a pair **must** be comprised of adjacent values, we can precompute the sum of pairs beforehand. Among these sums we need to select the `k-1` largest values to get the maximum total score, and the smallest values to get the minimum total score. This can be easily achieved by sorting the list of precomputed pair sums.  
Also note that technically the total scores also contain the first and last values of `weights` as mentioned earlier. However since we want the difference between the minimum and maximum total scores, they cancel each other out and thus we do not need to include these terms in the difference computation.  

#### Conclusion
This solution has a time complexity of $O(n\log n)$ where $n$ is the length of `weights`. The precomputing step iterates over `weights` once, and generates a list of length $n-1$. This list is sorted in ascending order, which takes $O(n\log n)$ time. The space complexity is $O(n)$.  
  

