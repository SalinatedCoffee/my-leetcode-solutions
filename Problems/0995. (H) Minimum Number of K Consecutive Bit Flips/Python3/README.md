## 995. (H) Minimum Number of K Consecutive Bit Flips

### `TLE.py`
The naive solution is to greedily perform k-bit flips starting at every bit that is set to `0`. Traversing `nums` from left to right, if the current bit(the `i`-th bit) is `0`, all bits starting at that bit up to the `i+k-1`-th bit is flipped. After all bits have been examined, we check the number of `1`s in `nums` to determine whether it is possible to make all bits `1`. We can convince ourselves that this greedy approach works by working through a (very) loose proof. Our claim is 'any `1`s in the leftmost prefix of consecutive `1`s should not be flipped'. We will prove this claim by proof by contradiction. Let's now assume that the claim we made earlier is false, and the `i`-th bit is the first bit(from left to right) that is `0`. Because the claim is false, a better flip sequence should exist that performs a k-bit flip starting at the `j`-th bit where `j < i`. There may be multiple possible values of `j`, but here we will assume that `j` is the smallest possible value. We flip the subarray `nums[j:j+k]`. Now `nums[j]` is `0`, since it was previously `1`. Because we eventually want to make all bits `1`, at some point in the future we need to flip `nums[j]` back into `1`. However, since `j` is the smallest possible value we *cannot* flip any bits to the left of `nums[j]`, forcing us to perform a k-bit flip starting with `nums[j]` in order to make it a `1`. Since this is redundant, we know that this cannot possibly be a optimal solution; thereby contradicting our assumption that a more optimal solution exists by flipping a `1` in the prefix subarray of consecutive `1`s. The problem now becomes actually flipping the bits, which is pretty straightforward as briefly mentioned earlier.  

#### Conclusion
The time complexity of this algorithm is $O(n^2)$, where $n$ is the length of `nums`. In the worst case, a k-bit flip is performed for each and every element in `nums`. Since `k` is bound by $n$, the overall time complexity becomes $O(n^2)$. The space complexity is $O(1)$.  
  


### `solution.py`
The previous attempt, while algorithmically correct, fails with TLE as the quadratic time complexity is too large for the length constraint on `nums`. We need to find a way to reduce the running time of the k-bit flips to a sub-linear time complexity in order for the algorithm to be accepted. Obviously, the basic act of flipping some number of bits cannot be made any more faster. Can we flip each bit one-by-one while emulating how they would be flipped if we were actually performing the k-bit flips? We absolutely can, due to the fact that bit flipping(which is basically an XOR operation) can be reversed by flipping the bit one more time. That is, a bit will retain its original value if it is flipped an even number of times, and it will be reversed if it is flipped an odd number of times. By storing whether a k-bit flip has occurred starting at each element, we can determine the number of times an element has been flipped, which will in turn allow us to identify whether that element needs to be flipped or not. Before iterating over `nums`, we initialize the integer `flips_prev` and the list of booleans `flipped`. The value of `flips_prev` will be the number of flips performed on the `k` previous elements, which we keep track separately to avoid having to count this for each element(which would defeat the purpose of this optimization). `flipped[i]` will be `True` if a k-bit flip has occurred starting at `nums[i]`, and `False` otherwise. When iterating over `nums`, the first thing we check is whether there is an element that is about to become irrelevant(a k-flip from that element does not reach the current element). If so, and a flip has occurred at that element, we decrement `flips_prev` by `1`. We then check whether the current `i`-th element needs to be flipped by consulting the value of `nums[i]` and `flips_prev`. If `nums[i]` has not changed(`flips_prev` is even) and `nums[i]` is `0`, we need to flip `nums[i]`. The remaining 3 cases are straightforward to understand, and will not be explained here. One thing to keep in mind is when the current element needs to be flipped, but is less than `k` elements away from the end of `nums`. As we need to flip `k` elements at once, this means that the current element cannot be flipped, and making all elements in `nums` a `1` is impossible. Otherwise, we simply mark the current element as flipped by assigning `True` to `flipped[i]` and move on to the next element.  

#### Conclusion
This solution has a time complexity of $O(n)$. `nums` is iterated over once, but this time we flip a single element instead of `k` elements, bringing down the time required to process each element to $O(1)$. The space complexity is $O(n)$, due to `flipped`.  
  

