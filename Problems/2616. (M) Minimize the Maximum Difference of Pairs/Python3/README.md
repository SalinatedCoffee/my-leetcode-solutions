## 2616. (M) Minimize the Maximum Difference of Pairs

### `solution.py`
We first realize that we would need to sort `nums` in order to achieve a reasonable time complexity. Once `nums` has been sorted, we also notice that it is **always** optimal to select a pair of adjacent values rather than non-adjacent pairs since the values are monotonically increasing. Using this, we can greedily count the number of valid pairs for some target difference `t` in linear time. While iterating over `nums`, we check whether the difference between a value's neighbor is less than or equal to `t`. If yes, we skip *both* values and continue iterating. Otherwise, we simply move on to the next element in `nums`.  
Now that we can verify whether some difference `t` can yield some number of pairs, how can we put this together with `p`? Let's assume that for `t` we can select `i` pairs. What can we definitely say for `t+1` and `t-1`? For the former we can say that we could select **at least** `i` pairs - trivially, the exact pairs that were selected for `t`. For the latter, since we possibly could not select `i+1` pairs for `t`, it would be reasonable to say that we could not select `i+1` pairs for `t-1` as well. In conclusion, if `t` yields `p` pairs and `t-1` yields `p-1` pairs, it is **guaranteed** that any difference less than `t` will yield less than `p` pairs and those greater than or equal to `t` will yield at least `p` pairs. If we can define a linear search space for the target difference then, we can apply binary search in order to find the smallest difference that yields `p` pairs. This search space starts at `0` and ends at `nums[-1] - nums[0]`, since the smallest possible difference is trivially `0` and the largest possible difference is that of the smallest and largest values in `nums`. If the midpoint value yields a greater or equal number of pairs as `p` it means that a smaller value may exist, and so we choose the left half. If not, we choose the right half.  

#### Conclusion
This solution has a time complexity of $O(n\cdot \text{max}(\log n, \log V))$, where $n$ is the length of `nums` and $V$ is the largest pair difference. We initially sort `nums`, which takes $O(n\log n)$ time in Python. The binary search step performs $\log V$ iterations, and performs a $O(n)$ time verification during each iteration resulting in a total running time of $O(n\log V)$. Given the input constraints, $n$ and $V$ have comparable magnitudes, hence the $\text{max}$ component in the final time complexity. The space complexity is $O(n)$ as Python's `sorted()` will use $O(n)$ space.  
  

