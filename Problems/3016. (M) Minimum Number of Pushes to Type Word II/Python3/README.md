## 3016. (M) Minimum Number of Pushes to Type Word II

### `solution.py`
Given the string `word` comprised of only lowercase English letters, we are asked to find the minimum number of keypresses required to type `word` on a numeric keypad where letters can be mapped to each button in the style of a cellphone. Out of 12 keys on a keypad, letters cannot be mapped to the keys `0`, `1`, `*`, and `#`, leaving 8 mappable keys.  
Firstly, it becomes obvious that a greedy algorithm can solve this problem since we want to prioritize mapping the most frequent letters as the first letter on a key. Being the first letter allows the letter to be inputted with a single keypress, which is the most efficient way a letter can be inputted. Once all keys are assigned a letter, we take the next batch of frequent letters and map them as the second letter of the keys, and so on. The frequency of each letter can be easily generated by passing `word` as the parameter when instantiating a `Counter`, where the resulting dictionary will have each letter as the keys and their frequencies in `word` as their values. After generating the frequency list, it is sorted in descending order of their values as we want to map the high frequency letters first. We then iterate over the sorted list while computing the number of keypresses we would need to perform to input all instances of the current letter. This is achieved by computing the product of the frequency and current index divided by `8`(the number of available keys) plus `1`. Once all key-value pairs have been examined, `ret` will contain the desired value.  

#### Conclusion
This solution has a time complexity of $O(n)$ where $n$ is the length of `word`. Instantiating the `Counter` `freq` requires $O(n)$ time to complete as it iterates over the entire length of `word` to count each letter. The key-value pairs of the resulting dictionary are then sorted, but since there can be 26 pairs at most, the time it takes to sort them is $O(1)$. Computing the total number of keypresses is also performed in $O(1)$ time, bringing the overall time complexity to $O(1)$. The space complexity is $O(1)$, since `freq` is a dictionary but has a constant size limit.  
  

