## 1593. (M) Split a String Into the Max Number of Unique Substrings

### `solution.py`
Given the string `s`, we are asked to return the largest number of substrings that can be achieved by splitting `s` such that all of the substrings are unique. For example, the string `abb` can be split into `a` and `bb`(or `ab` and `b`) to yield a value of `2`. Note that the split `a`, `b`, `b` is not valid as `b` is not unique in the set of substrings. Because the length of `s` is short(upper bound of 16), we can brute force the solution by using backtracking. Using a set to keep track of previously split substrings, we try exploring all possible splits of the remaining portion of the string. If the split results in a substring that has previously been seen, we exit out of the recursion and try a different split.  
`recurse` takes a single argument `idx`, which indicates the index of the first character of the unsplit portion of `s`. Previously split substrings will be stored in the aptly named set `substrings`. When `recurse(idx)` is called, we first check whether `idx == n`. If so, all characters have been examined, and we return the current size of `substrings`. All possible splits of the remaining suffix `s[idx:]` are then examined, consulting the contents of `substrings` to evaluate each split. If the substring resulting from the split at index `i` already exists inside `substrings`, the split is invalid and we move on to the next split. Otherwise, we first add the newly split substring `s[idx:i]` to `substrings`, update the maximum length `res` using the value returned from `recurse(i)`, and revert `substrings` to its original state by removing the substring `s[idx:i]`. The value we are interested is that returned by `recurse(0)`, which we can return directly.  

#### Conclusion
The time complexity of this solution is $O(n\cdot 2^n)$ where $n$ is the length of the string `s`. `s` can be split at `n-1` positions(between each adjacent pair of characters), which means that there can be $O(2^{n-1}) = O(2^n)$ possible combinations of splits. Each split extracts a substring from `s` through slicing, which has a linear time complexity that scales to the size of the substring being produced. Because the maximum length of a substring of `s` is $n$, the overall time complexity of the algorithm becomes $O(n\cdot 2^n)$. The space complexity is $O(n)$, due to the set `substring` and the recursion stack created by `recurse`.  
  

