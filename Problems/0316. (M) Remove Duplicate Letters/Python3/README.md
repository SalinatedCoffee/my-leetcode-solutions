## 316. (M) Remove Duplicate Letters

### `solution.py`
We want the lexicographically smallest string possible, and so it could be said that we should try keeping the smaller letters as far left as possible. Of course, we still want to leave at least one of each letter that appears in the original string `s`, and so we will need to keep this requirement under consideration while we build our string.  
Say we are building our string character by character, left to right. We currently have the substring `pre`, which we have built by examining the characters in `s[:i]`. For the character `s[i]` then, we obviously do not want to add it to `pre` if `s[i]` already exists in `pre`. If not, there are a few more steps to take before adding `s[i]`. As previously mentioned we want to put the smaller letters as far towards the left as possible. However, as the new string should essentially be a substring of the original string, we cannot simply rearrange the characters arbitrarily. That is, in order to 'move' `s[i]` towards the left, we must do so by **removing** the characters in reverse order. More specifically, if `pre` is 5 characters long and we want to have `s[i]` as the second character in `pre`, we must remove the 4 characters in `pre[1:]` and add `s[i]` so that `pre` is now 2 characters long. Hence, we should only removing a character from `pre` when it is 1; lexicographically larger than `s[i]`, *and* 2; the character appears again later on in `s[i+1:]`.  
A dictionary `last` is initialized, where `last[c]` will be the index of the very last occurance of letter `c` in `s`. So for example if `s = adcde`, `last['d'] == 3`. Then we initialize `letters` to use as our stack, and a set `in_stack` to keep track of which letters are currently on the stack. We then start iterating along `s`. If `s[i]` is in `in_stack`, we skip it and move onto `s[i+1]`. Otherwise, we also check if the letter top of the stack (`letters[-1]`) is lexicographically larger than `s[i]` and if `last[letters[-1]]` is larger than `i`. If so, we can pop the letter off of the stack and also update `in_stack` accordingly. If the check fails, we simply push `s[i]` on top of the stack, update `in_stack`, and move on to the next character.  
Once we have finished iterating over `s` we convert the stack into a string, which we can return immediately.  

#### Conclusion
This solution has a time complexity of $O(n)$, where $n$ is the length of `s`. `s` is iterated exactly twice, and over the duration of the second iteration constant-time operations on `letters` and `in_stack` can happen at most $2n$ times - hence the overall time complexity of $O(n)$. The space complexity is also $O(k)$, where `k` is the size of the alphabet of `s`.  
  

