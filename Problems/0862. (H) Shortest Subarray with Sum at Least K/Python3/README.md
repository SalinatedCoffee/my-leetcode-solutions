## 862. (H) Shortest Subarray with Sum at Least K

### `solution.py`
Given the list of integers `nums`, we are asked to determine the length of the shortest subarray of `nums` where its elements sum up to at least `k`. Because `nums` also contains negative numbers, a sliding window approach is no longer viable. Going back to the drawing board, we know that the brute force approach would involve examining all possible subarrays of `nums`. There are two problems with this approach; there are $O(n^2)$ subarrays in total, and evaluating each subarray will take $O(n)$ time to complete. One way to solve the latter would be to precompute the prefix sums of `nums`, which will allow us to determine the sum of any given subarray in constant time. For the former problem, we need to first think about the properties of the subarrays and their sums. Let's first assume that `nums[i:j]` is a valid subarray; that is, the sum of `nums[i:j]` is larger than or equal to `k`. If we were to use precomputed prefix sums to compute the sum of `nums[i:j]`, we would do so by evaluating the expression `pre[j] - pre[i-1]`. Let's also assume that `nums[i:k]` is also a valid subarray(where `k < len(nums)` and `j < k`). This means that the value of `pre[k] - pre[i-1]` would also be greater than or equal to `k`. If we were examining `nums` from the left towards the right, we would not care about this subarray since we have already encountered the valid subarray `nums[i:j]` which also starts with `nums[i]` but is shorter than `nums[i:k]`. In other words, we can disregard the prefix sum `pre[i-1]` in the future once we encounter a subarray that begins with `nums[i]`. Combining this observation with the fact that we would want to access the previous prefix sums in ascending order(since we want the subarray sum to be *at least* `k`, we would want to select the prefix `nums[:i+1]` that would maximize the value of `pre[j] - pre[i-1]` where the current prefix is `nums[:j+1]`), we can see that we could use a priority queue that presents prefixes in ascending order of their sums. Iterating over `nums` while keeping a rolling sum of the prefix ending at then current element, we can consult the priority queue to see if there are any prefixes that would form a valid subarray when paired with the current element. Once all elements of `nums` have been considered, we can return the length of the shortest observed valid subarray.  

#### Conclusion
This solution has a time complexity of $O(n\log n)$, where $n$ is the length of `nums`. Since the priority queue `heap` can hold at most $n$ elements, adding or removing an item from `heap` should be considered as $O(\log n)$ time operations. As it is guaranteed that $n$ insertions will occur during the runtime of this algorithm, with $O(n)$ possible removals, the overall time complexity comes out to be $O(n\log n)$. The space complexity is $O(n)$, due to `heap`.  
  

