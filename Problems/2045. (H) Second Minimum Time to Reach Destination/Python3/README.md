## 2045. (H) Second Minimum Time to Reach Destination

### `solution.py`
We are given an undirected graph with `n` nodes(labeled from `1` to `n`) and `edges` edges. When traversing said graph, we start at node `1` and eventually want to reach node `n`. The graph has a color which dictates whether we can move to a neighboring node or not. If it is green, we can move to an adjacent node immediately but cannot 'idle' at the current node. If it is red, we must wait until it becomes green before we can move. When the traversal begins the graph initially starts off as green, and alternates between the two colors every `change` amount of time. All edges in the graph requires `time` time to traverse. Given these conditions, we are asked to determine the *second* smallest amount of time required to traverse the graph.  
Without the second portion, the problem could be trivially solved through BFS. Since the edges all have the same weights we can treat them as being weightless, computing the amount of elapsed time as the graph is traversed. Another problem arises from the fact that a node can be traversed multiple times. If we were to allow this in the vanilla implementation of BFS, the algorithm would most certainly take too long to run. When we think about the problem some more, we realize that even for the second shortest 'path', a node would never be traversed more than twice. Hence, we can avoid performing any redundant traversals if we limit the number of node visits to 2. Based on this modification, we also know that we can traverse the graph using normal BFS, *ignoring* the destination on its first visit. Due to how BFS works, we know that when the destination node is visited a second time, the time elapsed is guaranteed to be the second smallest time.  
Before traversing the graph, we convert the list of edges into an adjacency list and initialize the lists `d1` and `d2`. `d1` will contain the smallest amounts of time required to reach a node from node `1`, while `d2` will contain the second smallest. Both lists will be filled with `-1`, which signifies that the node has not yet been visited. After initializing a queue with the tuple `(1, 1)`(current node `1` where the current visit is the `1`st visit), we start traversing the graph. The first order of business is determining the time elapsed the moment the current node is traversed. We use the value from `d1` or `d2` depending on the number of visits. The waiting time(if it exists) is added to that value before adding the time required to move to an adjacent node. Finally, the neighbors of the current node are examined. Looking at each neighbor, we check whether if it has never been visited or if it has been visited once. For the former we update the time elapsed in `d1`, after which the node is enqueued with a visit count of `1`. For the latter, we also check whether the elapsed time for the first visit is not equal to the current elapsed time. If so and the node is node `n`, we immediately return the current time. If the node is not `n`, we update the time in `d2` and enqueue the node with a visited count of `2`.  

#### Conclusion
This solution has a time complexity of $O(m+n)$, where $m$ is the length of `edges` and $n$ is `n`. Because each node can be traversed at most twice, the time required for the BFS step is $O(m+n)$. Converting `edges` into an adjacency list takes $O(m)$ time to complete, and instantiating `d1` and `d2` each requires $O(n)$ time. Hence, the overall time complexity of the solution is $O(m+n)$. The space complexity is $O(n)$, due to `nodes`, `d1`, and `d2`.  
  

