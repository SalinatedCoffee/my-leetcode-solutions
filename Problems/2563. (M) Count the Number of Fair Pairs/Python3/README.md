## 2563. (M) Count the Number of Fair Pairs

### `solution.py`
A 'fair' pair of integers in a list of integers satisfies the following conditions:  

- `0 <= i < j < len(nums)`, where `i` is the index of an integer in the list `nums` and `j` is the index of the other integer in the pair.  
- `lower <= arr[i] + arr[j] <= upper`, where `lower` and `upper` are integers and `lower <= upper`.  

Given these conditions, along with the list of integers `nums` and integers `lower` and `upper`, we are asked to return the number of fair pairs that can be formed using the elements of `nums`. Intuition tells us that we can sort `nums` in ascending order and use binary search to identify the subarray of `nums` that when paired with some element will form a fair pair. While the first condition seems to suggest that reordering the elements may not be a valid approach, we can see that the condition is there simply to disallow duplicate pairs. If we had the pair of elements `nums[i]` and `nums[j]` that satisfies only the second condition(meaning that `i > j`), we could simply swap the values of `i` and `j`, which would then satisfy the first condition as well. Building on these observations, we can now focus on figuring out exactly how we should be applying binary search on `nums`. As mentioned previously, we are interested in finding the subarray of `nums` where pairing each of its elements with some element `nums[i]` results in a fair pair. This means that we would have to perform binary search twice for each element in `nums`; once to find the lower bound and once to find the upper bound. For the lower bound, we would want to find the largest element that would be less than `lower` after adding the current value `nums[i]`. For the upper bound, we would want to find the largest element that would be less than `upper + 1` after adding the current value `nums[i]`. Note that we search for `upper + 1` instead of `upper` as we want to find values in `nums` that when added to `nums[i]`, would be less than *or equal to* `upper`. One more thing that we should keep in mind is that we want to avoid overcounting duplicate pairs. If we perform binary search on the entire array for each element of `nums`, we would end up counting pairs that have been already counted previously. To avoid this, we can simply exclude the elements from the first up to the current from the search space. If we iterate over `nums` from left to right, we can count all fair pairs without overcounting redundant ones.  
`nums` is first sorted in ascending order. We then start iterating over the sorted list, using binary search to identify the lower and upper bound of the subarray that would satisfy the conditions when paired with the current element. Python's built in `bisect` module offers various binary search functions, with `bisect_left` being the function we are interested in. `bisect_left` also supports customization of the initial search space, which we will use to limit the search onto the relevant portion of `nums`. The lower bound `l` can be identified by calling `bisect_left(nums, i+1, len(nums), lower-nums[i])`. We restrict the initial search space to `nums[i+1:len(nums)]`, and search for the value of `lower-nums[i]`. Because we are using `bisect_left`, this function call will return the correct index even if there are multiple elements with the same value that are equal to the search target. The upper bound `h` can be determined by calling `bisect_left(nums, i+1, len(nums), upper-nums[i]+1)`. The number of fair pairs that can be formed using the subarray `nums[l:h]` is simply the length of the subarray, which is the evaluated value of `h - l`. This is added to the total number of fair pairs `res` before moving onto the next element.  

#### Conclusion
This solution has a time complexity of $O(n\log n)$, where $n$ is the length of `nums`. Sorting `nums` using Python's built in sort requires $O(n\log n)$ time to complete. The search step that follows performs binary search on a suffix of `nums` twice for each element. Since there are $n$ elements, and a single binary search on `nums` finishes in $O(\log n)$ time, this step will also have a time complexity of $O(n\log n)$, putting the overall time complexity at $O(n\log n)$. The space complexity is $O(n)$, due to the sorting step.  
  

