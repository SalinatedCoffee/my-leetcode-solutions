## 51. (H) N-Queens

### `solution.py`
Given an integer `n`, we are asked to return a list of all placements of `n` queens on a `n*n` board where the queens cannot attack each other. A board should be represented by a list of `n` length containing strings that are `n` characters long. `.` corresponds to an empty square, and the letter `Q` corresponds to a square that has a queen. For example, the list `["Q..", "...", ".Q."]` would represent a (invalid) board where the squares `(1, 1)` and `(3, 2)` are occupied by a queen(1-indexed, origin is upper-leftmost square). Intuition tells us that we can use backtracking to solve this problem, where our algorithm backs out of a recursion branch as soon as it is determined that it is not possible to place any more queens in the current configuration.  
There are 3 pieces of information we need to keep track of to determine whether a queen can be placed on a square. We need the list of unoccupied rows, the list of unoccupied columns, and the list of coordinates for all queens currently on the board. The first two are obvious, since a queen can attack any piece that is on the same row or column as it. The last bit of information is required to determine whether a square lies on a diagonal of a queen, which can be determined by checking the absolute difference between the rows and columns. For example, say that a queen exists on the `i`th row and `j`th column and we want to determine whether a queen can be placed on the square on the `k`th row and `l`th column. Because either diagonal on the coordinate `(i, j)` has an 'absolute' slope of `1`, we know that `(k, l)` is on a diagonal of `(i, j)` if a line connecting the two points also has an absolute slope of `1`. This can be determined by simply checking whether the expression `abs(i - k) == abs(j - l)` evaluates to `True`.  
Now that we have established a method to determine whether a square is available for placement, we can start implementing the solution. The `n*n` 2D list `board` is initialized with `.`s, which will be used to store the current configuration of the board. The empty list `placed` and list of booleans `col_avail` are also initialized, where `placed` will contain the coordinates of all queens on the board and `col_avail` the availability of each column. Note that we do not explicitly store any information about the rows, which we will explain later. We then define the function `recurse` which takes a single argument `i` that represents the row that is currently being considered. If we sequentially place queens on each row, we know that all previously considered rows already have a queen on them and thus do not need to keep track of this information seperately. When `recurse(row)` is called we first check for the base case, which is when `row == n`. In this case we have placed a queen on all rows on the board, which means that the current placement is a valid one. We return after adding the current state of the board to the return list `ret`. Otherwise, we try placing a queen on each square on the row `row`. After checking that the current column is available, we iterate over `placed` to determine whether the square is on a diagonal of any of the queens currently on the board. If not, we update `board`, `placed`, and `col_avail`, before recursing on the next row. Once the recursive call returns, we revert the state to before the current square is added before moving to the next square on the row. The backtracking step is implied, since `recurse(row)` will simply exit without making any recursive calls if all squares on row `row` are unavailable for placement.  
  

#### Conclusion
The time complexity of this solution is $O(n!)$ where $n$ is `n`. Simplifying the problem, we know that we have $n-1$ columns to choose from after placing the first queen. After placing the second queen we have $n-2$ columns remaining, and so on. From this we get that there are $n\cdot (n-1)\cdot(n-2)\cdot...\cdot2\cdot1$ possibilities in total, which is the definition of $n!$. The space complexity is $O(n^2+n) = O(n^2)$, due to `board`($O(n^2)$), `placed`, `col_avail`, and the recursion stack($O(n)$ each).  
  

