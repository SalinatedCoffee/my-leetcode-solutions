## 823. (M) Binary Trees With Factors

### `solution.py`
As is usually the case with problems concerning trees we can take a recursive approach to this problem, memoizing the intermediate results to form a dynamic approach based solution. Given a list of integers `arr`, we are asked to compute the number of ways we can compute a *binary tree* where the product of two children equals their parent. `arr` contains only positive integers, which are all *strictly larger than 1*. Through this description we can deduce a couple of things about the trees that can be generated. A non-leaf node **must** have 2 children, as `arr` is guaranteed to not contain `1`. We also know that each value in `arr` can form *at least* 1 tree, by having a tree only consisting of a single node. Finally, a node can have children with identical values since the values in `arr` are unique, but we may use them however many times we want.  
The basic concept is rather simple. If we wanted to compute the number of ways to construct a tree rooted at some value `i`, and knew that value for all value in `arr` less than `i`, we could feasibly compute the total number of possible ways to construct the trees. Say we have a pair of factors of `i`, `j` and `k`. For each possible tree configuration for `j`, we can pair all tree configurations for `k`. That is, the total number of tree configurations for `i` given the factor pair `j` and `k` is simply the product of the number of trees for `j` and `k`. We can also see that `j` and `k` can be swapped, mirroring the tree congfigurations. The number of the mirrored configurations equal to the original ones, and thus we multiply the product of the values of `j` and `k` by `2`, only if `j` and `k` are *not equal*. We do this for every pair of `i`'s factor pairs, summing the values up. Finally, we add `1` to the sum to account for the single-node tree case mentioned previously.  
We recurse on all elements in `arr`, and return the sum of all of the return values.  

#### Conclusion
This solution has a time complexity of $O(n\log n)$, where $n$ is the length of `arr`. We pre-sort `arr` in descending order, which takes $O(n\log n)$ time. The recursion step will take $O(n)$ time, since each state is represented by a single value bound by $n$. The space complexity is also $O(n)$, both due to the sorting step and the recursion stack.  
  

