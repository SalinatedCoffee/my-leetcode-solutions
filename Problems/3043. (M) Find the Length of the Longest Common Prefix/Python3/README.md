## 3043. (M) Find the Length of the Longest Common Prefix

### `TLE.py`
Given the list of integers `arr1` and `arr2`, we are asked to return the length of the longest common prefix between elements of the two arrays. The obvious brute force approach would be to examine all possible pairs of values and return the length of the longest common prefix among all of them. Sadly, as is most often the case with brute force approaches, this algorithm will take too long to run and fails with TLE.  

#### Conclusion
This algorithm has a time complexity of $O(mnk)$, where $m$, $n$, and $k$ are the length of `arr1` and `arr2`, and the average length of the elements in both lists. The entirety of `arr2` is iterated for each element of `arr1`, and evaluating the common prefix of a pair of values scales linearly with the length of those values. Hence, the overall time complexity comes out to be $O(mn\cdot k) = O(mnk)$. The space complexity is $O(n)$ since the elements of `arr1` are incrementally converted into a string using `map`, but the entirety of `arr2` is converted and kept in memory.  
  

### `solution.py`
The previous attempt took too long to run because it compared all possible pairs of values. More specifically, we had to iterate over the entirety of the other list for each element in one list. This is where we can use a trie(also known as prefix trees) to iterate over all elements in a list simultaneously. The basic idea of tries is that it represents a collection of strings as a single n-ary tree(where n would be the size of the alphabet of the strings). A node represents a character, and its children corresponds to the set of characters that can come after that character amongst all strings in the trie. For example, if we had the list of strings `["10", "12", "17"]`, the node corresponding to the character `"1"` in the `0`th position would have the children `"0"`, `"2"`, and `"7"`. If we wanted to determine the length of the longest common prefix between the string `"18"` and the list of strings, we would start at the first character `"1"` and look at the children of the root of the trie. The root of the trie has the single child `"1"`, which is equal to the current character. We traverse to the node `"1"`, and move on to the next character, which is `"8"`. However, `"8"` is not among the children of the current node, which means that there are no strings in the list that have a prefix of `"18"`. The search is now complete, and the length of the longest common prefix between `"18"` and the list of strings is `1`. By generating a trie from one of the lists we can reduce the time complexity of the brute force solution by a factor of $n$(or $m$) at the cost of using some memory to store the trie.  
A trie is generated from the contents of `arr1`. Because we are only interested in the length of the common prefix, we can represent a single trie node using a dictionary. After initializing the root node, we start iterating over `arr1`, converting each number into a string and inserting it into the trie. Once the trie is fully populated, we iterate over `arr2`, searching for the longest common prefix between all numbers of `arr1`. After the iteration completes, `res` will contain the length of the longest common prefix between the two lists.  

#### Conclusion
The time complexity of this solution is $O(mk+nk)$. Populating a trie with the contents of `arr1` takes $O(mk)$ time to complete since there are $m$ numbers in `arr1` with each of them taking an average of $O(k)$ time to insert into the trie. Looking up the longest common prefix between `arr1` and a number in `arr2` also takes $O(k)$ time on average, with `arr2` containing $n$ numbers. Hence, the entire algorithm takes $O(mk+nk)$ time to run. The space complexity is $O(mk)$.  
  

