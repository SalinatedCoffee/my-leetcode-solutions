## 330. (H) Patching Array

### `solution.py`
Given a list of integers `nums` and an integer `n`, we are asked to return the minimum number of additions('patches') to `nums` so that all integers in the interval `[1, n]` can be formed by computing the sum of a subset of `nums`. For example, if `nums = [1, 2]` and `n = 4`, we can form `1`, `2`, and `3` using the contents of `nums` but cannot do so for `4`. In order to be able to form `4` we need to add either another `1` or a `3` to `nums`, and since in either case the required number of additions is `1`, we should return `1`. The problem is that there are many possible additions that can achieve the same effect using the same number of additions, which may affect the additions required for any value that follows. As `n` can be very large($2^{31} - 1$), as well as `nums`(`len(nums) <= 1000`), it is not possible to brute force the solution or remember each subset sum that have been computed. Instead, we need to take a 'induction-like' approach that will allow us to incrementally build up to an answer. Let's first assume that we know that `nums[:i]`(along with any newly added values) can form every integer in the interval `[1, j]`. What can we do if `nums[i]` is larger than `j+1`? Obviously we need to add an additional value, as we cannot add `nums[i]` directly since there will be a gap between `j` and `nums[i]` which cannot be formed using the current set of numbers. We can instead add `j` to the current set of numbers, and extend the interval to `[1, j*2]`. Because we could already form all integers in the interval `[1, j]`, adding `j` to the set will allow us to form all integers in `[j+1, j+j]`, bringing the entire interval to `[1, j*2]`. If `nums[i]` is less than or equal to `j*2`, we can add `nums[i]` to the set. Otherwise, we repeat the process until `nums[i]` can be added. What happens *after* `nums[i]` is added to the set? Using the same logic as earlier, adding `nums[i]` will allow us to form the integers in `[nums[i]+1, j*2+nums[i]`, expanding the interval to `[1, j*2+nums[i]]`. These steps are continued until the interval includes `n`, at which point we can return the number of additions made to `nums`.  

#### Conclusion
This solution has a time complexity of $O(n)$ where $n$ is `n`. The interval of 'formable' integers is either doubled or extended by a value in `nums` until it includes `n`. Each extending of the interval takes $O(1)$ time, thus bringing the overall time complexity to $O(n)$. The space complexity is $O(1)$.  
  

