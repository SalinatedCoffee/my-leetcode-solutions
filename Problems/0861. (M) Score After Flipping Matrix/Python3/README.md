## 861. (M) Score After Flipping Matrix

### `solution.py`
At first glance the problem may seem more difficult than it actually is, with intuition suggesting that some sort of dynamic programming approach may be needed. However, because only the values in each row are interpreted as a binary number, we can quickly see that a greedy algorithm can be utilized in implementing a solution.  
Let's first consider the case where a row is selected. We want to maximize the value of the binary number represented by the row, and so naturally we would want to make sure that the MSB is `1`. Thus, if the first element of the row is `0`, we should flip the entire row. We do not care about flipping `1`s to `0`s in the process, as any value where the MSB is `0` is smaller than the smallest value when the MSB is `1`(for example, `0b0111` is smaller than `0b1000`). Moving on to the columns, we can see that flipping a digit to `1` will add `1 << i`(where `i` is the 0-indexed number of the column from the right) to the sum of values and flipping it to a `0` will subtract the same value. Because all digits in a column are flipped indiscriminately, we need to decide whether flipping a column would increase the sum or not. This can be easily evaluated by simply counting the number of `1`s in the column; if there are less `1`s than there are `0`s, flipping the column would increase the total sum.  
Now that we know when to flip each row and column, we can start implementing a solution. As we want the MSB of *every* row to be `1`, we first make a row-by-row pass over `grid`. We then make a second pass that scans each column, after which we make one last pass that converts each row into an integer and adds it to the total.  

#### Conclusion
This solution has a time complexity of $O(mn)$ where $m$ and $n$ are the number of rows and columns in `grid`, respectively. The first, second, and third pass over `grid` each takes $O(mn)$, $O(2mn)$, and $O(3mn)$ time to complete. The row-by-row scan only checks a single value, which takes $O(1)$ time. The column-by-column scan has to count all `1`s in a column, requiring $O(m)$ time before flipping. Finally, the convert-than-sum step makes 3 passes over each row; first converting each value into a string, then concatenating said values, and then converting that string into an integer. The space complexity is $O(n)$ as we temporarily use extra memory to store the string representation of each binary number in `grid` before converting it into an integer.  
  

