## 729. (M) My Calendar I

### `solution.py`
We are asked to design the class `MyCalendar` that keeps track of booked events represented by a tuple corresponding to the starting and ending time of an event. `MyCalendar` should implement the method `book()`, which takes the integers `start` and `end`, which represents the starting and ending(exclusive) time of an event to be booked. If the event overlaps with a previously booked event, `book` should return `False` and ignore the given event. It should otherwise return `True` and book that event.  
If the given event is of the interval `[s2, e2)`, we can say it conflicts if there is at least 1 event `[s1, e1)` that is already booked where `e2 < s1` or `s2 < e1`. The most obvious brute force approach would be to store booked events in a simple list and scan through it every time `book` is called. While this approach may just work due to the small problem constraints(at most `1000` calls to `book`), we know that we can do better. Linearly scanning through the list of intervals is obviously not optimal. If the list was sorted, we can run binary search to find a specific interval in logarithmic time rather than linear. Taking this approach, the problem now becomes figuring out a way to efficiently maintain a sorted list when new items are added to it. Python's `heapq` module cannot be used here as it does not allow us to iterate over the elements in sorted order without removing/adding elements from/to the heap. Java's `TreeMap` class would be a perfect fit for this use case, but unfortunately Python does not offer any built in modules that guarantee a sorted ordering of inserted elements *and* supports 'read-only' random access of its elements. Instead of attempting to implement our own, we will use the external library [Sorted Containers](https://grantjenks.com/docs/sortedcontainers/). The module we are most interested in is Sorted Lists, which implements a list-like data structure that also guarantees that its elements are in sorted order. It also conveniently implements the binary search method `bisect_right`, which behaves exactly the same as the method of the same name in Python's built in `bisect` module.  
An empty `sortedcontainers.SortedList` object is instantiated and assigned to `MyCalendar.events` when a `MyCalendar` object is instantiated. When `MyCalendar.book(start, end)` is called, we first determine the index `idx` in `MyCalendar.events` where the tuple `(start, end)` should be inserted. We then examine the tuples at `idx` and `idx - 1`(if they exist) to evaluate the 2 inequalities described earlier. For the event at `idx - 1`, we compare its ending time with `start`. For the event at `idx`, we compare its starting time with `end`. If either comparison evaluates to `True` we have a conflict, and we return `False` without doing anything else. The event occurring at the time interval `[start, end)` is otherwise bookable, and we add it to `MyCalendar.events` before returning `True`.  

#### Conclusion
Instantiation of a `MyCalendar` object takes $O(1)$ time to complete.  
Calls to `MyCalendar.book` completes in $O(n\log n)$ time, where $n$ is the number of calls made to `MyCalendar.book`. The methods `SortedList.add` and `SortedList.bisect_right` both have a running time of $O(\log n)$, with $n$ corresponding to the number of elements that the `SortedList` object contains. Thus, each call to `MyCalendar.book` will take $O(\log n)$ time to complete, which means that processing all $n$ calls will take $O(n\log n)$ time to complete.  
The space complexity is $O(n)$.  

