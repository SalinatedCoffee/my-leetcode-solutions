## 1408. (E) String Matching in an Array

### `solution.py`
Given the list of strings `words`, we are asked to return a list of the strings in `words` that are a substring of another string in `words`. Because the size constraints on `words` and the strings that it contains is small, we can take a brute force approach that scans through the entirety of `words` for each string. Conveniently, Python's `in` operator performs substring matching when it is used on a string with a string. For example, `string_a in string_b` searches for an instance of `string_a` in `string_b`, evaluating to `True` if it exists and `False` otherwise.  

#### Conclusion
This solution has a time complexity of $O(n^2m)$, where $n$ is the length of `words` and $m$ is the average length of the strings in `words`. The entirety of `words` is examined for each word in `words`, and a pair of strings will take $O(m)$ time to process as we check whether a string is a substring of the other string. The space complexity is $O(1)$, excluding the returned list `res`.  
  


### `solution_2.py`
The previous solution has a catch - we used Python's `in` operator in order to determine whether a string is a substring of the other string, and we had just assumed that this was a $O(n)$ time operation. While this is true, this is because Python's `in` operator does not perform a naive search when looking for a pattern. The naive algorithm, which starts at the beginning of the substring candidate every time a mismatch is detected, will take $O(n^2)$ time to perform the substring search. We can instead implement the [KMP algorithm](https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm), which determines whether a string is a substring of another string in $O(n)$ time. The basic idea is that we preprocess the substring candidate before performing the search, keeping track of the length of the longest proper pre/suffix for each prefix of the candidate. For example, consider the string `ababaca`. The first prefix `a` has an LPS value of `0`, since a proper pre/suffix excludes the string itself. The next prefix `ab` also has a value of `0`, since `a != b`. Moving on to the next prefix `aba`, the longest proper prefix that is identical to the corresponding suffix is `a`, and thus `aba` has an LPS value of `1`. Examining one more prefix, the LPS value of `abab` is `2` since `s[:2] == s[-2:]`. Eventually, we will have the LPS value at all 7 positions, which will be used to 'skip over' the portion of the candidate string that we know is already matched against the target string. To illustrate this behavior, lets consider the candidate string `ababaca` and target string `ababbbcabdababaca`. As we start matching the candidate against the target, we can easily see that the characters will match up to index `3`, after which we detect a mismatch. We already know that the prefix `abab` of the candidate string has an LPS value of `2`. Visually, we can see that we can resume matching at index `2` of the target string and candidate string, since the proper prefix `s[:2]` of `s = abab` is identical to the proper suffix `s[-2:]`. As we can see, the KMP algorithm avoids having to restart at the first character of the candidate string every time there is a mismatch, allowing us to determine whether the candidate really is a substring of the target in linear time.  
We implement 2 helper functions `_compute_lps` and `_is_substring_of`, with the former taking a single string and returning the list of LPS values, and the latter taking 2 strings and the LPS values for the candidate string and returning whether the candidate is a substring of the target. For each string in `words`, the LPS values are computed first by calling `_compute_lps` passing in the string as the argument. The resulting list along with the string itself are compared to every other string in `words` by calling `_is_substring_of`, adding the candidate to the list of matched strings `res` whenever a match is found. Once all string pairs have been considered, we simply return the list of matched strings `res`.  

#### Conclusion
The time complexity is identical to that of the previous solution($O(n^2\cdot (2m)) = O(n^2m)$). The space complexity is $O(m)$, due to the list of LPS values generated for each string in `words`.  

