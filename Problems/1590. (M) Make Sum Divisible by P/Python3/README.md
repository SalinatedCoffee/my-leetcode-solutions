## 1590. (M) Make Sum Divisible by P

### `TLE.py`
Given the list of integers `nums` and integer `p`, we are asked to determine the length of the shortest *subarray* of `nums` such that excluding the subarray from `nums` results in the sum of `nums` being divisible by `p`. That is, we want to find the smallest value of `j - i` where the expression `(sum(nums) - sum(nums[i:j])) % p == 0` evaluates to `True`.  
The easiest approach would be a brute force based one, where we consider all possible subarrays until we find one that satisfies the condition. We first compute the sum of the entirety of `nums`, which is needed to determine whether removing a subarray will result in the sum of the remaining elements being divisible by `p`. Because the empty subarray is also allowed, we first check whether the sum of `nums` is already divisible by `p` before examining each subarray. When considering the subarrays we start with the shortest subarrays first, which will allow us to exit early as soon as we find one that satisfies the condition. Determining the validity of a subarray can be optimized through preprocessing `nums` beforehand. Instead of linearly scanning through the subarray each time to compute its sum, we can compute the sum in constant time if we know the sum of the prefix subarrays running up to the element previous of the first, and last element of that subarray. That is, we can compute the sum of the subarray `nums[i:j+1]` by evaluating the value of `pre[j] - pre[i-1]` where `pre[k]` is the sum of the array `nums[:k+1]`. Starting with subarrays of length `1`, we compute the sum of the subarray and subtract it from the sum of `nums`. If this value is `0`, it means that the subarray is valid, and we return the length of the current window.  

#### Conclusion
The time complexity of this algorithm is $O(n^2)$, where $n$ is the length of `nums`. Computing the sum of `nums`, as well as computing the prefix sums each require $O(n)$ time. Each and every subarray of `nums` is then examined, of which there are $n(n+1)/2$ of. Since evaluating the validity of each subarray requires $O(1)$ time to complete, the overall time complexity comes out to be $O(n^2)$. The space complexity is $O(n)$, due to the list of prefix sums `pre`.  
  

### `solution.py`
While correct, the previous attempt takes too long to run and fails with TLE. The main point of optimization would be the subarray searching step, where we had previously examined all possible subarrays of `nums`. Can we do better? Let's go back to our previous attempt, where we had determined the sum of each subarray using prefix sums. Consider the case where we know the sum of `nums[:j]` and all of its prefixes, and we are interested in finding subarrays that end with the element `nums[j-1]` and their sum modulo `p` is some integer `k`. That is, we want to find the index `i` where the sum of `nums[:i]` subtracted from that of `nums[:j]`(which is the sum of the elements in the subarray `nums[i:j]`) modulo `p` equals `k`. Obviously, there may be multiple valid indices `i`; but since we are only interested in the length of the shortest subarray, we only need the largest valid index. Because of this, we can iterate over `nums` while pulling double duty - updating the most recently seen index `i` where the sum of `nums[:i]` modulo `p` equals `k` for all `k` in the range `[0, p)`, and consulting these indices to determine the shortest length of the subarray ending at the current element whose removal would result in `nums` being divisible by `p`. The former can be accomplished by maintaining a dictionary where the key is some value in the range `[0, p)` and the value is the index. The latter can be achieved by looking at the value of the prefix sum up to the current element modulo `p` and the dictionary that was just mentioned. If the sum of the entire array modulo `p` equals some integer `k`, the sum of the subarray modulo `p` should also be `k` in order for it to be valid. We know the sum of the prefix up to the current element, and the 'most recent' indices of the prefix modulo of the values in the range `[0, p)`. Using this information we can compute the length of the shortest valid subarray ending with the current element in constant time, allowing us to find the length of the shortest subarray in linear time by making a single pass over `nums`.  

#### Conclusion
This solution has a time complexity of $O(n)$. Computing the sum of `nums`, as well as the length searching step requires $O(n)$ time each to complete, bringing the overall time complexity to $O(n)$. The space complexity is $O(max(n,k))$, where $k$ is `p`.  
  

