## 494. (M) Target Sum

### `solution.py`
Given the list of integers `nums`, we can add either a negative or positive sign to each value. Our task is to determine the number of sign combinations where the sum of all signed elements in `nums` is equal to `target`.  
Intuition tells us that a dynamic programming approach can be taken for this problem, as it can be broken down into smaller subproblems. For example, if the sum of the current sign combination of `nums[:idx]` is `cur`, we know that the sum of `cur`, `nums[idx]` *or* `-nums[idx]`, and `nums[idx+1:]` must be equal to `target` for the overall sign combination to be valid. If we knew the number of sign combinations of `nums[idx+1:]` that would make the sum equal to `target - cur - nums[idx]` and that for `target - cur + nums[idx]`, we could quickly determine the number of sign combinations for the current element `nums[idx]`. We also notice that there may be multiple combinations of `nums[:idx]` that sum up to `cur`, in which case the combinations for `nums[idx+1:]` would be counted redundantly. Thus, we can use memoization to remember intermediate results while recursing down the recurrence relations. Each state will be represented by 2 integers; `idx`, the index of the current value being considered, and `cur`, the sum of the current sign combination of `nums[:idx]`. If `idx` is equal to `len(nums)`, we have considered all values and we return `1` if `cur` is equal to target and `0` otherwise. If `idx` is *not* equal to `len(nums)`, we explore all possibilities regarding `nums[idx]` by making it negative and positive before recursing on the remaining section of `nums`. By definition of the recurrence relation, the desired value will be that of the state `(0, 0)`.  

#### Conclusion
This solution has a time complexity of $O(nk)$, where $n$ is the length of `nums` and $k$ is the sum of `nums`. Each state in the recurrence relation is represented by the integers `idx` and `cur`. `idx` is bound by $n$, and `cur` is bound by $k$; meaning that there are $O(nk)$ total states that are evaluated. Since evaluating a single state takes $O(1)$ time, the overall time complexity of this solution is $O(nk)$. The space complexity is also $O(nk)$, as the value of each state is memoized in memory until the algorithm completes.  
  

