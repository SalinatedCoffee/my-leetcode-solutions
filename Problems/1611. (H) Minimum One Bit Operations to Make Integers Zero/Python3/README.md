## 1611. (H) Minimum One Bit Operations to Make Integers Zero

### `solution.py`
This problem is not at all intuitive, but we can start chipping away by examining the most basic of cases for `n` - which is when `n` is a power of 2. Working a few examples by hand starting at `n == 1`, we can see that the number of operations required to convert $2^k$ is $2^{k+1} - 1$. However, `n` can of course be any integer in the range `0 <= n <= 10**9`. The immediate thought that springs to mind would be to 'deconstruct' `n` into powers of 2 and sum the number of operations for every term. This is indeed a valid way of converting `n` into `0` but is not guaranteed to be the *fastest* way, which is what the problem asks us for. One example would be when `n == 3`. `3` in binary is `11`, and according to the algorithm described above the number of steps to convert `3` into `0` would be `(2**2-1) + (2**1-1) = 3 + 1 = 4`. If we actually try out the conversion for ourselves, we see that the minimum number of operations is actually `2`, since `11 -> 01 -> 00`. The problem with the current algorithm is that it performs redundant operations when converting a value to `0`. In the earlier example, converting `10` to `00` takes 3 steps (`10 -> 11 -> 01 -> 00`). When `n == 11` however, the first step in converting `10` has already been performed.  
Let's step back and examine what we have in a more formal matter. Let the function $f(k)$ return the number of operations it would take to convert $2^k$ to $0$. Given some integer $n$, $n'$ is the integer derived by removing the MSB of $n$(which can be extracted by using bitwise XOR). If the function $A(n')$ returns the number of operations to convert an *arbitrary integer* $n'$, we can start to see the general picture of how we could apply recursion to the problem. For some integer $n$, we can feed the MSB to $f$ and the remaining bits to $A$. The question is, do we add the return values or do we subtract them? While we have not explicitly mentioned this previously, converting some integer $n$ to $0$ is *reversible*. That is, the number of operations required to convert $n$ to $0$ is equal to that of converting $0$ to $n$. Using this fact, we know that converting a power of 2 involves setting its $0$s to $1$s to eventually flip the MSB. Then if we split some integer $n$ into its MSB and remaining digits $n'$, we would have had to set the $0$ bits to $n'$ at some point to flip the MSB. Hence, we need to **subtract** $A(n')$ from $f(k)$, where $k$ is the MSB of $n$.  
Now that we have our recurrance relation, we can implement a recursive function that extracts the MSB and remaining digits of $n$ and then recurses on those values using the formula described above.  

#### Conclusion
This solution has a time complexity of $O(\log^2 n)$, where $n$ is `n`. The worst case is when *all* bits of $n$ are set, in which case we recurse $(\log n)$ times. The `while` loop that extracts the MSB takes $O(\log n)$ time to run as well, hence the overall time complexity of $O(\log^2 n)$. The space complexity is $O(\log n)$, due to the recursion stack.  
  

