## 380. (M) Insert Delete GetRandom O(1)

### `solution.py`
We are asked to design a class that stores values where insert, remove operations, as well as retrieving a random stored value all takes $O(1)$ time to perform. Naturally the first instinct would be to use a set to store the values, which trivialises the implmentation of insert and remove operations. The problem however, lies in the implementation of `getRandom`. There is no way to easily retrieve a random item in a Python set in constant time. In order to address this problem let's instead think about *how* we could select a random item in constant time. The obvious way to implement this would be to store the items in an array, which would allow us to randomly select a valid index in constant time. To have the best of both worlds (with a slight amount of overhead) we could store the items in a dictionary and a list. The dictionary would map a value to its index in the list, and the list would implicitly map an index to its value. This way, we can insert and remove items (Python's `list.append` takes amortized constant time) as well as select a random item all in constant time. There is still one more problem that needs solving, which is how we deal with removed items. The na√Øve implementation would create 'holes' in the list, forcing us to randomly generate integers repeatedly until we get a valid index(which by the way, takes $O(n)$ time). Ideally we would want the items in the list to be stored neatly in a single contiguous region. This can be achieved by partitioning the list into two regions, the 'void' where the stored elements are considered to be invalid (and consequently can be overwritten without repercussion) and a 'valid' region where only the values that are actually currently stored in the `RandomizedSet` object are held. For this solution we have chosen to keep the invalid region on the left and the valid region on the right. The border is represented by a single integer which is the index of the first element in the valid region in the list. Whenever an item is removed, we swap the item in the list to that denoted by the integer mentioned earlier. Essentially, the invalid region grows towards the right whenever an item is removed. The valid region first grows towards the left if there is available space, and then grows towards the right. This behavior allows us to maintain a contiguous region of relevent values, as well as having the added benefit of minimizing additional memory usage. When `getRandom` is called, we simply choose a random element in the valid region of the list. Python's `random.randint` is perfect for this situation as it has a uniform probability distribution and supports custom ranges.  

#### Conclusion
All four methods have a time complexity of $O(1)$. `insert` and `remove` accesses a list and a dictionary once each, with both operations taking $O(1)$ time to complete. `getRandom` uses Python's built-in PRNG to randomly select an integer, which takes $O(1)$ time to do so. The overall space complexity for `RandomizedSet` is $O(n)$ where $n$ is the total number of calls to `insert`.  
  

