## 1061. (M) Lexicographically Smallest Equivalent String

### `solution.py`
Since we're using Python, you would be tempted to use Python `set`s to solve this problem as it supports various set operations such as `isdisjoint()`, `union()`, or `intersection()`. And while it works (I haven't tried it myself but solutions using `set`s *should* be accepted) I think it misses the point of this problem. It's like saying "Watch me draw a painting" and then using Stable Diffusion to generate an image. So let's try analyzing the problem and seeing how we can do it another way.  
One thing to keep in mind is that equivalence relations in this problem are transitive and reflexive, so for string pairs like `ab` and `bc` the relation becomes `a == b == c`. Since this is an equivalence relation, we can also represent it using a set. In this case `a` would be the letter of interest, for obvious reasons. Instead of looking up the lexicographically smallest letter in a set every time we convert a letter, we want to somehow point all of the other letters to (in this case) `a`. For this, we can use a [disjoint-set](https://en.wikipedia.org/wiki/Disjoint-set_data_structure) (more commonly known as union find) since it lets us perform rank-based set merges and specify set representatives with optimal inserts and lookups.  
Here we use a dictionary to keep track of the parents of each letter. We are also using the ranked variant of union find, where a letter has a higher rank if it is lexicographically smaller. This is implemented in `uunion()` where we first get the highest ranked letters from a letter pair and perform a set merge based on their ranks. `ufind()` is trivial to implement since all we have to do is follow the node chain until we reach the highest ranked node (which will have itself as its parent).  

#### Conclusion
This solution has an amortized time complexity of $O(n+m)$, where $n$ is the length of `s1` and $m$ is the length of `baseStr`. Union find overall has a runtime of $O(n)$ but for for individual operations has an amortized runtime of $O(1)$, which we do `len(s1) + len(s2) + len(baseStr)` times. Thus, $O(n+n+m) = O(2n+m) = O(n+m)$. The space complexity is $O(1)$ since the number of nodes in the union find is fixed at 26 (or $O(m)$ if you count the return string).  
  
