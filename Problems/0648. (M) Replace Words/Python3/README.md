## 648. (M) Replace Words

### `solution.py`
A brute force solution that converts `dictionary` into a set of words and attempts to find all possible prefixes of each word in `sentence` will obviously take too long. We can instead implement a trie to facilitate efficient prefix matching and thus greatly bring down the time complexity. As the implementation of a [trie](https://en.wikipedia.org/wiki/Trie) is rather simple, we will not go over its details in this writeup.  
We first implement the `Trie` class, which keeps track of the root of the trie and provides methods that adds and matches words against its contents. Each internal `TrieNode` has 2 instance variables; a dictionary `TrieNode.children` that keeps track of references to its child nodes, and a boolean `TrieNode.end` that signifies whether the current node corresponds to an end of a word. `Trie.add(word)` adds the string `word` to the `Trie` object, and `Trie.match(word)` returns the index of the character in `word` that comes after the last character in the shortest prefix of `word` that exists in the `Trie` object(for example, if the trie contains the words `ab` and `abc`, `match('abcd')` will return `2`). If a prefix does not exist, it returns `-1`. We then instantiate a `Trie` object and add the contents of `dictionary` into it. Then we split `sentence` using the whitespace as the delimiter, and iterate over each word while searching for it in the trie. If the word does not exist in the trie, we leave the word as-is. Otherwise, we swap the current word with its prefix using the return value from `Trie.match()`. Finally, we contatenate the words back into a sentence using Python's `string.join()` method.  

#### Conclusion
This solution has a time complexity of $O(mk+nk)$ where $m$ is the length of `dictionary`, $n$ the length of `sentence`, and $k$ the average length of words in `dictionary` and `sentence`. When adding the contents of `dictionary` to the trie, each word has to be iterated over to access the appropriate child of each character. Thus, this step takes $O(mk)$ time to complete. During the matching step splitting `sentence` takes $O(n)$ time, but the split words have to be checked against the contents of the trie. As there are $O(n)$ words in a string of length $n$, this step takes $O(n+nk) = O(nk)$ time, bringing the overall time complexity to $O(mk+nk)$. The space complexity is $O(mk)$ because the trie can contain $O(mk)$ nodes. Each node can have 26 key-value pairs at most, but since this adds a constant factor, the overall space complexity is still $O(26mk) = O(mk)$.  
  

