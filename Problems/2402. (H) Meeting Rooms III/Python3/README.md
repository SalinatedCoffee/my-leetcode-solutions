## 2402. (H) Meeting Rooms III

### `solution.py`
Given a list of schedules and number of rooms, we are asked to determine the room used the most after every meeting has concluded. If there are multiple vacant rooms, those with the smaller numbers should be booked first. Similarly, delayed meetings should be held in ascending order of their original starting times. This tells us that we would want to access the smallest numbered room / earliest delayed schedule first, which intuition tells us that we can use heaps to implement such behavior.  
`meetings` are first sorted in ascending order of starting times. We then initialize 2 heaps and 1 list. The heaps will each store all available rooms and ending times of all booked meetings along with the room number. The list will store the number of times each room was used. As we iterate over `meetings`, we check the min heap of booked meetings and 'evict' those that will have already ended by the time the current meeting is scheduled to begin. Then we check if there are any rooms available. If so, we simply book the current meeting as-is by popping off a room number from the available heap, incrementing the usage count for that room number, and pushing the end time and room number of the current meeting onto the booked heap. Otherwise, we greedily 'pre-book' the current event to the room with the meeting that concludes the earliest (which will be on top of the heap), pushing the *delayed* ending time onto the booked heap. Since the newly booked meeting **must** take place immediately after the preceding one, we pop the top-most item off of the booked heap.  
Once all meetings have been considered, we iterate over the usage counts of all rooms and return the earliest room number that held the most meetings.  

#### Conclusion
This solution has a time complexity of $O(m\log n + m\log m + n)$, where $m$ is the length of `meetings` and $n$ is `n`. Sorting `meetings` takes $O(m\log m)$ time; hence the second term. `meetings` is then iterated over, where for each meeting we perform a limited number of insert/remove operations on `vacant` and `booked`. As these heaps can each contain at most $n$ elements, an operation will take $O(\log n)$ time to complete; hence the first term. Finding the earliest room with the most number of usages takes $O(n)$ time, and corresponds to the third term. The space complexity is $O(m+n)$ as the sorting step takes up $O(m)$ space, with `vacant`, `booked`, and `usage` each using $O(n)$.  
  

