## 10. (H) Regular Expression Matching

### `solution.py`
Given two strings `s` and `p`, we are asked to match `p` against `s`. `s` is a string consisting of only letters of the lowercase English alphabet, and `p` contains a regular expression consisting of lowercase English letters and the characters `.` and `*`. A `.` means that any character can be matched against it, and a `*` means that any number(including 0) of characters that precedes the `*` can be matched against it. Because of the quantifier `*`, we cannot naively match `p` against `s` in an iterative manner. Since multiple valid matches can be made against a pattern 'window' ending with a `*`, we must explore all possible matches. This can be achieved through recursion, where we try recursing down after each valid match of `p`. The function `recurse(s_idx, p_idx` will return `True` if `p[p_idx:]` can be matched against `s[s_idx:]`, and `False` otherwise. The first thing to check when `recurse` is called is whether we have reached the end of `s`. If so, we also check whether we have reached the end of `p`, returning `True` if so. If `s` still contains characters yet to be matched, we try matching the current portion of the pattern `p` against the current character of `s`. The first order of business is to check whether the characters match. Since in a pattern the character to be matched always comes before a quantifier, this can be easily achieved by simply comparing the characters at `s[s_idx]` and `p[p_idx]`. We store the result in `char_match` for future reference. Then, we look ahead 1 character in `p` to see whether `p[p_idx]` is suffixed by a quantifier. If so, we also need to consider the case where we match no characters of `s`, which we can do by consulting the return value of `recurse(s_idx, p_idx+2)`. Of course, it is still possible that matching one or more characters is the correct choice; which we can determine by looking at the values of `char_match` and `recurse(s_idx+1, p_idx)`. By structuring the recurrence relation in this way, we know that this call will return `True` if any of the possible substrings match. As the initial character must also match, we only consider the case where `char_match` *and* `recurse(s_idx+1, p_idx)` are `True`. If there is no quantifier, we check whether the character pair matches(which is simply the value of `char_match`) and whether the remaining substrings of `s` and `p` also match against each other.  
One case that is not explicitly mentioned in the problem description is when there are multiple consecutive quantifiers(`p = 'a******'`, for example). In this case, we can compress the consecutive quantifiers into a single quantifier, for obvious reasons. In the implemented solution, this case is handled by the order of which the recursive branches are explored. In line 19, notice how the case where the character in `s` is not taken is explored first. This will skip over the consecutive `*`s, which has the same effect as compressing them into a single quantifier.  

#### Conclusion
This solution has a time complexity of $O(mn)$, where $m$ and $n$ are the length of `s` and `p`, respectively. Each state in the recurrence relation has 2 arguments `s_idx` and `p_idx`, each of which are bound by $m$ and $n$. Since evaluating each state takes $O(1)$ time to complete, the overall time complexity becomes $O(mn)$. The space complexity is also $O(mn)$, since we memoize all intermediate results in memory.  
  

