## 2272. (H) Substring With Largest Variance

### `solution.py`
Because we are working with substrings, the first instinct will be to take a sliding window approach to the problem. We are not however optimizing the variance between two characters but rather the variance accross **all** possible pairs of characters in the string. Due to this we cannot make informed decisions on whether we should extend or shrink the window, which is critical in coming up with a sliding window algorithm. The (admittedly less intuitive) solution is to look at this problem as a maximum subarray sum problem. Variance is defined as the absolute difference between the number of occurences of two characters in `s`. So for `s = "aaabc"` for example, the variance is `3 - 1 = 2` for `a, b` and `a, c`, and `1 - 1 = 0` for `b, c`, for the entirety of `s`. We want the largest variance across all possible substrings of `s`, which is where Kadane's algorithm comes in. Kadane's algorithm solves the maximum subarray sum problem in linear time. We can apply this by selecting two characters and counting the number of those characters, effectively disregarding other characters and 'replacing' one character with `1` and the other with `-1`. Then, by running Kadane's algorithm we can determine the largest variance between the two selected characters across all substrings of `s`.  
There are however a few issues that prevent us from directly applying Kadane's algorithm in this fashion. Firstly, we must account for substrings that do not contain either one of the selected characters. Returning to the previous example, if we are looking at `a` and `c`, we would need to ignore the variance of the substring `"aaab"`. This can be achieved by only updating the overall variance when the frequency of the 'secondary' letter is non-zero. Secondly, we need to know when to 'discard' the results from the previous subarrays. In the original version of Kadane's algorithm this is achieved with an operation similar to `current_sum = max(0, current_sum + x)`. The algorithm tries to *maximize* the sum of a subarray, and thus there is no point in carrying over the maximum subarray sum of the previous region if it is negative. Our problem with this is that this will discard the frequencies for both letters, which is undesirable if the remaining region of `s` does not contain the secondary character. For example, if `s = "abbaaa"` where `b` is the secondary character, the variance will become negative at the third character. If both frequencies are reset the remaining region does not contain the character `b`, and thus the maximum variance will end up as `0` despite it clearly being `2` for the substring `"baaa"`. This can be remedied by keeping track of the remaining number of the secondary character, which can be trivially precomputed for all possible characters.  
Now we can simply run our modified algorithm for all possible pairs of letters, and return the maximum value directly.  

#### Conclusion
This solution has a time complexity of $O(26\cdot 26\cdot n) = O(n)$, where $n$ is the length of `s`. The alphabet of `s` is all lowercase letters in the English alphabet, which is comprised of 26 letters, and we check every possible pair. For each pair we run our modified Kadane's algorithm which has a running time of $O(n)$, hence the overall running time of $O(26^2 n)$. The space complexity is   
  

