## 75. (M) Sort Colors

### `solution.py`
The easy solution is to simply perform a counting sort on `nums`. Since there are only 3 types of 'colors' in `nums`, we can initialize an empty list of length 3 with `0`s. We make an intial pass over `nums` while counting each color in the frequency list. Then we make a second pass over `nums`, overwriting it with colors according to the frequency counts from earlier.  

#### Conclusion
This solution has a time complexity of $O(n)$ where $n$ is the length of `nums`. `nums` is iterated over twice, with each round of traversals taking $O(n)$ time to complete. The space complexity is $O(1)$, as we only use a single list of fixed length.  
  

### `solution_2.py`
The follow up question asks us to implement a solution that only makes a single pass over `nums`. This can be achieved by the [Dutch National Flag algorithm](https://www.geeksforgeeks.org/sort-an-array-of-0s-1s-and-2s/)(also known as 3-way partitioning). Essentially, we maintain 2 pointers to `nums` while it is iterated. All elements before the first pointer will satisfy some condition, those that come after the second pointer will satisfy another, and the elements between the two pointers will satisfy another condition still. More specifically, we will maintain two pointers `l` and `h` where `nums[:l]` will only contain `0`s, `nums[l:h]` only `1`s, and `nums[h+1:]` only `2`s. `l` is initialized to `0`, and `h` to `len(nums)-1`. Starting at the `0`th element of `nums` up to `h`(which will, of course, slowly move towards the left as `nums` is sorted) we move the current element `nums[i]` to either `l` or `h` depending on its value. If it is `1` it is already at the correct location, and we move onto the next element. If it is `0` we swap it with `nums[l]`, advancing `l` by `1` before moving onto the next element. If it is `2`, we swap it with `nums[h]`, after which we advance `h` by `1`(towards the left) and **stay in place**. The reason that we only advance `m` when the value of `nums[i]` is `0` or `1` is rather simple; because we move `nums[i]` to `nums[h]` if it is `2`, we know that `nums[:i]` can *only contain* `0`s and `1`s. That is, it is *guaranteed* that `nums[l]` will be `1`. Hence, when `nums[i] == 0` we will essentially be swapping it with `1`, and because that `1` is in the correct position within `nums`, we move on to the next element. The same cannot be said for when `nums[i] == 2`, as `nums[h]` can be either `0` or `1`. In this case we need to re-check the swapped element and move it into the correct position.  
  
#### Conclusion
The time and space complexity is identical to the first solution, but only makes a single pass over `nums` as requested by the follow up question.  