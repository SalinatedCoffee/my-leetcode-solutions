## 1569. (H) Number of Ways to Reorder Array to Get Same BST

### `solution.py`
For this problem, one of the easier mistakes that can be made is misinterpreting the given array as a representation of a BST instead of a sequence of elements being inserted into a BST. Thus `nums = [3, 4, 2]` would represent a tree where node `3` has left and right children of `2` and `4`, respectively. Since `nums` represents the insertion order of elements, we know that the first element `nums[0]` is always the root of the entire tree. We also know that any element in `nums[1:]` that is **smaller** than `nums[0]` will be in the **left** subtree of `nums[0]` and vice versa. If we generate two lists from `nums[1:]` `left` and `right`, where values smaller or larger than `nums[0]` is stored respectively, we can see that our logic up until now can be recursively applied to these two lists. That is, `left[0]` will be the root of the tree represented by `left` (the left subtree of `nums[0]`) and elements in `left` smaller than `left[0]` will be in the left subtree of `left[0]` and vice versa. Because of this recursive relationship, it stands to reason that the generated BST will be the same as long as the relative positions of the items in `left` and `right` are preserved. For example, if `nums = [3, 1, 2, 4, 5]`, `left` and `right` will be `[1, 2]` and `[4, 5]`, respectively. The left and right children of `3` will be `1` and `4`, but notice how `[3, 1, 4, 2, 5]` would also result in the same BST. The order of `nums[1:]` is changed, but the **relative** positions of the elements in `left` and `right` are left untouched. There are of course other permutations that will generate the same BST but in the end this simply boils down to counting the number of ways we can *interleave* `left` and `right`, or, $n\text{C}r$ where $n$ is the length of `nums[1:]` and $r$ is the length of `left` (or `right`). All of this however, pertains to computing the number of permutations at a single depth. The permutation number of the left and right subtree can be retrieved recursively, which we need to take the product of to compute the total possible number of permutations.  
Putting all of this together, let $f(nums)$ be the value of the number of permutations of $nums$ that results in the same BST. If the length of $nums$ is less than $3$, the return value is $1$ since it is not possible to rearrange $nums$ without changing the structure of the BST. If not, $f(nums) = P\cdot f(left)\cdot f(right)$ where $P = _{\text{len}(nums)-1}\text{C}_{\text{len}(left)}$ and $left$, $right$ are lists of elements that are smaller or larger than the first element in $nums$, respectively. Using this definition, we can trivially implement a recursive divide-and-conquer solution.  
One last thing to keep in mind is that we need to subtract 1 from the resulting number, since the above method counts the initial state of `nums`, but we want the total number of **permutations** of `nums`.  

#### Conclusion
This solution has a time complexity of $O(n^2)$, where $n$ is the length of `nums`. The height of the recursion tree is $O(n)$ since the length of `nums` is reduced by 1 each call, and at each level we do $O(n)$ amount of work generating $left$ and $right$. The space complexity is $O(n)$.  
  

