## 1915. (M) Number of Wonderful Strings

### `solution.py`
At first glance it would seem that this problem could be solved with a sliding window based approach. However, since a 'wonderful' string can contain *up to* 1 letter with odd frequency there is no clear way to decide when or when not to contract the window. Instead, we can split this problem into two parts; finding the substrings where *all* characters have even frequencies, and finding those where *one* character has an odd frequency.  
For the former, we first need to decide on how we should be representing the frequencies of each letter in a substring. As we want to count substrings based on the odd/evenness of each letter, we should avoid storing explicit frequencies for each letter. If we instead keep track of the odd/evenness, we can trivially count the number of substrings with no letters with odd frequency. We can think about this in terms of computing the difference between two prefixes. For example, if the current prefix `word[:i]` has 2 letters with odd frequency, any prefix of the current prefix `word[:i]`(excluding itself) where the exact 2 letters are also odd can be removed from the current prefix to yield a substring with zero odd letters. A more concrete example would be when `word = "abccc"` and `i = 5`. Here, the current prefix would be `abccc`, which would have `a`, `b`, and `c` as odd letters. If we look at the prefixes of `abccc`, we see that `abc` also has the exact same configuration - indeed, if we remove `abc` from `abccc` we get the substring `cc` which does not contain any odd characters.  
We can build upon the algorithm described to count substrings that have exactly one odd letter. Previously we counted substrings with the same odd/even configuration as the current string. To find those that would yield substrings with one odd letter we simply need to count prefixes with configurations that differ from the current by only one letter. Again returning to the example `word = "abccc"`, we see that the prefix `ab` differs from the configuration of `abccc` by only 1 letter, and removing `ab` from `abccc` indeed yields `ccc`, where exactly 1 letter is odd.  
Now that we know how to count the desired substrings, we need to integrate these algorithms into a single solution. We will represent the configuration of each substring as an integer, where the `i`th least significant digit(0-indexed) will be `0` if the `i`th letter of the alphabet is even and `1` otherwise. The dictionary `masks` will contain key value pairs where the key is the bitmask of some configuration and the value the number of times that configuration has appeared. Iterating over each character in `word`, we first update the current bitmask by flipping the bit corresponding to the current letter. Then we count the prefixes that would yield a substring with zero odd letters by incrementing the counter `ret` by the frequency of the current mask. After updating said frequency by incrementing it by `1`, we count all prefixes that would yield a substring with one odd letter by flipping each digit of the current mask and incrementing `ret` by the frequency of the newly flipped mask.  
Once the entirety of `word` has been examined, we can directly return `ret` which will contain the desired value.  

#### Conclusion
This solution has a time complexity of $O(nk)$ where $n$ is the length of `word` and $k$ is the size of the alphabet of $n$. $n$ is iterated over exactly once, and processing each character takes $O(k)$ time as we perform a 'sweep' over each bit of the mask. Hence, the overall time complexity is $O(nk)$. The space complexity is $O(n)$ since `masks` will contain the bitmasks of all prefixes of `word`, which there are $n + 1$ of.  
  

