## 402. (M) Remove K Digits

### `solution.py`
At first glance this problem looks like it can be solved by taking a dynamic programming approach. This approach however involves indiscriminately trying all possible options for every single digit, resulting in an exponential time complexity. We can do better by realizing that there is a way to greedily remove digits while iterating over `num`, using an increasing monotonic stack to store the digits to be included in the final string. Iterating over `num`, we want to include a digit only if it is larger than or equal to the last digit that was included. If the last digit included is larger than the current digit, we exclude the last digit and compare the second-last digit with the current, repeating the process until either there are no included digits remaining or we have exhausted our deletion budget `k`. This allows us to greedily remove digits by 'replacing' a larger digit with a smaller digit, thus minimizing the final value. For example, consider the case where `num = 143`, `k = 1` and we are currently examining `3`. The list of included digits will be `['1', '4']` according to the algorithm described previously. Comparing the last added digit `4` with the current `3`, we see that `4` is larger than `3`. Thus, we remove `4` from the included list, after which the last added digit (second-last before the removal) is `1`, which *is* smaller than `3`. `3` is thus added to the included list, yielding the string `13`.  
We initialize an empty list `digits` before iterating over `num`. `digits` will serve as our monotonic stack, where the stored values will be in increasing order at any point in time. While there are remaining removals (`k` is not `0`), we iterate over `num`. If the top item of `digits` is larger than the current digit `num[idx]`, we pop it off of the stack and decrement `k` by `1` until either the stack is empty, no removals remain, or the topmost item is smaller than or equal to the current digit. We then push `num[idx]` onto the stack, increment `idx`, and repeat. When the loop exits, we concatenate the included digits `digits` and the remainder of `num`, `num[idx:]` to reconstruct the final string. Before returning said string, we need to remember to check for 2 things; whether there are any leading zeros, and whether there are any removals left. The former is easy enough to handle. For the latter, we remove digits from the **right**. We want to minimize the numeric value of the final string; and if there are removals remaining after the loop exits, it means that the entirety of `num` has been examined, and that all included digits will be stored in `digits`. Since `digits` is an increasing monotonic stack, we want to remove the digits with the largest values, hence the removal from the right side. Finally, if the resulting string is empty we return the string `0` instead of the empty string, as required by the problem.  

#### Conclusion
This solution has a time complexity of $O(n)$ where $n$ is the length of `nums`. `nums` is iterated over once, with each character taking constant time to process. The space complexity is also $O(n)$, due to the monotonic stack `digits`.  
  

