## 962. (M) Maximum Width Ramp

### `solution.py`
The list `nums` is a list of non-negative integers. A 'ramp' within `nums` is defined as the difference `j - i`, where `i < j` and `nums[i] <= nums[j]` are both true. Given this definition, we are asked to determine the width of the longest ramp that can be formed in `nums`.  
Simplifying the problem to a single element of `nums`, we essentially want to find the smallest index `i` where `nums[i] <= nums[j]` for all possible `j`. Intuition tells us that we can use a monotonic stack to solve this problem, but how exactly should we be using it?  
First off, the width of a ramp depends on the relative indices of values in `nums`. That is, if `nums[i] <= nums[j] <= nums[k]` and `i < j < k`, the ramp formed by `nums[i]` and `nums[j]` **must** be narrower than the one formed by `nums[i]` and `nums[k]`. Therefore, if we consider the elements of `nums` in the reverse direction we can 'discard' `nums[i]` as a candidate for the left side of a ramp once we pair it with `nums[k]` to form a ramp. Secondly, if we consider right side candidates in the reverse direction, we would want to be able to access the left side candidates in increasing order of their values, while preserving the relative order of their appearances in `nums`. That is, if we find that `nums[i]` can be paired with `nums[k]`, we would want to quickly identify the index `j` where `j < i`, `nums[j] > nums[i]`, and it is guaranteed that there are no values less than `nums[i]` between `nums[j]` and `nums[i]`. These two observations tell us that we should first populate a decreasing monotonic stack from `nums`, after which we iterate over `nums` backwards to determine the widths of candidate ramps.  
After initializing an empty stack `stack`, we iterate over `nums`. For each element of `nums`, we push the value and its index onto `stack` if either `stack` is empty, or the top-most item is larger than the current value. We then initialize the maximum width as `0` before making a second pass over `nums`, but in the reverse direction. For each element, we consult the top-most item on `stack`. If it and the current item can form a ramp, we update the maximum width `res` as necessary before popping the item from the stack. These steps are repeated until either `stack` becomes empty or the top-most item cannot form a ramp with the current item. Once the entirety of `nums` has been examined, `res` will contain the desired value.  

#### Conclusion
This solution has a time complexity of $O(n)$, where $n$ is the length of `nums`. During both passes over `nums`, processing a single element requires $O(1)$ time to complete. The space complexity is also $O(n)$, due to `stack`.  
  

