## 1190. (M) Reverse Substrings Between Each Pair of Parentheses

### `solution.py`
Given the string `s` which contains lowercase English letters and parentheses, we are asked to return the resulting string where a substring enclosed in a parenthesis pair is reversed starting with the innermost substring. For example, if `s = "(ab(xyz)c)"`, the innermost substring `xyz` is reversed first resulting in the intermediate string `(abzyxc)`. Since this string is too enclosed in a parenthesis pair, it is also reversed resulting in the final modified string `cxyzba`. As is usually the case with problems involving parentheses, this problem can also be solved by using stacks. Instead of using a stack to store parentheses to be matched against however, we store the prefix of each parenthesis 'depth' where the bottom of the stack holds that of the outermost substring and the top the innermost. Whenever a close parenthesis is detected, we pop the substring from the top of the stack, reverse it, and then append it to the substring currently on top of the stack.  
After instanstating the empty stack `stack`, we iterate over each character of `s`. There are 3 possible category that each character can fall under. If it is a `(`, we prepare to accept new characters for the current parenthesis depth by pushing an empty string onto the stack. If it is a `)`, we pop an element off of the stack, reverse it, and check whether the stack is currently empty. If so, it means that the current substring is in fact the final modified string and we simply add it back onto the stack to return later. Otherwise, we pop an item of the top of the stack, reverse it, and concatenate it with the string currently on top of the stack, as mentioned earlier. Finally, if the character is a letter we simply concatenate it to the substring on the top of the stack.  
Once all characters have been considered, the first(and only) item in `stack` will be the answer. Of course, it may also be the case that the outermost string is *not* enclosed in a parenthesis pair(`s = "a(bcd)e"`, for instance). This case can be easily handled by checking whether `s` starts with an open parenthesis before iterating over it. If it does start with one, we do nothing. Otherwise, we push the empty string on `stack`.  

#### Conclusion
This solution has a time complexity of $O(n^2)$ where $n$ is the length of `n`. The algorithm reverses the current substring every time it encounters a `(`. Since there are $O(n)$ possible strings of length $O(n)$, and reversing a string of length $n$ takes $O(n)$ time, the overall time complexity comes out to be $O(n^2)$. The space complexity is $O(n)$, due to the exsistance of `stack`.  
  

### `solution_2.py`
The previous solution had to spend quadratic time as it reversed a substring multiple times. For example, when `s = "(ab(cde(fg)))"` the substring `fg` would be reversed thrice when a single reversal would have sufficed instead. If we think about the problem a bit deeper, we know that the direction of each substring alternates as the depth changes. That is, if the direction of a substring at depth `i` is left-to-right, all substrings at depth `i+1` will have a direction of right-to-left, and so on. We can exploit this property to 'weave' in and out of `s` though parenthesis pairs, changing the iteration direction whenever a jump is performed. Let `s` be the string `"a(bcd(ef)g)hi"`. Iterating over `s`, the first character we encounter is an `a`. We append this character to the end of the modified string(which is currently empty) and move on to the next character, which is an `(`. Looking at `s`, we can see that the matching close parenthesis is the `)` at index `10`. We thus *jump* to index `10`, and *reverse* our traversal direction to right-to-left. After advancing the pointer we will be at index `9`, which is the character `g`. As we did with `a`, we append this character to the modified string to get the intermediate string `ag`. Notice that this is exactly what we would end up if we had processed `s` using the algorithm from the first solution. The outermost characters `a`, `h`, and `i` are *not* enclosed in a parenthesis pair, and should thus be presented in original order in the modified string. The characters `b`, `c`, `d`, and `g` *are* enclosed in parentheses, and are `1` depth deeper than the outermost characters. Hence, these characters should be presented in reverse order in the processed string. Continuing on with the example, we advance the pointer once more to end up at index `8`, which is yet another parenthesis. This time the matching parenthesis is at index `5`, which we jump to and reverse direction once again. The next character is `e` at index `6`, which is appended onto the result string. Fast-forwarding a few characters, we will end back up on index `8` before encountering any other parentheses. This is where the magic happens; we will again jump to index `5`, but since the iteration direction is reversed yet again, the next character will be the `d` at index `4`. If we continue to work through the example we can see that all letters in `s` are processed exactly once, with each substring being traversed in the correct direction. Once we reach the end of `s`, we know that we have examined every letter of `s` and can return the resulting string that we have constructed.  
  
#### Conclusion
The time complexity of this solution is $O(n)$. As described above, the algorithm iterates over each letter of `s` exactly once, with each character taking $O(1)$ time to process. Hence, the overall time complexity is $O(n)$. The space complexity is also $O(n)$, due to `portals`, `parens`, and `ret`.  