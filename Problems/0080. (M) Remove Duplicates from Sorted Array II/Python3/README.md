## 80. (M) Remove Duplicates from Sorted Array II

### `solution.py`
Given a list of integers `nums` sorted in ascending order, we are asked to 'compress' this list be removing any excess elements from the third duplicate onwards. For example, let `nums = [1, 1, 1, 1, 2, 3, 3, 3]`. Since there are 4 `1`s and 3 `3`s, the compressed list would look like `nums = [1, 1, 2, 3, 3, _, _, _]`, with underscores representing any integer. The problem also asks us to return the number of remaining elements in order to determine the length of the processed list, which in this example would be `5`. Because we must perform the compression in-place, we need to keep track of where the processed section ends and the unprocessed section starts. We can achieve this by using two pointers, where one points to the last processed element and the other points to the unprocessed element currently being considered. To determine whether an element should be removed while iterating over `nums`, we need to keep track of the number of duplicates of that number previously seen. We store this information in the variable `dupes`, which is initialized to `1`. The pointers `l` and `h` are also initialized to `0` and `1`, respectively. Since the first item of `nums` is never deleted, we can skip it to avoid having to deal with out of bounds indices. For each element in `nums` we check whether it is equal to `nums[l]`, which is the last element in the processed portion of `nums`. If they are equal, `dupes` is incremented by `1`. If they are not, `duples` is reset to `1`. We then determine whether a new value needs to be added to the processed array by looking at the number of duplicates. If it is less than or equal to `2`, we add the current element `nums[h]` to the processed section before moving on to the next unprocessed item. Once all elements of `nums` have been examined we simply return `l + 1`.  

#### Conclusion
This solution has a time complexity of $O(n)$ where $n$ is the length of `nums`. `nums` is iterated over at most twice(since `l` and `h` both advance over `nums` in a linear fashion), and since each element takes $O(1)$ time to process, the overall time complexity comes out to be $O(n)$. The space complexity is $O(1)$, as requested by the problem.  
  

