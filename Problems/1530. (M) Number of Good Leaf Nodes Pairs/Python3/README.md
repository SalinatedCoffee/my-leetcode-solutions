## 1530. (M) Number of Good Leaf Nodes Pairs

### `solution.py`
Given the root node of a binary tree and the integer `distance`, we are asked to return the number of pairs of leaf nodes where the minimum distance between the node are less than or equal to `distance`. We could of course, simply traverse the tree starting at each and every leaf node. This however involves a lot of work as we need to create reverse edges between nodes(since we have to be able to move to a parent node), find all leaf nodes, and finally traverse the tree for each leaf node. Instead, we can perform a single LRN(postorder) traversal on the binary tree while counting the number of valid leaf pairs at each node. At some node, we can easily count the number of valid pairs if we have a list of distances to all leaf nodes in the left and right subtrees. The two lists are then concatenated before being updated and returned.  
The global integer `self.ret` is first initialized, and will represent the number of valid pairs counted up to this point. We then implement the function `recurse`, which takes a single argument `node`. `recurse(node)` will return a list of distances from `node` to each leaf node in the subtree that has `node` as its root. When it is called, it should first check whether it is a leaf node. If it is, we immediately return `[1]`. Otherwise, we first call `recurse` on `node`'s children. The number of valid pairs is then counted, after which the lists from the child nodes are concatenated and the distances updated. By definition of `recurse`, the value we want is that of `self.ret` after `recurse(0)` has finished executing.  

#### Conclusion
The time complexity of this solution is $O(n^3)$ where $n$ is the number of nodes in the binary tree rooted at `root`. A single DFS traversal is performed on the given tree, which takes $O(n)$ time to complete. At each node, all pairs of leaf nodes from its children are considered. Since the number of leaf nodes is bound by $n$ this step will take $O(n^2)$ time to complete, resulting in the overall time complexity of $O(n^3)$. The space complexity is $O(n)$ since `recurse(node)` returns the list of distances between `node` and its leaves, and the recursion stack can be at most $n$ tall.  
  

