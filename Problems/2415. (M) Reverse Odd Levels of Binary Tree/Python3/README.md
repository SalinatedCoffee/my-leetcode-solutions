## 2415. (M) Reverse Odd Levels of Binary Tree

### `solution.py`
Given the root node `root` of a perfect binary tree, we are asked to reverse the node values at each odd level. We can immediately see that this problem can be solved through recursion, traversing the tree and swapping the positions of child nodes whenever it is appropriate to do so. Because we want to reverse the node values of an entire level, simply swapping the children of the current node is not enough. If we think about what it means to reverse a sequence of values, we can see that the first element becomes the last element, the second element becomes the second-to-last, and so on. In other words, we take the first and last elements, swap them, and move on to the second and second-to-last items, moving inwards until all pairs have been swapped. Conveniently, the given tree is also a perfect binary tree - which means that we do not have to consider the case where a few nodes are missing.  
As we have previously discussed, a naive DFS traversal will not work for this problem. Instead, we recursively do work on *pairs* of nodes, incrementally moving down a level after processing the nodes. Visually, we have a good idea as to how the nodes should be paired. Let's first consider the easiest case, which is the two children of the root node. The pair of nodes are at an odd level, and as such, their values should be swapped. Moving on to their children, how should these nodes be paired? Obviously, we would want to pair the left child of the left node with the right child of the right node, and the right child of the left node to the left child of the right node. If we think about this behavior in a recursive context, we can see that the correct nodes will be paired at any level. We may now implement this algorithm in code, running the recursive function on the children of `root` before returning `root` itself.  

#### Conclusion
This solution has a time complexity of $O(n)$, where $n$ is the number of nodes in the tree rooted at `root`. The recursive function `recurse` traverses each node exactly once, with each node pair taking $O(1)$ time to process. The space complexity is $O(\log n)$. Since the given binary tree is perfect, the height of the tree is $\log n$. As `recurse` recurses down the tree, the maximum depth of the recursion stack scales linearly with the height of the tree being traversed; hence the space complexity of $O(\log n)$.  
  

