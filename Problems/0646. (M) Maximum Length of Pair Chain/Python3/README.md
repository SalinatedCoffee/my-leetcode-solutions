## 646. (M) Maximum Length of Pair Chain

### `solution.py`
We may choose pairs regardles of their position in `pairs` - that is, a chain consisting of the 5th, 3rd, and 7th elements in that order is a valid chain. Thus we need not preserve the original spatial information of these pairs, which means that we may sort the list to make things easier for us. The problem is that we are unsure as to which value of the pair to sort `pairs` on. One important detail that we should keep in mind when trying to make this decision is that `pairs[i][0] < pairs[i][1]`. If we sort the list based on the first value, we may end up with a list such as `[[1, 99], [1, 2], [4, 7],...]`. NaÃ¯vely iterating over this list we will end up choosing `[1, 99]` instead of `[1, 2]`, which is clearly the optimal choice. Would sorting `pairs` based on the second value allow us to implement a greedy solution then? Assume we encounter 2 pairs in the sorted list: `i` and `j`, in that order. Since we encountered `i` first, it must be the case that `i[1] <= j[1]`. There are 2 scenarios given these two pairs; either `i[1] < j[0]` (at which point we can trivially choose both pairs) or `i[1] >= j[0]`. For the latter, we may only choose either `i` *or* `j` but not both. We do not yet have any information of the pairs that lies beyond `j`, but it stands to reason that we should try and keep the maximum value of the chain as small as possible so that we may potentially add more pairs to the chain. But then, we have already established that `i[1] <= j[1]`. If `i[1] == j[1]`, it does not matter which pair we choose. If `i[1] < j[1]`, it is optimal to choose `i` over `j`. Thus, it is **always** optimal to choose `i` over `j`, and now we may start implementing a greedy algorithm.  
We first sort `pairs` based on the second value of the pairs. Then we iterate over the sorted list while keeping track of two elements `ret` and `prev`. `ret` is the length of the longest chain at a certain point in time, and `prev` is the right value of the last pair in the chain (or maximum value of the chain). For each pair `i`, if the pair is choosable (`i[0] > prev`) we greedily add that pair to the chain by incrementing `ret` by `1`, and assigning `i[1]` to `prev`. Once the iteration has completed we can directly return the value of `ret`.  

#### Conclusion
This solution has a time complexity of $O(n\log n)$, where $n$ is the length of `pairs`. Python's built-in `sorted()` takes $O(n\log n)$ time, and iterating over the sorted list will take $O(n)$ time. The space complexity is $O(n)$, as `sorted()` uses $O(n)$ memory and we create a copy of `pairs` instead of performing an in-place sort.  
  

