## 2392. (H) Build a Matrix With Conditions

### `solution.py`
Given the lists `rowConditions` and `colConditions`, along with the integer `k`, we are asked to return a valid `k` by `k` matrix using these arguments. `rowConditions` is a list of lists of size 2, where `rowConditions[i][0]` represents the value that must come *above* the value `rowConditions[i][1]`. `rowConditions[i][1]` may appear at any row in the constructed matrix. `colConditions` follows the same logic, with the difference being that `colConditions[i][0]` should appear to the *left* of `colConditions[i][0]`. The constructed `k` by `k` matrix will contain each integer in the range `[1, k]`, with all other elements being `0`.  
At first glance, it may seem that in order to solve this problem we could take a backtracking-like approach. This would involve trying to place each integer in the interval on each cell, backing out to try another value whenever it is determined that the value cannot be placed according to `rowConditions` and `colConditions`. This would however be very inefficient as we would have to scan the entirety of `rowConditions` and `colConditions` for every possible value placement. We can do better by realizing that we can interpret the given conditions as a dependency graph, the nodes of which can be ordered in order of their appearance in the matrix by performing a topological sort. After topologically sorting the nodes for the rows and columns, we can convert the sorted lists into coordinates that can be used to fill the matrix appropriately.  
The function `build_graph` will take a list of conditions and return a adjacency list of the corresponding directed graph, as well as a list of indegrees for all `k` nodes. These are then given to the function `topo_sort` as arguments, which will run [Kahn's algorithm](https://en.wikipedia.org/wiki/Topological_sorting#Kahn's_algorithm) and return the topologically sorted list of nodes. Implementations of the two functions are very straightforward, with `topo_sort` implementing Kahn's algorithm without any modifications. It does not however, check whether the nodes can be sorted using topological sort. We can easily check this by comparing the length of the sorted list against `k`. If they are not equal, the nodes in the graph cannot be topologically sorted and thus a valid matrix reconstruction does not exist. Otherwise, we use the resulting lists to populate the 2D list `ret`, which can be directly returned after it has been filled.  

#### Conclusion
This solution has a time complexity of $O(m+n+k^2)$, where $m$, $n$ are the lengths of `rowConditions` and `colConditions` respectively, and $k$ is `k`. Topological sorting scales with the number of edges it is given, resulting in the calls to `topo_sort` taking $O(m+k)$ and $O(n+k)$ to complete. Converting the conditions into adjacency lists and counting the indegrees for each node are also linear-time tasks. Initializing the zero matrix `ret` takes $O(k^2)$ time, and filling it takes $O(k)$ time. Thus, the overall time complexity of this solution is $O(m+n+k^2)$. The space complexity is $O(k^2)$, due to the adjacency lists having the worst case size of $O(k^2)$(when every node has outgoing edges to all other nodes).  
  

