## 1371. (M) Find the Longest Substring Containing Vowels in Even Counts

### `solution.py`
Given the string of lowercase English letters `s`, we are asked to return the length of the longest substring of `s` that contains an even number of each vowel(a, e, i, o, and u). At first glance the problem looks like a sliding window problem since we are dealing with optimizing a substring. Upon further ideation however, we can quickly see that this approach is not feasible because there is no clear criteria to expand or contract the window by. We start by considering the most straightforward algorithm that can solve the problem but may not be the most efficient. The brute force approach involves checking all possible substrings of `s`, counting the number of each vowel for each and every substring. Obviously, this approach will take too long and would most likely fail with TLE. We can speed this approach up by a factor of `len(s)` by realizing that we can compute the number of each vowel in a substring in constant time if we have the list of cumulative appearance of each vowel. That is, we can compute the number of `'a'`s in `s[i:j]` if we know the number of `'a'`s in `s[:i]` and `s[:j]`. Actually, we do not even need to keep track of the exact number of each vowel since we are only interested in whether a substring contains an odd or even number of vowels. Returning to the given example if `s[:i]` and `s[:j]` *both* contain either and odd or even number of `'a'`s, we can definitively say that `s[i:j]` contains an even number of `'a'`s, and odd otherwise. The same can be said for the other vowels; and because there are a fixed number of vowels we can consider this vowel counting step as a constant time operation. Another optimization opportunity exists in the order of substrings to be considered. As we want the length of the longest valid substring we would naturally want to examine the longest substrings first, as that would allow us to return early the moment we find a valid substring.  
We first generate the prefix oddity of each vowel by iterating over `s`. `counts[i][j]` is `True` if `s[:j+1]` contains an even number of `ctoi[i]`, and is `False` otherwise. Once `counts` has been fully populated we examine the substrings of `s`, starting with the longest substring(which is simply the entirety of `s`). Once all substrings have been evaluated, we reduce the candidate substring length by `1` and scan through `s` again. These steps are repeated until a valid substring is found, at which point we may immediately return the size of the current substring.  

#### Conclusion
This solution has a time complexity of $O(n^2)$ where $n$ is the length of `s`. Preprocessing `s` into `pre` requires $O(n)$ time to complete. The substring evaluation step that follows examines all possible substrings of `s`, of which there are $n(n+1)/2 = O(n^2)$ of. Evaluating a single substring is a $O(1)$ time operation, thus bringing the overall time complexity of this solution to $O(n^2)$. The space complexity is $O(n)$, due to `counts`.  
  

