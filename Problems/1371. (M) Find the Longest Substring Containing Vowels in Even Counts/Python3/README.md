## 1371. (M) Find the Longest Substring Containing Vowels in Even Counts

### `solution.py`
Given the string of lowercase English letters `s`, we are asked to return the length of the longest substring of `s` that contains an even number of each vowel(a, e, i, o, and u). At first glance the problem looks like a sliding window problem since we are dealing with optimizing a substring. Upon further ideation however, we can quickly see that this approach is not feasible because there is no clear criteria to expand or contract the window by. We start by considering the most straightforward algorithm that can solve the problem but may not be the most efficient. The brute force approach involves checking all possible substrings of `s`, counting the number of each vowel for each and every substring. Obviously, this approach will take too long and would most likely fail with TLE. We can speed this approach up by a factor of `len(s)` by realizing that we can compute the number of each vowel in a substring in constant time if we have the list of cumulative appearance of each vowel. That is, we can compute the number of `'a'`s in `s[i:j]` if we know the number of `'a'`s in `s[:i]` and `s[:j]`. Actually, we do not even need to keep track of the exact number of each vowel since we are only interested in whether a substring contains an odd or even number of vowels. Returning to the given example if `s[:i]` and `s[:j]` *both* contain either and odd or even number of `'a'`s, we can definitively say that `s[i:j]` contains an even number of `'a'`s, and odd otherwise. The same can be said for the other vowels; and because there are a fixed number of vowels we can consider this vowel counting step as a constant time operation. Another optimization opportunity exists in the order of substrings to be considered. As we want the length of the longest valid substring we would naturally want to examine the longest substrings first, as that would allow us to return early the moment we find a valid substring.  
We first generate the prefix oddity of each vowel by iterating over `s`. `counts[i][j]` is `True` if `s[:j+1]` contains an even number of `ctoi[i]`, and is `False` otherwise. Once `counts` has been fully populated we examine the substrings of `s`, starting with the longest substring(which is simply the entirety of `s`). Once all substrings have been evaluated, we reduce the candidate substring length by `1` and scan through `s` again. These steps are repeated until a valid substring is found, at which point we may immediately return the size of the current substring.  

#### Conclusion
This solution has a time complexity of $O(n^2)$ where $n$ is the length of `s`. Preprocessing `s` into `pre` requires $O(n)$ time to complete. The substring evaluation step that follows examines all possible substrings of `s`, of which there are $n(n+1)/2 = O(n^2)$ of. Evaluating a single substring is a $O(1)$ time operation, thus bringing the overall time complexity of this solution to $O(n^2)$. The space complexity is $O(n)$, due to `counts`.  
  


### `solution_2.py`
Even though the order of evaluation allowed us to return an answer early, the previous solution still ran in quadratic time in the worst case. We can reduce the running time by a factor of $n$ by exploiting the fact that there are only 5 vowels, and the status of each vowel can be represented by a single boolean. As mentioned in the previous solution, we only care whether if a substring contains an even or odd number of each vowel. Because of this, we were able to represent the oddity of each vowel with a single boolean. At this point, we can clearly see that we can represent the oddity of all vowels with a 5 bit integer - that is, a single integer within the range `[0, 31]`. We had also previously established that a substring `s[i:j]` contains an even number of a vowel of the oddity values of the vowel for `s[:i]` is equal to that of `s[:j]`. That is, if the 5 bit 'oddity integer' of `s[:i]` is equal to that of `s[:j]` we can confidently say that the substring `s[i:j]` contains an even number of each vowel. Representing the oddity of a substring with a 5 bit integer also allows us to simply keep track of the earliest index at which each 'oddity integer'(or the vowel bitmask) appears within `s`. If we use a list `seen` with length 32 to represent this, the value of `seen[i]` would be the smallest value of `j` where the vowel bitmask of `s[:j]` is equal to `i`. We only care about the earliest index as we are interested in maximizing the length of a valid substring. When iterating over `s`, we maintain a vowel bitmask corresponding to the prefix substring ending at the current character. If the bitmask has been previously encountered, we use the index from `seen` to compute the length of the longest valid substring ending at the current character and update the previous longest length as necessary.  

#### Conclusion
This solution has a time complexity of $O(n)$. Initializing `seen` requires $O(1)$ time to complete as it has a fixed length regardless of the size of the input. `s` is then iterated over, with each character taking $O(1)$ time to process - resulting in an overall time complexity of $O(n)$. The space complexity is $O(1)$ as all variables and data structures kept in memory are of a fixed size.  

