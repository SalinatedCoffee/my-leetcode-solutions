## 287. (M) Find the Duplicate Number

### `solution.py`
We will first start off by addressing the first follow-up question. How do we prove that there is at least one duplicate number in `nums`? Given the problem constraints, `nums` contains values in the range `1 <= i <= n`, and is `n+1` long. If each number could only appear once, we would have `n` different values in `nums`, but `nums` has a length of `n+1`. Hence, we can definitively say that `nums` **must** contain at least one duplicate value.  
The second follow-up question, along with the problem requirements asks us to implement a linear-time solution that uses constant space and does not modify `nums`. This means that we cannot utilize sorting in our solution, as that would require either modifying the input array, allocating additional memory, or ending up with a worse-than-linear time complexity. Once again going over the problem description, we notice that the values are *mostly* unique - that is, excluding 1 value that is duplicated, all other values are unique in `nums`. If we imagine `nums` as a representation of a linked list, where the value in `nums[i]` points to the value at that index in `nums` (so that following the `next` pointer would simply be `nums[nums[i]]`), we know that we will eventually run into a cycle since `nums` contains duplicates of some number. You may be wondering what would happen if we encountered a 'node' where its value is equal to its index - would we not we simply fall into an infinite cycle? The answer is rather simple; because the range of the values start at `1`, but `nums` is 0-indexed, it is guaranteed that the cycle-inducing node is the duplicate value (attempting to come up with a contradiction with small sizes of `nums` will make this apparent).  
At this point we realize that we can take a two pointer approach for this problem, where two pointers travel along a list at varying speeds. If at any point the two pointers point to the same node, we know that there is a cycle. For this problem however, we also want to know the entry point of the cycle - that is, the number that occurs more than once in `nums`. The node from the cycle detection step is in the cyclic section of the list. We initialize a new pointer `finder`, that initially points to the first item in `nums`. The slow pointer from the first step and the `finder` pointer are than advanced at the same rate until they point to the same node, which is the entry point for the cycle.  

#### Conclusion
This solution has a time complexity of $O(n)$, where $n$ is the length of `nums`. The space complexity is $O(1)$.  
A more rigorous explanation can be found [here](https://keithschwarz.com/interesting/code/?dir=find-duplicate) - where it is said that it apparently took 24 hours for the man, the myth, the legend, [Knuth](https://en.wikipedia.org/wiki/Donald_Knuth) himself to come up with this solution.  
Make of that what you will.  

