## 1605. (M) Find Valid Matrix Given Row and Column Sums

### `solution.py`
Given the lists `rowSum` and `colSum`, where the two lists contain the sum of each row and column of a matrix respectively, we are asked to reconstruct and return a valid matrix where the sums of its rows and columns match those of `rowSum` and `colSum`. There may be multiple valid reconstructions, in which case we only need to return one of them. First off we know that for some element in the matrix `matrix[i][j]`, the inequalities `matrix[i][j] <= rowSum[i]` and `matrix[i][j] <= colSum[j]` must be true for `matrix` to be a valid reconstruction since `matrix` only contains non-negative integers. If we put the two inequalities together we get the inequality `0 <= matrix[i][j] <= min(rowSum[i], colSum[j])`, which **must** hold for all `i` and `j`. Using this inequality, we can incrementally reconstruct the original matrix by greedily assigning the largest possible value for each element. We can do this because `rowSum` and `colSum` are guaranteed to reconstruct into at least 1 valid matrix. The `min()` function in the inequality protects against cases that would lead to a different element in the same row or column becoming a negative value, and because an element can have a value of `0`, we do not care about 'exhausting' a sum.  
Before we start building the matrix the lists `c_rowSum` and `c_colSum` are initialized with `0`s, and will contain the current sums of each rows and columns in the reconstructed matrix. After initializing a 2D list `ret` with the same dimensions as the original matrix, we start iterating over the 2D list of `0`s starting at the element on the top left. For each element `ret[i][j]`, we assign it the value `min(rowSum[i] - c_rowSum[i], colSum[j] - c_colSum[j])`. As `c_rowSum` and `c_colSum` contain the *current* sums of each row and column in `ret`, we are essentially determining the 'available' value for the `i`th row and `j`th column and assigning `ret[i][j]` the largest value possible without making `rowSum[i]` or `colSum[j]` negative. After updating the values of `c_rowSum[i]` and `c_colSum[j]`, we move on to the next value, continuing until every element of `ret` has been filled.  

#### Conclusion
This solution has a time complexity of $O(mn)$ where $m$ and $n$ are the lengths of `rowSum` and `colSum`, respectively. Initializing `c_rowSum`, `c_colSum`, and `ret` each takes $O(m)$, $O(n)$, and $O(mn)$ time. Reconstructing the matrix also takes $O(mn)$ time, bringing the overall time complexity to $O(mn)$. The space complexity is $O(m+n)$, due to `c_rowSum` and `c_colSum`.  
  

