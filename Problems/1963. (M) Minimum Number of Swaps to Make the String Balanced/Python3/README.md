## 1963. (M) Minimum Number of Swaps to Make the String Balanced

### `solution.py`
The string `s` is of even length and is comprised of `len(s) / 2` open brackets(`[`) and the same number of close brackets(`]`). If we are allowed to swap 2 characters within `s` in a single step, we are asked to return the minimum number of swaps required to make `s` balanced. Given that this is a parenthesis balancing problem, the first instinct would be to take a stack-based approach. The problem now becomes determining how to adapt the usage of a stack to the swapping component. If we swap an unbalanced pair of brackets, how many unbalanced brackets could we balance at most with this single swap? The answer is obviously 2 since the position of 2 brackets are affected in a single swap. Because the constraints on `s` makes it guaranteed to be able to be balanced, and we do not care about the exact steps to make `s` balanced or what the balanced string looks like, we can simply assume that each swap is performed optimally. Now that we know the number of brackets that can be balanced with a single swap, we can simply count the number of unbalanced brackets and use that value to compute the number of swaps that must be performed to balance `s`. Since we are performing optimal swaps as much as possible the computed number of swaps is guaranteed to be the minimum number of swaps required.  
We initialize the empty stack `stack` before iterating over `s`. If the current character is `[`, we push it to the stack. If it is `]`, we pop an item off of `stack` if it is not empty. If it is, the current character cannot be matched and so we increment the counter `hanging` by `1`. Once the iteration completes, we compute the number of required swaps by evaluating the expression `(hanging + 1) // 2`. Note that we add `1` to `hanging` before it is divided by `2` to account for the case where there is an odd number of mismatching brackets. In this case we must perform a single non-optimal swap that balances 1 bracket. Since we are performing integer division to compute the number of swaps, adding `1` to `hanging` will increase the quotient by `1` if `hanging` is odd, which is exactly what we want.  

#### Conclusion
This solution has a time complexity of $O(n)$, where $n$ is the length of `s`. `s` is iterated over exactly once, with each character requiring $O(1)$ time to process. The space complexity is also $O(n)$, due to `stack`.  
  

### `solution_2.py`
The memory footprint of the previous solution can be optimized by realizing that we do not have to keep each instance of the brackets stored in `stack` in memory. Since we are only interested in the number of unmatched brackets, we can represent this state by using a single integer. While iterating over `s`, `hanging` is incremented by `1` if the current character is `[`. Otherwise, it is decremented by `1` if it is larger than `0`. Computing the number of required swaps is identical to the previous solution.  
  
#### Conclusion
The time complexity of this solution is identical to the previous one. The space complexity is $O(1)$, as we do away with the stack from the previous solution and instead use a single integer to keep track of the number of unmatched brackets in `s`.  