## 834. (H) Sum of Distances in Tree

### `solution.py`
The trivial solution would be to traverse the tree `n` times starting at each node, computing the sum of the distances from each node to all other nodes. Traversing a graph however is a linear time operation, which brings this approach to $O(n^2)$ time complexity. As the bound on `n` is rather large(`30000`), this method will fail with TLE. We need to devise a method to speed this process up, which we can achieve with a technique called [rerooting](https://www.geeksforgeeks.org/sum-of-length-of-paths-from-every-node-to-all-other-nodes-using-tree-rerooting-technique/). Essentially we are applying dynamic programming to the tree traversal, using previously computed values to quickly evaluate the value for the current state.  
Because it is guaranteed that the given graph will be a tree, there are a few things that we can take for granted. There will only be one connected component in the graph(all nodes are reachable from each other), and the graph will be acyclic. Because of this, we can select any node in the graph and make it the root. If we know the sum of distances from all nodes for an arbitrary root, we can use this value to quickly compute those of its neighboring(child) nodes. By moving from the root to one of its children, we are moving *away* from the root by 1, and moving *closer* to those in the subtree of that child node. Since each edge has a distance of `1`, moving towards to the nodes in the subtree of the child node `child` will decrease the distance sum by `sub[child]` where `sub` is a list containing the size of each subtree rooted at a node in the tree. The opposite can be said for the nodes **not** in the subtree rooted at `child`, thereby increasing the distance sum by `n - sub[child]`. Thus, for some node `i` and its child `j`, the sum of distances for node `j` can be computed by evaluating the expression `distance_sum[i] - sub[j] + (n - sub[j])`. After this operation, `j` is now the 'root' node; hence the 'rerooting' moniker.  
Now that we know how to quickly compute the distance sum for a node's neighbor, we first need to compute the distance sum for an arbitrary node and the subtree size for each node. This can be done with a single DFS pass over the tree. Once we have these initial values, we run DFS over the tree a second time, performing rerootings to each and every node in the graph. By the end of the second DFS pass, we will have the distance sums for every node in the graph.  
We define 2 helper functions `dfs1` and `dfs2`. `dfs1(node, prev)` will compute the sum of distances to all nodes in the subtree rooted at each node in the graph(where the root is `node`) as well the size of the subtree. `dfs2(node, prev)` will then compute the sum of distances to *all nodes in the tree* using the values computed by calling `dfs1`. In both functions, the value of the argument `prev` should be the node previously traversed(`-1` for the root) passed to prevent revisiting nodes. Choosing an arbitrary node as the root(in this solution, node `0`) we first call `dfs1(0, -1)` and then `dfs2(0, -1)`; after which the list `dp2` will contain the desired values.  

#### Conclusion
This solution has a time complexity of $O(n)$ where $n$ is `n`(the number of nodes in the given tree). The tree is traversed twice using DFS, where each traversal takes $O(n)$ time. The space complexity is also $O(n)$, due to the traversal step as well as the lists `dp1`, `dp2`, and `sub`.  
  

