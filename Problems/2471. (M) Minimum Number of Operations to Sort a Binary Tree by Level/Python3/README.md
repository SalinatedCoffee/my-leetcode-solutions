## 2471. (M) Minimum Number of Operations to Sort a Binary Tree by Level

### `solution.py`
Given the root node `root` of a binary tree, we are asked to determine the number of swaps required to make the list of node values of each level of the tree sorted. Retrieving the per-level list of node values can be easily achieved through the use of BFS to traverse the tree and a dictionary to store the per-level values. The real problem is coming up with a way to count the number of required swaps to make all levels sorted. To solve this, we can enlist the help of a sorting algorithm called [cycle sort](https://en.wikipedia.org/wiki/Cycle_sort). While it is not the most optimal sorting algorithm in terms of time complexity, it has its own niche use cases where writes to the underlying memory is very expensive. This is because cycle sort performs the minimum number of writes to the list being sorted, which is consequently exactly what we want.  
Cycle sort sorts elements in a list by taking each element and putting it into its correct sorted position within the array, swapping it out with the element that was previously occupying that space. To determine the correct position for the node values in each level, we can simply sort the list of values. We can do this since the goal is to determine the minimum number of swaps to make the list sorted, and not actually sorting the list. For each level, a sorted copy of the list of node values is first created. The original list is then iterated over, incrementing the swap counter whenever a swap needs to occur. Once all levels have been processed, we may simply return the counter.  

#### Conclusion
This solution has a time complexity of $O(n\log n)$, where $n$ is the number of nodes in the tree rooted at `root`. The initial BFS traversal finishes in $O(n)$ time, since each node is visited exactly once and takes $O(1)$ time to process. When determining the number of swaps, we take the list of values for each level and sort it before iterating over the original list once. In the worst case(where the level in question is the bottom-most level in a perfect binary tree), the number of nodes in a single level is $n / 2$. Thus, the sorting operation will take $O(n\log n)$ time, and performing the cycle sort will require $O(n)$ time. Hence, the overall time complexity of this solution is $O(n\log n)$. The space complexity is $O(n)$, due to `nodes`, the counting step, and `level_values`.  
  

