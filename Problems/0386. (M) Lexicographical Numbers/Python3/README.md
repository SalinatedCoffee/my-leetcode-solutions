## 386. (M) Lexicographical Numbers

### `solution.py`
Given then integer `n`, we are asked to return the list of lexicographically sorted numbers from `1` to `n`. A lexicographical ordering of numbers compare two values starting with their leftmost digits, with the value that has the greater digit first coming before the other value. If a value is the prefix of the other value, the other value has more digits and is thus considered the larger of the two. For example, between `112` and `122` the latter would come after the former, and between `123000` and `123`, the former would come after the latter. The lexicographical ordering of the integers in the range `[1, 13]` is `[1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]`.  
Almost immediately we realize that the values can be generated in lexicographical order through a DFS-like algorithm. The algorithm would go 'down' a level by adding a digit until the current value exceeds `n`, at which point we 'backtrack' by removing the least significant digit from the current value. After backtracking, we increment the current value by `1` until either the least significant digit becomes `9` or the current value exceeds `n`, at which we backtrack again. The main problem arises from the fact that we are asked to implement a solution that uses $O(1)$ memory - which means that we cannot utilize recursion to implement this algorithm(despite the editorial claiming otherwise, a term should not be considered constant if it scales with the size of the input - that said, you could follow up by arguing that the upper bound is small enough for the term to be considered constant). Instead of relying on a stack, be it the call stack or an explicit one, we can use the integer containing the current value as a simulated stack.  
Starting with the value of `1`, we first add the current value to the ordered list of numbers. We then 'recurse down' by multiplying the value by `10`, adding a digit to it. If adding a digit would result in the value exceeding `n`, we first trim off digits until the least significant digit is a value that is not `9` or the value is less than `n`. The value is then incremented by `1` before repeating the steps described above. Since we already know the number of elements the ordered list should contain, we can stop after looping `n` times.  

#### Conclusion
The time complexity of this solution is $O(n)$, where $n$ is `n`. Adding / removing digits take $O(1)$ time to perform, and this does not happen more than $O(n)$ times. The space complexity is $O(1)$, since we use a single integer as a simulated stack.  
  

