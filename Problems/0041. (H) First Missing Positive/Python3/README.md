## 41. (H) First Missing Positive

### `solution.py`
The trivial solution is to simply store all positive values into a set, and incrementally check every positive integer against that set. However, we are asked to implement a solution that does not use extra memory. Due to this restriction, approaches that involve sorting `nums` also become infeasible.  
One method that we can use is to modify the given input. While this should be avoided whenever possible in practice, it should be okay in an interview / evaluation setting as long as it is clearly communicated that such an approach is allowed.  
We are only interested in the positive values in `nums`, which means that we do not care about negative values or `0`. Any values that are larger than `len(nums)` can also be disregarded, since the largest value that can be missing is `len(nums) + 1`. Iterating over `nums` then, we set each value to `1` if it is either negative, `0`, or larger than `len(nums)`. Because we have 'sanitized' `nums` using `1` as the sanitized value, we also need to explicitly check if `1` already exists in `nums`. If `nums` before the sanitization did not contain `1`, we can immediately return `1`, as it is the smallest possible integer that can be missing. Then, we iterate over the modified `nums` once more, flipping the sign of `nums[nums[i]-1]` if it is not already negative. Finally, we iterate over `nums` one last time, returning the current index whenever `nums[nums[i]-1]` is not negative.  

#### Conclusion
This solution has a time complexity of $O(n)$ where $n$ is the length of `nums`. `nums` is iterated over thrice, with each value taking constant time to process. The space complexity is $O(1)$ if excluding the reuse of `nums`(use of *auxillary* space), or $O(n)$.  
  
  
### `solution_2.py`
We can also implement a different solution based on an algorithm known as [cycle sort](https://en.wikipedia.org/wiki/Cycle_sort). Simply put, we move values to their appropriate locations in `nums` by using the values themselves as their indices(which is similar to the previous solution). After all items have been moved, we can scan `nums` one more time to identify the first missing positive integer.  
Because the contents of `nums` (which we are interested in) are 1-indexed, the value `nums[i]` should be at index `nums[i]-1` if it is positive. Iterating over `nums`, we first check whether the current value `nums[i]` needs to be moved by checking if it is in the range `[1, len(nums)]` and not in the correct position `nums[i] != nums[nums[i] - 1]`(note that we cannot evaluate `nums[i] != i+1` as we must account for cycles). If so, we swap the current value with the value stored in the correct position. Otherwise, the current value is either out of bounds or is already in the correct position and does not need to be moved, so we move on to the next value in `nums` by incrementing `i` by `1`. The reason that we need to manually advance `i` is because we simply swap the values between the current position and the 'correct' position, without checking whether the current position or the 'correct' position contains the correct value. For example, if `nums = [-1, 4, 3, 1]`, and we are currently examining `4`, without manually incrementing `i` we would first swap `4` with `1`, and immediately move on to `3` despite `1` still being in the wrong position.  
Once all values in `nums` have been moved, we iterate over `nums` one last time to find the first missing positive integer by immediately returning the current index + `1` whenever the current value does not match the current position.  

#### Conclusion
The time and space complexity of this solution is identical to the previous solution's.  