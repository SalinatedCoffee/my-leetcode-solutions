## 2406. (M) Divide Intervals Into Minimum Number of Groups

### `solution.py`
Given the list of intervals `intervals`, where each interval is represented by a list of length 2, we are asked to return the minimum number of groups required to group the intervals so that each group does not contain overlapping intervals. Upon first reading the problem description, the problem can feel more complicated than it actually is. It would seem that we would have to take a dynamic programming or backtracking based approach that considers each interval and tries to add them to a group or create a new one. Upon further ideation however, we realize that the minimum number of groups required is simply the maximum number of overlapping intervals. With this revelation, the problem now becomes determining the maximum number of overlapping intervals within `intervals`.  
There are many valid approaches to this problem, but here we will implement a [line sweep](https://en.wikipedia.org/wiki/Sweep_line_algorithm) based algorithm. The range of the sweep will be the interval starting with the smallest value amongst the starting coordinates in `intervals`, and ending with the largest value amongst the ending coordinates. If we knew the number of overlapping intervals at each point within this interval, we can easily determine the largest number of overlapping intervals by iterating over the sweep interval. This can be achieved by implementing a modified prefix sum. We count the number of occurrences of each unique starting and ending point in `intervals`. While iterating over the sweep interval, we maintain a single integer. If this value is incremented by the number of occurrences of previously seen starting points, and decremented by that of the ending points, this integer represents the number of 'open' intervals at the current location on the number line.  
We first initialize the sweep interval using the method described. `l` will be the starting point of the interval, and `h` will be the endpoint. The number of occurrences will be kept in the list `counts` of length `h+2`, with `counts[i]` representing the number of occurrences of start/endpoints at point `i`. `counts` is then populated by iterating over each interval `[i, j]` in `intervals`, incrementing `count[i]` by `1` and decrementing `count[j+1]`(since `j` is included in the interval) by `1`. We then iterate over the sweep interval, incrementing the current number of 'open' intervals by incrementing the counter `overlap` by `counts[i]` for all `i` within the sweep interval. The maximum value of `overlap` is then returned.  

#### Conclusion
This solution has a time complexity of $O(n+k)$ where $n$ is the length of `intervals` and `k` is the size of the sweep interval. Initializing `counts` requires $O(k)$ time, as well as iterating over the sweep interval. Populating `counts` takes $O(n)$ time to complete, as it involves iterating over the entirety of `intervals`. Initializing the sweep interval also runs in $O(n)$ time, putting the overall time complexity at $O(n+k)$. The space complexity is $O(k)$, due to `counts`.  
  

