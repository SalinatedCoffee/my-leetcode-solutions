## 2491. (M) Divide Players Into Teams of Equal Skill

### `solution.py`
Given the list of integers `skill` we are asked to pair each element such that the sums of each pair are equal, and then return the chemistry of that pairing. The chemistry of a pair is simply the product of the two values, and if a valid pairing does not exist, we should return `-1`.  
This problem can be thought of has having two parts. We first need to determine the target value by which to pair the elements of `skill`, and then devise a method to actually pair values according to the target value. Upon further ideation, we realize that only one target value can exist, which is the sum of the smallest and largest value of `skill`. To investigate this claim further, let's assume that `skill` is sorted in ascending order. Naturally, `skill[0]` will be the smallest element in the array and `skill[-1]` will be the largest. Because `skill` is sorted, the expression `skill[i] >= skill[i+1]` is always true. If we also assume that `skill[0] > skill[1]`, and we paired `skill[1]` with `skill[-1]`, we can see that finding a suitable pair for `skill[0]` becomes impossible. Hence, the target value is always the sum of the smallest and largest values of `skill`. We have found a target by which to pair values, but the existence of this value does not guarantee that a valid pairing of `skill` exists. Using similar logic to the one used when making the claim of the target value, we can say that we should be pairing the `i`th smallest value with the `i`th largest value. If the sum of at least 1 pair is not equal to the target value, a valid pairing of `skill` does not exist.  
`skill` is first sorted in ascending order, after which the target value `tgt` and pointers `l`, `h` are initialized. While `l` is less than `h`, we attempt to pair the elements at `skill[l]` and `skill[h]` if the sum of the two elements are not equal to `tgt`, we immediately return `-1` as the elements of `skill` cannot be paired per the problem description. Otherwise, we compute the product of the two values and add it to the total `res`, after which we advance the pointers by `1` in the appropriate direction.  

#### Conclusion
This solution has a time complexity of $O(n\log n)$ where $n$ is the length of `skill`. `skill` is sorted before it is iterated over, which requires $O(n\log n)$ time to complete using Python's built in sort. The pairing step completes in $O(n)$ time as there are $n/2$ pairs with each pair taking $O(1)$ time to process. The space complexity is $O(n)$, due to the sorting step.  
  

