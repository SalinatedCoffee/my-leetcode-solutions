## 1310. (M) XOR Queries of a Subarray

### `solution.py`
Given the list of integers `arr` and 2D list `queries`, we are asked to return the XOR sum of each query in `queries`; that is, the list of XOR sums of all elements in `arr[i:j+1]` of each integer pair in `queries`. The brute force approach would involve iteratively computing the XOR sum for each and every query, but we can easily write a faster solution by exploiting the properties of XOR operations. For one, we know that XORing a value with itself always yields a value of `0`, effectively cancelling each other out. Using this property, we can immediately see that we could quickly compute the XOR sum of a subarray of `arr` if we know all of the values of the prefix XOR sum of `arr`. For example, consider the subarray `arr[i:j+1]`, which we want to compute the XOR sum of. Expanding the sum into individual terms would result in an expression that looks like `arr[i] ^ arr[i+1] ^ arr[i+2] ^ ... ^ arr[j-1] ^ arr[j]`. If we know the XOR sums of `arr[:i]` and `arr[:j+1]`, it means that we know the value of `arr[0] ^ arr[1] ^ ... ^ arr[i-1]` and `arr[0] ^ arr[1] ^ ... ^ arr[j]`. Since we have already established that XORing a value with itself results in `0`, we can immediately see that XORing `arr[:i]` with `arr[:j+1]` would cancel out the terms `arr[0]`, `arr[1]`, ...`arr[i-1]` in `arr[:j+1]`, resulting in the expression `arr[i] ^ arr[i+1] ^ ... ^ arr[j-1] ^ arr[j]` - which is exactly the value we want. By precomputing the prefix XOR sums of `arr`, we were able to reduce a linear time operation to a constant time operation, reducing the overall time complexity by a factor of `len(arr)`.  
`pre` will contain the prefix XOR sums of `arr`, with the value `pre[i]` being the XOR sum of `arr[0:i+1]`. The `itertools.accumulate()` function allows us to populate `pre` in a single line, after which we append a `0` to `pre` to handle queries that have a left index of `0`. We can now compute the XOR sum of each query in `queries` by using list comprehension to generate the list containing the results of each query.  


#### Conclusion
This solution has a time complexity of $O(m+n)$ where $m$ and $n$ are the length of `query` and `arr`, respectively. The precompute step requires $O(n)$ time to complete, and the query evaluation step that follows takes $O(m)$ time to finish. The space complexity is $O(n)$ as the list of prefix XOR sums `pre` is $n+1$ long. `arr` could be overwritten instead of using a separate list to bring the space complexity down to $O(1)$, but one should keep in mind that modifying the input values in a function is generally considered bad practice.  
  

