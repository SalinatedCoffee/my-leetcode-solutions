## 1239. (M) Maximum Length of a Concatenated String with Unique Characters

### `solution.py`
Essentially, we want to find the largest sum of the lengths of the strings in `arr` where the set of unique letters in each string are mutually exclusive to each other. Intiuition tells us that a dynamic programming approach could work for this problem, as we can easily compute the length of concatenating a string to a previous string if the previous string is guaranteed to be valid and the current string is determined to be 'concatable' to the previous one. The problem is representing the set of unique letters contained in the previous string in a recurrence relation. Passing in the actual concatenated string is obviously not ideal for a few reasons; mainly because we would have to linearly scan the string to identify the set of unique letters, and the bound on the parameter would be too large. Thankfully, the problem constraints tell us that all strings in `arr` only contain lowercase English letters, which means that we can represent a set of unique letters with 26 bits using bit manipulations.  
First, we need to define the recurrence relation. Let $f(\texttt{i}, \texttt{b})$ be a function that returns the longest length of a concatenated string formed using `arr[i-1:]` where the set of previously used letters is `b`. If `arr[i]` is *concatable*; that is, if `arr[i]` only consists of unique letters and the set of unique letters does not overlap with that represented by `b`, we can either choose to append `arr[i]` to the string or to simply skip it. Among these two choices we want to select the one that yields the larger value, hence we return $\text{max}(f(\texttt{i}+1, \texttt{b}), \texttt{len(arr[i])} + f(\texttt{i}+1, \texttt{b} + \texttt{b_n}))$, where `b_n` is the integer representing the set of unique letters in `arr[i]`. Otherwise, `arr[i]` is not concatable, and we have no choice but to move on to the next string in `arr` by returning $f(\texttt{i}+1, \texttt{b})$.  
Generating `b_n` is rather simple; we need only convert each character into an index `i` (using ASCII codes) and raise the `i`th bit of `b_n`. If at any point the bit to be raised is already raised, the string contains duplicate letters and thus cannot possibly be contatable.  
By definition of $f$ we want the return value of $f(\texttt{0}, \texttt{0})$, which we can directly call in the `return` statement.  

#### Conclusion
This solution has a time complexity of $O(mn)$, where $m$ is the average length of the words in `arr` and $n$ is the length of `arr`. Each state in the recurrence relation is represented by 2 parameters, where one is bound by $n$ and the other by 26. We compute the values for all possible states, with each state taking $O(m)$ time to compute. Hence the overall time complexity is $O(mn)$. The space complexity is $O(n)$.  
  

