## 3097. (M) Shortest Subarray With OR at Least K II

### `solution.py`
An array is 'special' if the bitwise OR of all of its elements is at least `k`. Given the list of integers `nums` and the integer `k`, we are asked to return the length of the shortest subarray of `nums` that is special. First off, we know that a brute force approach cannot work here given the problem constraints. Because we are working with subarrays, we know that a sliding window based approach could work for this problem. The problem with this approach is that we would have to iterate over the entirety of the window to verify it, as we cannot simply 'remove' a value from the bitwise OR of the contents of the window. However, because the number of bits in an integer is fixed, we can maintain an array of counters where each element represents the number of elements within the current window that has a raised bit in a specific digit. For example, `arr[i]` could represent the number of elements with the `i`th bit raised. This way, we can remove an element from the window in constant time, as well as reconstructing the value of the window OR.  
We first define two helper functions. `bitarray_to_integer` takes a singular bit array as its argument and returns the integer reconstructed by the bit array. `update_bitarray` takes a bit array `arr`, integer `val`, and boolean `add`, and updates the contents of `arr` using the binary representation of `val`. If `add` is `True`, the elements of `arr` are incremented by `1` for each raised bit. Otherwise, they are decremented by `1` instead. The sliding window step is then performed on `nums`, expanding the window towards the right by `1` and checking whether the window is valid. If so, we attempt to incrementally contract the window from the left until it no longer becomes valid. Once all elements have been considered, we simply return the length of the smallest observed window.  

#### Conclusion
This solution has a time complexity of $O(n)$, where $n$ is the length of `nums`. `nums` is effectively iterated over twice, with each element being added to and removed from the window at most once. Updating the bit array for a window, as well as verifying the contents of a window from the bit array each require $O(1)$ time as previously described. Thus, the overall time complexity of this solution comes out to be $O(n)$. The space complexity is $O(1)$.  
  

