## 1717. (M) Maximum Score From Removing Substrings

### `solution.py`
We are asked to determine the maximum achievable score by removing the substrings `"ab"` and `"ba"` from `s`, where removing `"ab"` is worth `x` points and `"ba"`, `y` points. Since both substrings are 2 characters long, we realize that we can use stacks to remove the substrings from `s`, which also allows us to avoid having to iterate over `s` multiple times if we had opted to linearly scan `s` instead. The problem now becomes determining the order by which the substrings should be removed from `s` to maximize the achieved score.  
We will posit that removing the higher scoring substring first will always yield a score higher than other sequences of removals. Without loss of generality let `x > y`, which means that removing `"ab"` yields a higher score than removing `"ba"`. Because we have claimed that removing the more valuable substring first always yields the highest score, it must be the case that a different removal sequence cannot score higher. Assume that such a sequence does exist. This implies that  at some point in `s` removing a single `"ab"` will prevent us from removing 2 `"ba"`s. Consider the substring `"baba"`. If we remove `"ba"` first we are left with the substring `"ba"`, which when removed will result in the total score of `2 * y`. If we remove `"ab"` first, the overall score is `x + y`. By our assumption `2 * y` should be larger than `x + y`, but since `x > y` we know that this possibly cannot be true. Hence, our original assumption is wrong, and removing the more valuable substring first does always result in the highest achievable score.  
With this information we can now start implementing a solution. We will make 2 passes on `s`; once to remove the higher scoring substrings, and once to remove the other substrings. The more valuable substring is first decided by comparing `x` and `y`. The function `remove_ss` is then declared, where `remove_ss(ss, s_ss)` returns the score achieved by removing instances of `ss` from `s`, where `ss` is worth `s_ss` points. When `remove_ss` is called, an empty stack is initialized before iterating over `s`. During the iteration, we examine the character on top of the stack and the character currently being examined. If they concatenate to `ss`, we remove the characters by popping a character off of the stack. Otherwise, we simply push the current character onto the stack before moving on to the next character. Once the iteration completes, the stack will contain all remaining characters in reverse order. After computing the total score gained through the difference of the lengths between `s` and that of `s` pre-removal, we update `s` and return the score. To compute the total score of removing both substrings, we simply call `remove_ss` twice where we call the function with the higher scoring substring first.  

#### Conclusion
This solution has a time complexity of $O(n)$ where $n$ is the length of `s`. `s` is iterated over twice, with each character taking $O(1)$ time to process. Constructing the post-removal version of `s` from the contents of the stack takes $O(n)$ time, and since this only happens twice the overall time complexity of the solution becomes $O(n)$. The space complexity is also $O(n)$, due to `stack`.  
  

