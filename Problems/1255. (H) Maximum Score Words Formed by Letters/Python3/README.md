## 1255. (H) Maximum Score Words Formed by Letters

### `solution.py`
Given a list of words, a list of available letters, and the score for each unique English letter, we are asked to return the maximum score that can be achieved by forming words in `words` using the set of letters `letters`. Multiple words can be formed as long as there are enough letters to do so, but a word may not be formed more than once. Thankfully, since there can only be as many as 15 words that can be 14 letters long at most, we can simply use backtrackig to determine the maximum achievable score. To do this, we first need to convert `words` and `letters` into a more useful format. In order to form a word, we need to determine whether we have enough letters to form said word. By storing the frequency of each letter in a dictionary we can easily check this in constant time(since there are only 26 letters in the English alphabet).  
We first initialize the dictionary `letters_pool`, a list of dictionaries `words_freq`, and a list of integers `words_score`. `letters_pool` will store the frequencies of available letters, `words_freq` the frequency count for each word(where `words_freq[idx]` contains the count for `words[idx]`) and `words_score` the total score of each word in `words`. `words_score` is not strictly necessary, but we have opted to precompute these value to reduce redundant score computations during the backtracking step. Then the function `recurse` is defined, where `recurse(idx)` will return the maximum score of `words[idx:]` using the currently available letters in `letters_pool`. If `idx == len(words`, there are no more words that can be formed and `0` is returned. Otherwise, we determine whether `words[idx]` can be formed using the current set of remaining letters by comparing the values of the dictionaries `words_freq[idx]` and `letters_pool`. If the word indeed can be formed, we try choosing that word by decrementing the values in `letters_pool` and storing the value of `words_score[idx] + recurse(idx + 1)`. After `letters_pool` is reverted back to its state before forming `words[idx]`, we try skipping the current word by calling `recurse(idx + 1)` again. Among the two values, we simply return the larger one.  
By definition of `recurse`, `recurse(0)` will return the value that we want, which we can return directly as our answer.  

#### Conclusion
This solution has a time complexity of $O(nk + m + 2^n)$ where $m$ is the length of `letters`, $n$ the length of `words`, and $k$ the average length of the words in `words`. The initialization of `letter_pool`, `words_freq`, and `words_score` takes $O(m)$, $O(nk)$, and $O(nk)$ time, respectively. For each word in `words`, there are two possible actions that can be taken. Since processing each word takes $O(1)$ time(as there are a fixed number of letters in the alphabet) exploring all possible choices will take $O(2^n)$ time. The space complexity is $O(n)$, due to `words_freq`, `words_score`, and the recursion stack.  
  

