## 2601. (M) Prime Subtraction Operation

### `solution.py`
Given the list of integers `nums`, we are allowed to subtract a prime strictly smaller than an element from that element at most once, for any element in `nums`. If `nums` can be made into a strictly increasing array by performing this operation, we return `True`. Otherwise, we are asked to return `False`. Almost immediately we can see that we would want to greedily subtract primes from each element of `nums`. Specifically, we would want to subtract the largest prime `p` from `nums[i]` such that the expression `nums[i] - p > nums[i-1]` evaluates to `True`. Since we want to greedily make each element as small as possible, we can start with a target value of `1`, incrementing it by `1` until the current element can be modified to match the value of the target. If it is determined that an element cannot possibly be modified to match target, `nums` cannot be made into a strictly increasing list and we return `False`. If a prime can be subtracted from the current element to achieve the target, or it is already equal to the target, we move on to the next element and increment the target by `1`. Otherwise, we increment the target by `1` and try again. The list of primes up to `max(nums)` can be generated by using an algorithm called the [Sieve of Eratosthenes](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes), which requires $O(n\log\log n)$ time to generate a list of primes up to $n$. Because we want to quickly verify whether a number is prime or not, we will indirectly store each prime by creating a list of booleans and setting the element at the appropriate index to `True` to denote that the value of the index is prime.  
We first define the helper function `list_primes` that takes a single integer `n` and returns a list of booleans `primes`. `primes[i]` is `True` if `i` is prime, or `False` otherwise. After initializing the target `cur` to `1` and index of `nums` `idx` to `0`, we can start to examine the elements of `nums`. If the difference `d` between the current element `nums[idx]` and target value `cur` is less than `0`, `cur` is impossible to attain by subtracting a prime from `nums[idx]` and we return `False`. If `primes[d]` is `True`(difference is a prime) or equal to `0`, the current element can indeed be modified to match `cur` and we move on to the next element and target value by incrementing both `idx` and `cur` by `1`. Otherwise, we increment `cur` by `1` and try again. When all elements of `nums` have been examined, we know that `nums` can be made into a strictly increasing list of integers, and so we return `True`.  

#### Conclusion
This solution has a time complexity of $O(n+m\log\log m)$, where $n$ is the length of `nums` and $m$ is the largest element in `nums`. As mentioned above, generating a list of all primes up to $m$ using the Sieve of Eratosthenes requires $O(m\log\log m)$ to complete. Iterating over `nums`, as well as finding the maximum element within the list each takes $O(n)$ time to complete, resulting in the overall time complexity of $O(n+m\log\log m)$. The space complexity is $O(m)$, as the length of the list `primes` scales with respect to the largest element in `nums`.  
  

