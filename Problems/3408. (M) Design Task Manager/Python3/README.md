## 3408. (M) Design Task Manager

### `solution.py`
We are asked to design and implement the `TaskManager` class, which should be able to handle and manage tasks in an efficient manner. More specifically, it should support the following operations:  
 - A task should be represented by 3 integers; the priority(larger values have higher priority), user ID, and task ID.
 - When given a list of tasks(with each task represented by the triple `(taskId, userId, priority)`) upon instantiation, the created object should contain all of the tasks in the given list.
 - `TaskManager.add(int userId, int taskId, int priority)` should add a new task with the suppied values.
 - `TaskManager.edit(int taskId, int newPriority)` should modify the priority of the task with task ID `taskId` with `newPriority`. When this method is called, a task with task ID `taskId` is guaranteed to exist.
 - `TaskManager.rmv(int taskId)` should remove the task with task ID `taskId` from the `TaskManager` instance. When this method is called, a task with task ID `taskId` is guaranteed to exist.
 - `TaskManager.execTop()` should 'execute' the task with the highest priority by returning its user ID and removing it from the `TaskManager` instance. If there are multiple tasks with the same priority, the task with the highest task ID value should be executed. If there are no runnable tasks remaining, it should return `-1`.

 Since we are scheduling tasks based on priority, we can immediately see that we should be incorporating heaps in our solution. Using a heap as the base, we can layer on other data structures on top in order to support the operations described in the problem. Maintaining a list of tasks in descending order of priority is easy, since we can simply store the tasks in a min heap indexed by priority. The problem with this approach is that we cannot easily access a task by its task ID, which we need to be able to do in order to implement `TaskManager.edit`. If we ignore the min heap, we know that we can trivially achieve this by adding a dictionary that maps task IDs to the appriorate priority and user ID. While `TaskManager.edit` only supports modifying the task priority, a task's user ID can also be 'indirectly modified' by first removing it via `TaskManager.rmv`, and adding the task back into the `TaskManager` instance with a new user ID - which is why we need to map task IDs to both the priority and user ID. In essence, we simply keep the values updated in the dictionary while only inserting new and updated tasks into the heap. Outdated tasks can be lazily invalidated when `TaskManager.execTop` is called, by popping a task off of the heap, verifying it against values in the dictionary, and repeating this process as necessary until we get a task that is valid.  
 `TaskManager` will keep track of the tasks in the min heap `_task_heap` and dictionary `_taskid_priorities`. Since Python heaps support sorting tuples by multiple criteria, we can first order by priority and then the task ID by forming the triples in the order of `(priority, taskId, userId)`(remembering to negate the values that are used as the sorting criteria, due to Python only offering max heaps). When `TaskManager.add` is called, we simply push a new triple to `_task_heap` and add a key-value pair to `_taskid_priorities`. `TaskManager.rmv` is even simpler, since we invalidate the task by removing the corresponding entry in `_taskid_priorities`. `TaskManager.edit` is a bit more involved, as we need to pull the original user ID of the task from `_taskid_priorities` first in order to push the new triple with updated values onto `_task_heap`. Finally, `TaskManager.execTop` is where we will be doing most of the heavy lifting of invalidating tasks on `_task_heap`. When it is called, we pop an item off of `_task_heap`, validate it against `_taskid_priorities`, and either return the user ID of the popped item if it is valid, or pop the next item off of `_task_heap`. If the heap is exhausted, we simply return `-1`.  

#### Conclusion
Instantiating a `TaskManager` object requires $O(n)$ time to finish, where $n$ is the length of the list of tasks supplied to the constructor. Since the elements in the supplied list are converted into the desired format through list comprehension and *then* turned into a heap through the `heapify` function, creating a populated min heap takes $O(n)$ time, as well as populating `_taskid_priorities`.  
Calls to `TaskManager.add` and `TaskManager.edit` finishes in $O(\log m)$ time, where $m$ is the maximum number of tasks in the `TaskManager` instance over its lifetime.  
`TaskManager.rmv` takes $O(1)$ time to run.  
Finally, `TaskManager.execTop` will take $O(m\log m)$ time to finish. An item is popped off of `_task_heap` to be validated, which may continue until the heap is exhausted(all tasks in the heap has been invalidated). Since there can be up to $m$ items in `_task_heap`, and a single pop operation has a time complexity of $O(\log m)$, the worst case time complexity of `TaskManager.execTop` comes out to be $O(m\log m)$.  
A `TaskManager` instance has a space complexity of $O(m)$.  

