## 1171. (M) Remove Zero Sum Consecutive Nodes from Linked List

### `solution.py`
There are many restrictions that come from working with a linked list, and coming up with and implementing the optimal solution is (in my humble opinion) enough to push this problem towards the upper echelon of medium difficulty problems. The first thing to realize is that we should be using prefix sums in some capacity, as the brute force solution would involve a quadratic solution. Imagine that we want to plot the linked list on a cartesian plane, where the x-axis is the 'index' of each node and the y-axis is the prefix sum up to that node in the list. The resulting graph would fluctuate upwards and downwards depending on the sign of the node's value. If at some point the graph ends up in a y-coordinate that has previously been seen, it could be said that all the nodes between the previously seen point and the current one sums to 0 since the y-coordinate has not changed between the two values. For example, if the linked list is `1, 2, 3, -3, 4`, the list of prefix sums would be `1, 3, 6, 3, 7`. Because the prefix sum of the 3rd node (0-indexed) has already been observed at the 1st node, we need to delete all nodes *after* the 1st node *up to* the 3rd node. That is, the 2nd and 3rd nodes should be removed. We can use a dictionary to map a prefix sum to the appropriate node. If the current prefix sum already exists in the dictionary, we can retrieve the corresponding node and remove all nodes between it and the current node by linking it with the next node of the current.  
It may also be the case where the current prefix sum exists in the dictionary, but the entry corresponds to a node that has already been removed. If the linked list is `1, 3, 2, -3, -2, 5, 5, -5, 1`, the list of prefix sums is `1, 4, 6, 3, 1, 6, 11, 6, 7`. We can clearly see that nodes 1, 2, 3, and 4 would be removed by the time we reach the 5th node. However, because the stale entries have not been removed from the dictionary, we find that we would need to remove the section starting at the 2nd node when processing the 5th node. To prevent this behavior, we need to keep the dictionary updated whenever nodes are removed from the linked list. To do this, we can iterate over the section to be deleted while computing the prefix sums for each node once again.  

#### Conclusion
This solution has a time complexity of $O(n)$ where $n$ is the length of the linked list with `head` as the first node. The linked list is at most traversed twice, as the inner loop walks over the deleted section. The space complexity is also $O(n)$, due to the dictionary mapping the prefix sums to their appropriate nodes.  
  

