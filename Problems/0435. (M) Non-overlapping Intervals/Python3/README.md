## 435. (M) Non-overlapping Intervals

### `solution.py`
Before we do anything we know that we could make things easier for us by sorting `intervals` in ascending order first, since for a given interval we would have to scan the entire array for the 'nearest' interval otherwise. Determining the best behavior to take when presented with an interval however, is not as straightforward. It is easier to reason about this problem in the other direction. Becuase we want to minimize the number of overlapping intervals that are removed, we can also say that we want to maximize the number of non-overlapping intervals that we choose.  
Taking this new approach, say we have `in_sorted`, which is `intervals` sorted in ascending order. We want to examine the first two intervals. Which one would be the most optimal choice? Well, since `in_sorted` is sorted in ascending order and we are examining the first two intervals in this list we can safely disregard the start value of both intervals. Looking at the end values then, it stands to reason that choosing an interval with the smaller value will allow us to select more intervals. Then for the next (third) interval, if the start value is larger than the last selected interval's end value (no overlap) we can safely select the new interval and update the end value of the last selected interval (`k`) accordingly. Else, we need to delete the current interval and move on to the next one, and so we increment a counter that represents the total number of removed intervals. Up to this point we have hand waved the details of sorting `intervals`, but now we know that we should be sorting `intervals` in terms of the end values instead of the start values due to the algorithm using end values to make decisions.  
Once we have finished iterating over `in_sorted`, we can simply return the counter mentioned earlier.  

#### Conclusion
The time complexity for this solution is $O(n\log n)$ where $n$ is the length of `intervals`. Sorting `intervals` takes $O(n\log n)$ time, after which we iterate over `in_sorted` exactly once which takes $O(n)$ time. The space complexity is $O(n)$ since we do not sort `intervals` in-place. Python's built-in sorting algorithm also uses $O(n)$ memory during runtime(Timsort).  
The class of problems that relates to problems such as this one are known as [interval scheduling](https://en.wikipedia.org/wiki/Interval_scheduling).  
