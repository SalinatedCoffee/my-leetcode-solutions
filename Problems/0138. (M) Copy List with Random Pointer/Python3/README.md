## 138. (M) Copy List with Random Pointer

### `solution.py`
A naÃ¯ve solution would be to maintain a list of pointers that point to a node in the linked list. This however would be terribly slow largely due to the fact that we must scan the entire list in order to determine the index of the random node. There is also no straightforward way to use hashing since `Node.__hash__()` is not defined, and `Node.val` is not guaranteed to be unique. We can however work around these limitations with some clever thinking.  
Practically speaking, code that implicitly modifies the original input is bad practice which often gets overlooked when practicing DSA problems on platforms such as LeetCode. For this problem, since are asked to create a copy of the input list, we should especially try and leave the input untouched. We could however modify the input if we can revert it back to its original state after we are done with it. There are 2 problems we want to solve for this problem; we want to create a copy of each node while preserving their spatial information, and given an original node we want fast access to its copy. Both can be achieved by interleaving the original linked list with its copy, which for this solution, the original comes first in a pair of nodes (for example, if the original list was `A -> B -> C`, the interleaved list would be `A -> A' -> B -> B' -> C -> C'`, where `n'` is a copy of node `n`). The order of the nodes are preserved, and we can access the copy of a node by simply taking its `.next` pointer.  
After generating the interleaved list, we make one pass that adjusts the random pointers so that those of the copied nodes points to the proper copied node. Then we make one more pass to `unzip` the interleaved lists into the original list and the copied list, after which we can return the head node of the copied list.  

#### Conclusion
This solution has a time complexity of $O(n)$, where $n$ is the length of the linked list that starts with the node `head`. We make one pass over this linked list while generating the interleaved version. This interleaved list is then traversed twice, once to adjust the random pointers, and once to unzip it into the original and copied lists. These traversals all take $O(n)$ time since operations at each node takes $O(1)$ time. The space complexity is $O(1)$ (excluding the copied list) as we only use a handful of variables with a fixed size.  
  

