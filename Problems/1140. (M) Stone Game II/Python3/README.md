## 1140. (M) Stone Game II

### `solution.py`
Since the total number of stones does not change regardless of how a game is played, it can be said that a player trying to maximize their score is effectively the same as trying to minimize the other player's score. For this problem, we want to maximize Alice's score and thus need to perform different actions based on who's turn it is. Assume that the function $r(p, i, m)$ returns the maximum score of Alice for a game that starts with player $p$ (where $p = 0$ is Alice and the other, Bob), using the last $i$ piles of stones, and $M = m$. When $p = 0$, the score for the current move is the sum of stones in piles from $i$ up to $i + x$. This is then added with the return value of the next state, which would be $r(1, i+x, \text{max}(m,x))$. In the opposite case, we simply ignore the score of the current turn since Bob will take them, denying them to Alice. Alice wants to maximize return values of $r$, and Bob wants to do otherwise. Thus Alice chooses the maximum value among all possible calls to $r$ in the current turn, and Bob chooses the minimum value.  
We store the return values of $r$ in `dp` to avoid recomputing known values. The value we want will be stored in `dp[0][0][1]`, which is equivalent to the function call $r(0,0,1)$.  

#### Conclusion
This solution has a time complexity of $O(n^3)$, where $n$ is the length of `piles`. The value of two out of three parameters of $r$ can be at most $n$, and at each call to $r$ we try all possible values for $x$ which is also bound by $n$. The space complexity is $O(n^2)$.  
  


### `solution_2.py`
A bottom-up solution also exists, but is not as straightforward to come up with from the previous top-down solution. The previous solution gives us hints on how to set up the intermediate values and the direction in which to tabulate them, however. `dp` will be a `n` by `n` 2D list where `dp[i][j]` is the maximum number of stones Alice can score when `piles[i:]` piles remain and `M = j`. In the previous solution, the computation of the value `dp[i][j]` always depended on the values `dp[i+x][max(x, j)]`, where `x` being any integer in the range `[1, j]`. This means that we should be filling `dp` diagonally towards the upper-left, row-first. In order to avoid iterating over `piles` every time we have to compute the score for a move, we precompute the suffix sums `suf`, where the value of `suf[i]` is the sum of all values in `piles[i:]`. The base cases in `dp` should also be initialized, where `dp[i][n] = suf[i]` for all `i` in the range `[0, n]`. If `M = n`, the player can take all of the remaining piles. Since Alice and Bob both play optimally, they will always try to maximize their score, which means that they will take all remaining piles whenever it is possible to do so.  
We can now start filling `dp` starting at `dp[n-1][n-1]`. For some value of `M`, we know that `X` is in the interval `[1, min(2*M, n-i)]`. We consider the maximum achievable score for all values of `X`, choosing the highest score amongst them. The trick here is that while we defined `dp` as the maximum score of Alice, we can also treat the values as the maximum score of Bob since the states do not keep track of which player's turn it was given the values `i` and `M`. Thus, we can calculate the score for a certain value of `X` by evaluating the expression `suf[i] - dp[i+x][max(m, x)]`. `suf[i]` is the total score of all remaining piles, and `dp[i+x][max(m, x)]` is the maximum score of the other player if the current player takes `X` piles starting from the `i`th pile. Once `dp` has been fully populated `dp[0][1]` will contain the desired value, which we can return directly.  

#### Conclusion
This solution's time and space complexities are identical to the previous solution but will run faster in practice since it eschews the use of recursion, eliminating its overhead.  