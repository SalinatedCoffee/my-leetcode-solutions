## 241. (M) Different Ways to Add Parentheses

### `solution.py`
We can easily solve this problem by trying all possible parentheses configurations through recursion. For each operator, we try tying all terms to the left and rights side into a single term, after which we apply the operation between all possible pairs of values from the two terms.  
First, the string `expression` is preprocessed into a list of tokens `expr`, which will make it more easier to work with. The function `recurse` will take two arguments `i` and `j`, and will return a list of all values that result from each possible parentheses configuration for the list of tokens `expr[i:j+1]`. Of course, since an expression with a hanging operator(such as `1+3*`) is not valid, `expr[i]` and `expr[j]` *must* both be integers for `recurse(i, j)` to return a valid value(we do not need to guard against this as the problem constraints guarantee that `expression` is a valid arithmetic expression). When `recurse` is first called, it checks for the two base cases. If `i == j`, we return `expr[i]`. If `j - i == 2`, we evaluate the single operator `expr[i+1]` using `expr[i]` and `expr[j]`. Otherwise we scan through the tokens in `expr[i:j+1]`, selecting each operator and recursing down on the left and right terms as mentioned earlier. Obviously, since a string of values and operators can be interpreted in different ways, `recurse(i, j)` will return a list of all values resulting from each different interpretation of `expr[i:j+1]`. Basic combinatorics tells us that we need to compute the cartesian product of the sets of values for the left and right sides in order to get the list of evaluated values for the operation, which we can easily do by using nested for loops.  
By definition of `recurse`, the value of `recurse(0, len(expr)-1)` is what we want; which we can also directly return.  

#### Conclusion
This solution has a time complexity of $O(4^n)$ where $n$ is the length of `expression`. The problem essentially boils down to finding the number of unique expression trees, which is in turn asymptotically equivalent to finding the number of unique binary trees. The numbers of unique binary trees for some number of nodes is what is called a [Catalan number](https://en.wikipedia.org/wiki/Catalan_number), which increases exponentially. The space complexity is also $O(4^n)$ as `return` returns a list of evaluated values of each unique parentheses grouping, of which there are $O(4^n)$ of.  
  

