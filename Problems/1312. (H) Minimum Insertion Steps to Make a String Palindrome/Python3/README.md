## 1312. (H) Minimum Insertion Steps to Make a String Palindrome

### `solution.py`
First, we need to determine the insertion strategy before figuring out how to compute the desired number of steps using that strategy. Let `s == "abcd"`. The obvious method is to simply reverse the string and concatenate it with its original version (`"abcd" + "dcba" == "abcddcba")`, which would take `n == len(s)` steps. But we can see that the last character of the original string and the first character of the reversed string is always the same, and we can instead ignore the first letter of the reversed string (`"abcd" + "cba" == "abcdcba"`. This would take `n - 1` steps. Assume now that the first and last letters of `s` are the same (modifying the example, `s == "abca"`). Using the naïve method, we would now need to insert `n - 2` letters since the first and last letters already form a palindrome (`abccba` or `acbbca`). But again, the two characters in the center are repeated and thus we can save a step by ignoring one of them. This is because a single character by itself is already a palindrome, so we do not have to insert another character. At this point it becomes clear to us that the minimum number of steps is simply the length of the original string subtracted by the length of its longest palindromic subsequence.  
Now we need to compute the length of the longest palindromic subsequence of `s`. There are $2^{\text{length}(s)}$ possible subsequences of `s` and thus it would not be feasible to brute-force a solution. Instead, we can let `s_rev` be the reverse of string `s` and compute the length of the longest common subsequence between them. This problem can be solved with top-down dynamic programming, which will obviously be much faster than the naïve solution.  
We will store computed results in a 2D list `dp`, where the value of `dp[i][j]` is the length of the LCS between `s[:i+1]` and `s_rev[:j+1]`. If we let `recurse(s1, s2, l1, l2)` be a recursive function that returns the length of the LCS between `s1[:l1+1]` and `s2[:l2+1]`, the desired value will be the return value of `recurse(s, s_rev, n, n)`, where `n == len(s) == len(s_rev)`. The base case is when `l1` or `l2` is `0`, as a LCS cannot exist for an empty string. If a value has already been computed for `l1` and `l2`, we can immediately return `dp[l1][l2]`. If `s1[l1-1] == s2[l2-1]` we can 'include' the pair of characters in the LCS where the value for `dp[l1][l2]` will be `1 + recurse(s1, s2, l1-1, l2-1)` - if else, we need to choose the maximum value between excluding a character from `s1` or `s2`.  

#### Conclusion
The time and space complexity of this solution is $O(n^2)$. `recurse()` is called for all possible values of `l1` and `l2`, which is in the range of integers $[0, n]$. `dp` is kept in memory and is an `n+1` by `n+1` 2D list.  
  
  