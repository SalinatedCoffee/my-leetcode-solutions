## 52. (H) N-Queens II

### `solution.py`
We want to determine the number of possible placements of `n` queens on an `n*n` chess board where the queens cannot attack each other. A queen can attack any piece on the same row or column, as well as the diagonals. Simply put, it can attack in all 8 directions with unlimited range. The most straightforward way of counting all valid placements is through a backtracking based approach. For each row, we try placing a queen on all valid locations. In order to check whether a queen can be placed on each location on a row, we need to keep track of two things. First, the columns on which a queen has already been placed on, and second, a list of the coordinates of all queens that have been placed on the board. We can use the former to check whether the current column is available for placement, and the latter to check whether the current square is on a diagonal of a previously placed queen.  
The first order of business is to initialize the list of booleans `self.cols` and empty set `self.prev`. `self.cols[i]` is `True` if a queen has been placed on the `i`th column(0-indexed), and `False` otherwise. `self.prev` will contain the coordinates of all previously placed queens. In order to determine whether a square is on a diagonal of a queen, we can simply compare the absolute difference between the row and column numbers of the square and queen. If the differences are equal, than we know that the square is indeed on a diagonal of the queen. We then define the function `recurse`, which takes a single argument `rem` that represents the number of queens remaining to be placed. When `recurse` is called, we first check whether `rem` is `0`. If so, all queens have been placed, and so we increment the number of placements `self.ret` by `1` and exit. Otherwise, we determine the current row `row` through `rem` and try placing a queen on that row. For each column `j` on the current row, we perform a check on `self.cols` and `self.prev`. If `self.cols[j]` is `True`, then that square is not available for placement. If `abs(row - r) == abs(j - c)` evaulates to `True` for any `(r, c)` in `self.prev`, the current square is on a diagonal of a previously placed queen, and is also unavailable for placement. If both checks evaluate to `False`, we place a queen on that square by assigning `True` to `self.cols[j]` and adding the current coordinate `(row, j)` to `self.prev`. After calling `recurse(rem - 1)`, we revert `self.cols` and `self.prev` to their previous states and try placing a queen on the next available square on row `row`. Once `recurse(n)` exits, the value of `self.ret` will be the number of all possible placement of `n` queens.  

#### Conclusion
The time complexity of this solution is $O(2^{n^2}n)$ where $n$ is `n`. Each square in the $n\times n$ grid can either contain or not contain a queen, and evaluating whether a queen can be placed on a square takes $O(n)$ time since the size of `self.prev` is bound by $n$. The space complexity is $O(n)$, due to `self.col`, `self.prev`, and the recursion stack.  
  

