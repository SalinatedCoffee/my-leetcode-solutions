## 664. (H) Strange Printer

### `solution.py`
Intuition tells us that this problem could be solved by taking a dynamic programming approach. Let's first set up what a state should look like. Somewhat arbitrarily, we will say that the value of the state `(l, r)` is the minimum number of prints the printer has to perform to convert a string `t`, where `t == s[r]*(r-l+1)`(for example if `s = "abcdef"` and the state is `(1, 4)`, `t = "eeee"`), to the substring `s[l:r+1]`. If `s[l:r+1]` has at least two distinct characters, and `j` is the index of the first character that is not `s[r]`, we know that we will inevitably have to print over `j`. Because of how we defined `j`, we know that `s[l:j]` is already converted and will incur no additional cost. So we want to start printing at `j`, but we do not know when we should stop printing. Let's assume we stop printing at index `i`. Now `t[j:i+1]` only consists of `s[i]`, and `t[i:r]` only consists of `s[r]`. The converting cost of these two strings can now be recursively defined, where the former is represented by the state `(j,i)` and the latter by `(i+1,r)`. We have performed 1 printing operation to obtain the first string, hence the minimum print count of the state `(l,r)` now becomes `1 + (j,i) + (i+1,r)`. Of course, there could be many possible values for `j` and `i` for the state `(l,r)`, so we try all of them and select the one with the smallest cost.  
The desired value will be the return value of the state `(0, len(s)-1) + 1`. `len(s)-1` because the parameters are 0-indexed, and `+ 1` because the state definition does not count the initial cost of printing `t`.  

#### Conclusion
This solution has a time complexity of $O(n^3)$, where $n$ is the length of string `s`. Each state has two parameters, both of which are in the range $[0, n)$. Thus there are $n^2$ states total, and in computing the value of each state we find all possible values of `j` and `i` which is an operation that scales linearly with the size of `s`. The space complexity is $O(n^2)$.  
  


### `solution_2.py`
Looking back at the previous solution, we can see a few points of possible optimization. First off, we realize that substrings of `s` that consist of only a single character can be 'compressed' into a single character since such a substring of any length can be printed in a single step. While the asymptotic time complexity is unchanged, the algorithm will run faster in practice by preprocessing `s` using the described method. The recurrence relation can be simplified also, defining a state `(l, r)` as the minimum number of steps required to type `s[l:r+1]`. Given some substring `s[l:r+1]`, there are 2 possibilities relating to the character `s[l]`. Either the rest of the substring does not contain another instance of `s[l]`, or it does. For the former, we must spend 1 step to print only `s[l]` since it is unique in the substring `s[l:r+1]`. For the latter however, we can spend 1 step to print `s[l]` *and* the first occurrence of the character `s[l]` in `s[l+1:r+1]`, and overwrite the characters in between later. That is, if `s[l] == s[k]` where `l < k <= r` and `s[l+1:k]` does not include any occurrences of the character `s[l]`, we can ignore `s[k]` since we can print it when we print `s[l]`. Then, the number of steps required to print `s[l:r+1]` turns into the number of steps required to print `s[l:k]` plus that of `s[k+1:r+1]`. The value we want will be that of the state `(0, m)`, where `m` is the length of the *preprocessed* version of `s`.  

#### Conclusion
The time and space complexity of this solution is identical to the previous solution, but will run much faster in practice due to the mentioned optimizations.  
