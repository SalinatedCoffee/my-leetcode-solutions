## 1760. (M) Minimum Limit of Balls in a Bag

### `solution.py`
We are given the list of integers `nums`, where `nums[i]` represents the number of balls held in the `i`th bag. In a single operation, we can arbitrarily select any bag and split it into two smaller bags each containing at least 1 ball. If we can perform at most `maxOperations` operations, our task is to determine the minimum value of the most number of balls inside a single bag.  
The first instinct would be to use a priority queue, greedily dividing bags until we run out of operations. The problem with approach is that it only considers the case where a bag is divided into 2, as shown in the first given example. Given a single bag containing `9` balls and `2` available operations, the priority queue method would first halve the initial bag into bags holding `5` and `4` balls. Then, the bag containing `5` balls would be divided into bags containing `3` and `2` balls, since the bag would be the bag containing the most number of balls. As a result, we end up with 3 bags each containing `2`, `3`, and `4` balls - resulting in a value of `4`. However, we could have split the initial bag into 3 bags containing `3` balls, which would have yielded a better value of `3`.  
Now that we have established that a priority queue based approach will not work, we need to devise a different method. Ultimately, we want to find the optimal bag size that can be achieved by performing at most `maxOperations` operations. Thinking about this problem in reverse, we can determine whether `nums` can be divided in such a way that the largest bag contains some number of balls by performing at most `maxOperations`. We also realize that this property behaves monotonically in that if it is true for some number of balls `i`, it is also true for any number of balls larger than `i`. This means that we can take a binary search based approach for this problem.  
We define the helper function `verify`, which takes a single integer `size` as its argument and determines whether `nums` can be divided into bags holding at most `size` balls by performing at most `maxOperations` operations. The binary search step can then be performed, using the interval `[1, max(nums)]` as the initial search space.  

#### Conclusion
This solution has a time complexity of $O(n\log k)$, where $n$ is the length of `nums` and $k$ the largest value of `nums`. `verify` finishes in $O(n)$ time, as it iterates over the entirety of `nums` to determine whether the bags can be divided. This helper function is called for every halving of the search space during the binary search space. Since the size of the initial search space is $k$, $\log k$ halvings will occur in total, bringing the overall time complexity of this solution to $O(n\log k)$. The space complexity is $O(1)$.  
  

