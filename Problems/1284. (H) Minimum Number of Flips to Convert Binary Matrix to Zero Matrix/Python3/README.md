## 1284. (H) Minimum Number of Flips to Convert Binary Matrix to Zero Matrix

### `solution.py`
Given a bit matrix `mat`, we are asked to determine the number of flips required to make `mat` contain only `0`s. A flip involves selecting an element in `mat` and flipping it along with its four neighbors on its cardinal directions. Looking at the problem constraints, we know that the maximum size of `mat` is *tiny*, with the largest size being a 3*3 matrix. Because of this, a solution that tries all possible flip combinations is possible. Of course, a cell can be flipped multiple times. But since a cell can only alternate between a `0` and a `1`, flipping a square more than once will be redundant. Thus, we only need to consider 2 options for each square; when it is flipped, and when it is not. For each and every value in `mat`, we try flipping it or leaving it as is. We keep a separate 2D list that contains the number of times each value has been flipped. If that value mod 2 equals the original value in `mat`, we know that value is `0`, which we can use to determine whether `mat` is a zero matrix after some number of flips.  
We define a function `recurse`, which will take 2 arguments `i` and `f`. `i` will the the number of the square currently being considered(0-indexed), and `f` will be the number of flips performed up to this point. If `i` is equal to the number of values in `mat` + `1`, we count the number of `0`s in `mat` and return `f` if `mat` only contains `0`. Otherwise we return `float('inf')` as we have failed to make `mat` a zero matrix after considering every value. Once we have verified that the current square is valid, we try flipping it and its cardinal neighbors by increasing the appropriate value in the flip counter 2D list `cnt`. After recursing on the next square with an additional flip by calling `recurse(i+1, f+1)`, we revert the flips performed in the previous step and try recursing on the next square again. Since we want to minimize the number of flips, we return the smaller return value of the two recursive calls. By definition of `recurse`, the return value we want is that of `recurse(0, 0)`. If this value is `float('inf')` it is impossible to make `mat` a zero matrix by flipping its values, and so we return `-1`. Otherwise, we directly return the returned value.  
  

#### Conclusion
This solution has a time complexity of $O(2^{mn})$, where $m$ and $n$ are the dimensions of `mat`. Each value of `mat` has 2 states; it can either be flipped or not flipped. All possible combinations of these states are explored, of which there are $2^{mn}$ of. As each state takes $O(1)$ time to process, the overall time complexity will be $O(2^{mn})$. The space complexity is $O(mn)$, due to the 2D list `cnt` and the recursion stack.  
  

