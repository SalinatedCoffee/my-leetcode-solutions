## 735. (M) Asteroid Collision

### `solution.py`
For a problem like this, where we want to identify matching pairs involving previously encountered values in chronological order, an approach involving stacks is typically effective. One important thing to note is that the order in which we encounter asteroids matters, and consequently for inputs like `asteroids = [-1, 1]` the two asteroids will never collide with each other. Hence, the only scenario where we should be concerned about collisions is when the last encountered asteroid is moving to the right, and the current asteroid is moving to the left. When a collision does happen there are three scenarios that can occur. The asteroid on the top of the stack `m` is larger than the current asteroid `i`, both asteroids are the same size, or `m` is smaller than `i`. For the first case, we simply pop `m` off of the stack and perform the comparision again. For the second case we also pop `m` off the top of the stack, but we will also need to discard `i` and move on to the next asteroid in `asteroids`. For the last case, we just discard `i` and continue the iteration. We need to add `i` to the stack when collisions do not occur anymore, which we need to separate from the other cases. This can be done using a separate flag boolean for every asteroid in `asteroids`, where it is first initialized to `True` and later changed to `False` whenever the second and third collision cases are encountered. Before moving on to the next asteroid in `asteroids` we only add `i` to the stack if the flag is `True`.  

#### Conclusion
This solution has a time complexity of $O(n)$ where $n$ is the length of `asteroids`. `asteroids` is iterated over once, and during each iteration we only perform a fixed number of operations. The size of `ret` may fluctuate but add and remove operations can only occur $O(n)$ times during the entire runtime of the solution, hence the overall time complexity of $O(n)$. The space complexity is also $O(n)$ since `ret` will at most use $O(n)$ memory.  
  

