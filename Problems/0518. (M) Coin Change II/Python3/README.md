## 518. (M) Coin Change II

### `solution.py`
Intuition tells us that we may try taking a dynamic programming approach to this problem, as it looks like the problem can be broken down into subproblems. Since we want the number of *unique* combinations, those such as `1+1+2` and `1+2+1` should be counted as 1 combination. As such, a na√Øve recursive relation with only the amount as its parameter will fail because it will overcount combinations as explained. We will need to also keep track of some piece of information pertaining to what coins have been used previously, in order to avoid this problem. `1 <= len(coins) <= 300`, so bit representations are not feasible since we would need to represent $2^{300}$ states. We could keep track of the last coin that was used, but that still would overcount combinations such as `2+2+1+1` and `2+1+2+1`. This problem can be remedied, however, if we twist this idea slightly and keep track of the `i`th coin where we have **finished** considering coins in `coins[:i]`. The crucial point to realize here (which admittedly took me an embarrasing amount of time) is that if we build up combinations with coins in the order that they appear in `coins`, we can come up with a recurrence relation that avoids overcounting. Without this detail, we could have tried examining previous states for every used coin, so for example `1+1` could be later built up to `1+1+2+1` and `1+1+1+2`. Instead, we keep things simple by either using the current `i`th coin (possibly again) or skipping the current coin. If $f(a,u)$ returns the number of unique combinations using `coins[:u+1]` coins to add up to `a`, $f(a,u) = f(a-\texttt{coins[}u\texttt{]}, u) + f(a,u+1)$. If the $u$-th coin is larger than the remaining amount `a` we obviously cannot use that coin. In this case, we try using the next coin which is simply $f(a,u+1)$. There are 2 base cases; when $a = 0$, and when $u = \text{len}(\texttt{coins})$. For the former, there is only 1 way to build up to an amount of 0 and so we return $1$. For the latter, we have exhausted all coins that can be used and so we cannot possibly build up a combination. We return $0$.  
By definition, we want the return value of the state $f(\texttt{amount}, 0)$ ($f(\texttt{amount}, \text{len}(\texttt{coins}))$ would be incorrect as it represents the state where we have *finished considering* all coins but have to build up `amount`). $f()$ is also trivially memoizable, which we have done by using the $\texttt{amount} \times \text{len}(\texttt{coins})$ 2D list `dp`.  

#### Conclusion
The time complexity is $O(mn)$, where $m$ is `amount` and $n$ is the length of `coins`. There are in total $mn$ possible states, during each of which we perform a fixed number of operations. The space complexity is also $O(mn)$.  
  

