## 857. (H) Minimum Cost to Hire K Workers

### `solution.py`
Given two lists of equal length, with `quality[i]` containing the quality value of the `i`th worker and `wage[i]` their wage, we are asked to return the minimum total cost to hire exactly `k` workers. There are two conditions that must be met when paying out the hired workers. A worker must be paid at least that worker's `wage` value, and all workers must be paid proportionally by their contribution to the total amount of work completed. That is, if the quality and wage for one worker is `10`, `70`, and `5`, `30` for the other worker, the first worker should take `10/(10+5) = 2/3` of the total payout and the second worker, `1/3`. If we calculate the payout based on the second worker's minimum wage, we would end up paying the first worker `30/5*10 = 60`. Because this is below the minimum wage of `70`, we need to instead compute the payout based on the wage of the first worker, which would yield a total payout of `70/10*(10+5) = 105` with the first worker taking `70` and the second, `35`(which is higher than the minimum wage of `30`).  
There are two things to consider. First, we should hire workers in ascending order of their wage-to-quality ratio as a worker with a small ratio means that they cost less to hire. Second, when we already have hired `k` workers, we should remove the worker with the highest quality value to make room for a new worker. As previously observed, we need to calculate the total payout using the *highest* wage-to-quality ratio amongst those hired in order to guarantee that every worker is paid at least their minimum wage. Hence, it would be logical to remove the worker that does the most work(has the highest quality) in order to keep the total cost to a minimum. We can implement a solution that first creates a sorted list of ratios and quality values, after which the workers are greedily hired and their quality values are stored in a max heap.  
A sorted list of tuples containg the wage-to-quality ratio and quality of a worker can be easily generated using list comprehension. Then, an empty heap is initialized, along with the minimum total cost and the sum of the quality values of those currently hired. Iterating over the sorted list of tuples, we first push the current worker's quality value onto the heap and update the total quality. We then check whether we have hired more than `k` workers, removing the worker on the top of the heap if so. If at this point we have hired exactly `k` workers, we compute the total cost of hiring the current set of workers by computing the product of the current total quality and the current worker's wage-to-quality ratio(which is guaranteed to be the largest among all hired workers since the ratio list is sorted in ascending order) and update the minimum total cost if necessary. Once all workers have been examined, the minimum total cost `ret` will containg the value we want.  

#### Conclusion
This solution has a time complexity of $O(n\log n + n\log k)$, where $n$ is the number of workers(length of `quality` and `wage`) and $k$ is `k`. We first generate a list of tuples of length $n$. This list is then sorted using Python's built in sort, which takes $O(n\log n)$ time to complete. The sorted list is then iterated over, with each ratio-quality pair interacting with a heap at most 2 times. Since the heap's size is bound by $k$, each interaction will take $O(\log k)$ time, bringing the overall time complexity to $O(n\log n + n\log k)$. The space complexity is $O(n+k)$, as the list of ratio-quality pairs contains $n$ tuples and the heap can at most contain $k$ items.  
  

