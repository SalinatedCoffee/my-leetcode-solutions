## 2366. (H) Minimum Replacements to Sort the Array

### `solution.py`
The first instinct would be to try taking a dynamic programming approach, trying all possible choices for some number to make the pre/suffix subarray sorted. Upon further examination however, we realize that there exists an optimal way to split a number - which allows us to implement a greedy algorithm that will run faster than a dynamic programming based solution.  
We first acknowledge the problem by stating that at least one  adjacent pair `nums[i]` and `nums[i+1]` exist where `nums[i] > nums[i+1]`, since `nums` is not sorted. For such pairs, there are 2 possible actions that can be taken. Either the larger number is split, or the smaller number is split. The end result should be sorted in ascending order, which is why we can argue that splitting the smaller number will increase the minimum number of replacements that need to be made. For example, let `nums[i] = 3` and `nums[i+1] = 2`. If we split `nums[i+1]` into `[1,1]`, we would have to split `nums[i]` 2 times in order to make the sorted array `[1,1,1,1,1]`. On the other hand, we can simply split `nums[i]` in the first step, which would result in the sorted array `[1,2,2]` with only 1 replacement instead of 3.  
Now that we know which value we should be splitting, we should try determining how many pieces we should be splitting the value into. Clearly we should try maximizing the smallest split value so that the preceding value has a higher chance of being smaller(and thus already sorted). The base case would be when `nums[i]` is divisible by `nums[i+1]`, in which case we can simply split `nums[i]` into `nums[i] // nums[i+1]` pieces. If `nums[i]` is not divisible, we try and maximize the smallest piece by splitting `nums[i]` in to the mimimum possible number of pieces and distributing the remainder as evenly as possible. So if `nums[i] % nums[i+1] == 0`, we would get `nums[i] // nums[i+1]` pieces, and `nums[i] // nums[i+1] + 1` otherwise. We can divide `nums[i]` by the number of pieces to compute the value of these pieces. By performing integer division, this value is also that of the smallest piece when `nums[i]` is not divisible, which is what we want.  
Finally, we need to figure out which direction we should be iterating along `nums`. Since we have already determined that splitting the largest (the left) value of an unordered adjacent pair is optimal, the split of `nums[i-1]` would be affected after processing `nums[i]` and `nums[i+1]`. Therefore we should be iterating from right to left, while leaving the last value untouched (which is always optimal, as we have established in paragraph 2).  
Whenever a split occurs, the number of operations required to create `n` pieces is `n-1`, and so we increment a counter by that value after processing an unordered pair.  
Another thing to note is that the actions taken on the next value only depends on the smallest value of the split pieces in the current value, and thus we do not need to insert all pieces in `nums`. We can simply replace `nums[i]` with the piece value and move on to the next.  

#### Conclusion
This solution has a time complexity of $O(n)$, where $n$ is the length of `nums`. We iterate through `nums` once, and for each iteration we only perform a fixed number of constant-time operations - hence the overall time complexity of $O(n)$. The space complexity is $O(1)$.  
