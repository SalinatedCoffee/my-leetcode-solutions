## 2458. (H) Height of Binary Tree After Subtree Removal Queries

### `solution.py`
Given the root node `root` of a binary tree, we are asked to return a list of resulting values after running each query in `queries`. A query involves removing a node from the tree and returning the new height of the tree; that is, the return value of running `queries[i]` on the tree should be the new height of the tree after removing the subtree rooted at the node `queries[i]`. Each query is self contained, which means that a query should always be performed on the original state of the given tree.  
The brute force solution would obviously take too long to perform, as the entirety of the tree would have to be traversed for each and every query. Instead, we can precompute what the height of the modified tree would be after removing each node as we traverse the tree. Performing a DFS traversal on the tree, we keep track of the maximum depth previously seen. If the current node was to be removed from the tree, then the height of the tree will be equal to the maximum seen depth. Of course, it may be the case that the untraversed portion of the tree is taller than the previously seen maximum depth. To take this into account, we make 2 passes over the tree - once in normal preorder(NLR) and once in reverse preorder(NRL). During the second pass, we examine the previous 'query height' and the maximum previously seen depth, selecting the larger value among the two. Once the traversal completes, we will end up with a list of tree heights after each node is removed. The desired list can be trivially generated using list comprehension and the list `queries`.  

#### Conclusion
This solution has a time complexity of $O(m+n)$, where $m$ is the length of `queries` and $n$ is the number of nodes in the binary tree rooted at `root`. DFS is performed twice on the given tree, and because processing each node takes $O(1)$ time to complete, the time complexity of the height computation step comes out to be $O(n)$. Generating the list of query results takes $O(m)$ time, as there are $m$ queries and retrieving the value of a single query requires $O(1)$ time. Thus, the overall time complexity of this solution becomes $O(m+n)$. The space complexity is $O(n)$, due to the recursion stack and the list of 'query height's.  
  

