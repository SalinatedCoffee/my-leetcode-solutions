## 2948. (M) Make Lexicographically Smallest Array by Swapping Elements

### `solution.py`
For the list of positive integers `nums` and positive integer `limit`, we can select any 2 elements `nums[i]` and `nums[j]`, and swap them if `abs(nums[i] - nums[j]) < limit`. Our task is to return the lexicographically smallest arrangement of `nums` after performing any number of swaps.  
Thinking about the problem, it is not difficult to see that we can rearrange elements in any way we want if a group of elements are 'continuous within `limit`'. A group is 'continuous' if when sorted, the expression `group[i] - group[i-1] == limit` evaluates to `True` for all possible `i`. This is because swapping is a transitive operation; if `a` can be swapped with `b`, and `b` can be swapped with `c`, we can swap `a` with `b`, `b` with `c`, and `a` with `b` again to achieve the same effect as swapping `a` with `c`(`abc` -> `bac` -> `cab` -> `cba`). Thus, if we can identify groups of such elements within `nums`, we can generate the lexicographically smallest version of `nums` by sorting elements groupwise.  
Since we can swap any pair of elements as long as the difference is less than or equal to `limit`, we can sort `nums` to make the grouping of elements easier. When rearranging `nums`, we need 2 pieces of information; the group that an element belongs to, and the list of elements within that group that are yet to be swapped in. These can be kept track of by using dictionaries. `v2g`(value-to-group) will store the mapping between an element's value and its group label. Note that we do not have to handle duplicate values separately since they will obviously fall under the same group(difference of `0`, but `limit` is at least `1`). `g2l` will map the group label to a deque containing the remaining elements of that group that have not been swapped in. We use a deque instead of a list so that we can efficiently remove swapped in items from the group without having to maintain a separate index.  
The sorted copy of `nums`, `nums_sorted` is created, after which the current group label `cur` is initialized to `0`. After adding the first element of `nums_sorted` to group `0`, we start iterating over `nums_sorted` starting with the element at index `1`. If the absolute difference between the current element and the previous element is greater than `limit` the current element must be placed in a new group, which we achieve by incrementing `cur` by `1` before adding the current element to group `cur`. Once all elements have been assigned a group, we iterate over the `nums` while swapping in elements in the same group as the current element. The group of the current element `nums[i]` is the value of `v2g[nums[i]]`, and the remaining elements within that group is `g2l[v2g[nums[i]]].popleft()`.  

#### Conclusion
This solution has a time complexity of $O(n\log n)$, where $n$ is the length of `nums`. Sorting `nums` using Python's built in sort takes $O(n\log n)$ time to complete. Assigning each element to a group takes $O(n)$ time, as well as swapping in the grouped elements back into `nums`. The space complexity is $O(n)$, due to `v2g`, `g2l`, and the sorting step.  
  

