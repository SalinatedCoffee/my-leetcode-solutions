## 135. (H) Candy

### `solution.py`
A child with a higher rank than their neighbors must be given the most candy among the three children. Since it does not matter how many we give that child, we want to minimize the number of candies that we give away by giving that child the bare minimum that satisfies the requirement, which is just one more candy than the neighbor with the most pieces of candy. More formally, if `ratings[i] > ratings[i-1]` and `ratings[i] > ratings[i+1]`, we want to give the `i`th child `max(candy[i-1], candy[i+1]) + 1` pieces of candy. We can also think of the problem in terms of strictly increasing segments. Within these segments, we increment the number of candy we give away by `1`. If the next child has the same or lower rating than the current child, we ideally would want to give that child `1` piece of candy. However, if the next *next* child has a lower rating still than the next child, we clearly cannot give the next child only `1` candy as that would violate the requirement. Instead, the correct number of candies to give to this child would depend on the length of the strictly decreasing segment that comes after it. That is, if `ratings = [..., 98, 46, 45, ...]` the child with rating `46` would ideally be given `1` candy. However the next child has a smaller rating of `45`, which prevents us from giving only `1` candy to the child rated `46`. As a child with a higher rating than their neighbors must be given the most candies, `46` must be given more candies than `45`, and if the child that comes after `45` has a lower rating than `45` must also be given more candies than that child.  
The solution involves making two passes over `ratings`; one from left-to-right, and another from right-to-left. Both traversals greedily gives out candies by minimizing the number of candies handed out. For the left-to-right traversal, we check if the current child has a higher rating than the previous one. If true we give the current child `1` more candy than the previous child, otherwise we give the child `1` piece of candy. The second pass corrects the 'overly greedy' handouts as described earlier by applying similar logic used in the first pass. If the current child has a higher rating than the previous (relative position in context of the traversal direction) but the current child has been given a smaller or equal number of candies than the previous child, we give the child `1` more candy than the previous child.  
Note that these two passes cannot easily be reduced to a single pass as the direction of the dependency relationship is different than the traversal direction. For example, in the first pass going from left to right, we must move *backwards* in order to correct an overly greedy allocation which cannot be accomplished in a trivial manner.  

#### Conclusion
This solution has a time complexity of $O(n)$ where $n$ is the length of `ratings`. We store the alloted candy of each child in the list `sweets`, which is $n$ long. `ratings` is also iterated over 2 times, where each iteration takes constant time to process. The space complexity is also $O(n)$, due to `sweets`.  
  

