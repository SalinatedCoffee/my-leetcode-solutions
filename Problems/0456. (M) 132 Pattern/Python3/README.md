## 456. (M) 132 Pattern

### `TLE.py`
We can start off by coming up with a brute force solution in order to get a feel for what we are dealing with. The obvious brute force approach is to simply test all possible triplets in `nums`, which there are $O(n^3)$ of. However, we can reduce this down to $O(n^2)$ by changing how we select the first number (at index `i`). For some valid triplet of numbers at indices `i`, `j`, and `k`, if we choose a valid pair for `i` and `j`, we know we can validate whether a valid triplet exists for this configuration by checking whether `nums[k]` is within the interval `(nums[i], nums[j])`, where `k > j`. This is a linear-time operation, and thus we must now devise a method of choosing a valid pair `i`, `j` with the same time complexity. Going back to the problem description, we want to determine whether a valid 132 pattern *exists* or not, and don't care about the exact pattern that appears within `nums`. Hence, among the potential `i`s to the left of `j`, we can simply choose the index `i` with the *smallest* `nums` value. This greedy behavior yields a longer valid interval for `k`, and thus is the most optimal in searching for a valid 132 pattern.  
The implementation involves a nested for loop, where the outer loop selects `j` while updating `i`, and the inner loop validates all possible `k`s against the current configuration of `i` and `j`.  

#### Conclusion
This algorithm has a time complexity of $O(n^2)$, but is still not fast enough and will fail to pass with TLE. The space complexity is $O(1)$.  
  

### `solution.py`
The previous attempt, while slow, has parts that we can build upon to move towards a working solution. In the previous attempt, we searched the relevant portion of `nums` in order to check all possible `k`s against a `i` and `j` pair. If we can reduce the time complexity of this step to constant, a linear solution can be feasible. But how do we go about doing so? Again, given a valid pair `i` and `j`, there must be a `nums[k]` that is in the interval `(nums[i], nums[j])` for a 132 pattern to exist. In other words, in the subarray `nums[j+1:]`, we only need to consider values that are *at least* larger than `i`. And, among these values, if there exists one that is also smaller than `nums[j]`, we know that a 132 pattern exists. The 'greedy' way of selecting the value of `k` is to simply choose the **smallest** value among all candidate `k`s. If this value is larger than `nums[j]`, then there cannot possibly be another `k` that completes a valid 132 pattern, and we can move on to a different value for `j`. These candidate `k` values can be stored using a stack, where the contents will be implicitly sorted in descending order (top element will be the smallest) through the way the values are pushed.  
First of all, we need to make sure that given some list of candidate `k`s, we have looked at **every** possible `k`s in the relevant subarray. In order to do so, we need to iterate over `nums` in reverse order. One problem that arises from this is that we can no longer determine the minimum value to use as our `i` as we did previously. A simple way of circumventing this problem is to precompute an array `mins`, where `mins[j]` contains the minimum value in the subarray `nums[:j+1]`. Now, when iterating over `nums` in reverse order, we check whether `nums[j] > mins[j]` to determine whether a valid `i` exists for the current `j`. If not, we move on to the next value for `j`. Otherwise, we check the stack to see if there is a value for `k` that would complete a 132 pattern. As explained earlier, for a value to be considered as a candidate `k`, it must be larger than whatever value `i` is. Thus we keep popping elements off of the stack if it is larger than `mins[j]`. If the top of the stack after this operation is smaller than `nums[j]`, we have found a 132 pattern and can immediately return `True`. Otherwise we push `nums[j]` to the top of the stack as we have already established that `nums[j] > mins[j]`, and `nums[j]` is thereby a valid candidate for `k`.  
When `nums` is fully traversed without returning prematurely, we can return `False` as no 132 pattern could be found.  

#### Conclusion
The time complexity of this solution is $O(n)$, where $n$ is the length of `nums`. `nums` is traversed once to preprocess `mins`, and another time to determine whether a 132 pattern exists. The stack can grow and shrink in size during the second traversal, but since it can at most contain $O(n)$ elements, a total of $O(n)$ operations will be performed on the stack over the entierety of the traversal of `nums`. Hence, the overall time complexity is $O(n)$. The space complexity is $O(n)$ as we store the results of preprocessing in the list `mins`, which has a length of $n$.  
  

