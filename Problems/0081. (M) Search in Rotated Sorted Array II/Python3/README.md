## 81. (M) Search in Rotated Sorted Array II

### `solution.py`
This problem is exactly the same as problem 33, [Search in Rotated Sorted Array](../../0033.%20(M)%20Search%20in%20Rotated%20Sorted%20Array) - except for the fact that duplicates are allowed to exist in `nums`. This seemingly minor change is enough to invalidate the last approach, where we decided which half to choose based on where the pivot was. One such counterexample would be if `nums = [0,0,0,0,0,1,0,0]`. Splitting `nums` in half we get `[0,0,0,0]` as the left half, `0` as the middle element, and `[1,0,0]` as the right half. Using the algorithm from problem 33, we cannot determine which half contains the pivot since the boundary elements as well as the middle element are all equal. The only solution in this case is to examine each and every element in `nums`. In instances like the previous example where `nums` is comprised by 2 unique values and one of those values appears exactly once, we **must** iterate through the entirety of `nums` since that singular value may be anywhere in `nums` with no way for us to take an educated guess as to where it may be. Due to this this problem cannot be solved in sub-linear time, which allows for the simplest of solutions that loops over `nums` and returns `True` whenever `target` is found.  
For this solution, we have tweaked the second solution for problem 33. Instead of discarding half of the interval, we shrink the window in increments of `1` depending on the best guess that can be made. The search will eventually settle upon `target` if it exists, at which point we return `True`.  
Note that this solution could have also be written as a simple `for` loop that searches for `target` in a linear fashion.  

#### Conclusion
This solution has a time complexity of $O(n)$, where $n$ is the length of `nums`. As is usually the case for binary search solutions, the space complexity is $O(1)$.  
  

### `solution_2.py`
We may improve upon the first solution by taking a more opportunistic approach where we discard half of an interval whenever possible, and incrementally shrinking it only when it is necessary. Even with duplicates we know that a pivoted array is simply two sorted arrays appended to each other. And because they were originally part of a single sorted array, we can say that *all* elements in the right part (relative to the pivot) are less than or equal to the first element in the left part. Using this we can determine which part `target` resides in even without knowing the location of the pivot. If `target < nums[0]`, that would mean that `target` resides in the right part. If `target > nums[0]`, `target` is in the left part. Finally, if `target == nums[0]`, it may be in *either* of the two intervals since initially `nums[0] = left[0]`, and `i <= left[0] for i in right` as we have established earlier. This method can be used for *any* number and not just `target`. That is, in the context of binary search, we can check if the middle element and `target` are in the same interval. If they are, then they are both within an interval that is properly sorted and we can decide which half to discard by comparing `target` and the middle value. If the middle value is in the left portion and `target` is in the right portion, we know that we can discard the left half as the right portion only begins after the left one, and the same can be said for the opposite case. The problematic case is when the middle value and `left[0]` is equal, as this means that the middle value can be in either the left or right part. Consequently, we cannot decide which half is safe to discard and must shrink the search interval incrementally.  
Thus, after splitting the search interval about the middle index `m` we first check if we can determine if we can place `m` in either of the two parts. If not, we must increment the left boundary by `1`. Otherwise we check whether `m` and `target` are in the same part or not. If so we can directly compare `nums[m]` and `target` to decide which half should be discarded. If not, we make the decision based on the locations of `m` and `target`.  
  
#### Conclusion
The time complexity is still $O(n)$, but this solution will run much faster than the previous one since the best case performance is now down to $O(\log n)$ from $O(n)$. The space complexity is $O(1)$.  