## 564. (H) Find the Closest Palindrome

### `solution.py`
Given the string representation of an integer `n`, we are asked to find a palindrome that is closest but not equal to `n`, with the closeness simply being the absolute difference between `n` and the palindromic number. If there are multiple palindromes with the same distance, we should return the palindrome with the smallest value. Because we want to minimize the difference as much as possible, there are only a few ways of constructing a palindrome that we have to consider.  
First off, it becomes obvious that we should be mirroring the first half of `n` to generate a palindrome in order to minimize the difference between the two numbers. Of course, the mirroring should be able to handle both odd and even length palindromes. `n`s of even length are easy to handle. For `n`s of odd length, we will include the middle value when extracting the first half. Building a palindrome from the first half is easy, but are there any variations that we should be considering? There are indeed - in some cases, it may be the case that the palindrome from the unmodified first half is *not* the palindrome closest to `n`. One simple example would be `n = 139`. Here, the first half is `13` which forms a palindrome of `131`. However, we know that `141` is also a palindrome which is closer to `139` than `131`. The same could be said in the other direction, for instance when `n = 131`. `n` is already palindromic, so we try adding `1` to the first half like we did for `n = 139`, yielding the palindrome `141`. However, it is obvious that `121` is the correct answer since `121` and `141` both have a difference of `10` but `121` is less than `141`. We can also observe that in/decrementing the half by values larger than `1` is not optimal. Thus, we come to the conclusion that we should be considering palindromes generated by the untouched and in/decremented versions of the first half of `n`. Are there any other cases that should be handled? Consider the case where `n = 999`. The three patterns we have established will yield the palindromes `999`, `100001`, and `989`. Here the second and third candidates each have a distance of `99002` and `10`, although it is not difficult to see that `1001` is also a palindrome but is closer to `n`. As was the case for the mirrored palindromes, we can also say the same in the opposite case. Let `n = 1000`. The set of mirrored palindromes will be `1001`, `99`, and `1111`. While `1001` has a distance of `1`, `999` is smaller than `1001` and also has a distance of `1` - but is not included in the list of candidates. This leads us to the conclusion that we should be checking these edge cases on top of the three mirrored palindromes. Both patters can easily be generated by evaluating the expression `10**d+1` for `10...1`-shaped palindromes, and `10**(d+1)-1` for `9...`-shaped palindromes.  
Once all 5 palindromes have been constructed, we iterate over all of them to determine the palindrome with the smallest difference between `n`.  

#### Conclusion
This solution has a time complexity of $O(n)$ where $n$ is the *length* of `n`. Extracting the first half of `n` takes $O(n)$ time, as well as generating each candidate palindrome. The space complexity is $O(1)$.  
  

