## 2116. (M) Check if a Parentheses String Can Be Valid

### `solution.py`
The string `s` is a string containing only open(`(`) and close(`)`) parentheses. `locked` is a binary string, with `locked[i] == '0'` meaning that `s[i]` can be changed to any type of parenthesis and `locked[i] == '1'` meaning that `s[i]` cannot be changed. Given `s` and `locked`, we are asked to determine whether `s` can be made into a valid set of parentheses after any number of operations.  
As is usually the case for parenthesis matching problems, we can use a stack to keep track of open parentheses that are yet to be matched. When iterating over `s` while matching parentheses, we can instinctively see that matching parentheses using 'locked' parentheses as much as possible is the most optimal behavior since 'wildcard' parentheses can be any type of parenthesis. We also have to keep in mind that a hanging open parenthesis can only be matched using a wildcard if the hanging parenthesis is on the left of the wildcard. This means that we need to keep track of the index of each hanging parentheses and wildcards, which we can achieve by pushing the index onto the appropriate stack.  
Before doing anything else, we check the length of `s` to see if it has an odd length. If so, it is impossible to make `s` balanced, and we return `False`. We then initialize 2 empty stacks, where one will be used to store the index of hanging open parentheses and the other for storing unused wildcards. The matching step can now be started by iterating over `s`. If the current character is a wildcard, we defer 'using' it by pushing the current index onto the wildcard stack. Otherwise, we check whether it is an open or close parenthesis and process it accordingly. For the former, we simply push it onto the open parenthesis stack and move on to the next character. For the latter, we prioritize matching it with a locked parentheses by looking at the open parenthesis stack. If the stack is empty, we spend a wildcard by popping an item off of the wildcard stack. If the wildcard stack is empty as well, the current parenthesis cannot be paired and we immediately return `False`. Once the traversal over `s` has completed, we attempt to pair any remaining open parentheses with the unused wildcards. Because we have stored these parentheses and wildcards in a stack, the top of the stack will correspond to the rightmost item in its category. This means that we may pair characters and wildcards simply by comparing the index of the items at the top of each stack. If the index on the top of the parenthesis stack is greater than that of the wildcard stack, the parenthesis cannot be paired, which means that `s` cannot be made valid by consequence.  

#### Conclusion
This solution has a time complexity of $O(n)$, where $n$ is the length of `s`. `s` and `locked` are simultaneously iterated over exactly once, with each character pair requiring only $O(1)$ time to process. The space complexity is also $O(n)$, due to the stacks `stack` and `wildcards`.  
  

### `solution_2.py`
In the previous solution, we had to use stacks to keep track of open parentheses and unused wildcards since we needed to know the relative positions of the characters in order to pair them correctly. If we make two passes over `s` and `locked`, once from left to right and once in the reverse direction, we can ensure that the parentheses are correctly paired without having to keep track of their individual index.  
`stack` and `wildcards` are now integers, which are incremented by `1` whenever an item is pushed onto their counterparts in the previous problem, and decremented by the same amount whenever an item is popped off. Once the initial pass is complete, we initialize the integer `unmatched` to `0`. `unmatched` will represent the number of unmatched open parentheses. `s` and `locked` are then iterated over in reverse, decrementing both `unmatched` and `wildcards` whenever the current element is unlocked. If the current character is an open parenthesis, we increment `unmatched` and decrement `stack`. If it is a close parenthesis, we decrement `unmatched`. Once the appropriate counters have been updated, we examine `unmatched` to determine whether the current state is valid. If `unmatched` is greater than `0`, it means that there is a hanging open parenthesis that cannot be closed and we immediately return `False`. If there are no more wildcards left as well as unmatched open parentheses, we end the loop early. Once the loop exits, we examine the value of `stack` and return the appropriate value.  

#### Conclusion
The time complexity is identical to the previous solution. The space complexity is $O(1)$, as `stack` and `wildcards` are integers rather than stacks.  
  

