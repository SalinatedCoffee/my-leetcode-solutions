## 670. (M) Maximum Swap

### `solution.py`
Given the non-negative integer `num`, we are asked to return the maximum possible value after swapping two digits of `num` *at most* once. Intuition tells us that a single optimal swap exists for integers where a swap would increase its value. Obviously, we would want to include one of the more significant digits in the swap as we want the maximum possible value after the operation. Because an increase of `1` in the `i`th digit(counting from the left) increases the value more than any increase in the `i+1`th digit, we should be considering digits starting from the left and move towards the right. If there exists a digit that has a larger value than the current digit being considered, we should swap them and return the new value. But what if there are multiple larger digits? As we are aiming to maximize the value after the swap, it would make sense that we would want to select the largest viable digit. That is, among all possible `j` that satisfies the conditions `i < j` and `num[i] < num[j]`, we would want to choose the one that has the largest value of `num[j]`. What if there are *multiple* instances of `j` that satisfies these constraints? For example, consider the case where `num = 199`, and we are currently considering the `1`(`i = 0`). Both the first `9` and second `9` are larger than `1`; which one should we be swapping? In this trivial example, the answer is obviously the second `9`, which would yield the integer `991`(which is larger than the other case, resulting in a value of `919`). If we were to somewhat formally explain why the second `9` was chosen, we can think about the number in two parts. Excluding the `i`th digit and all digits to its left, we can see that swapping digits also has the effect of reducing the value formed by the remaining digits. Returning to the example, the number would be `99` where we are swapping a `9` with a `1`. We want to maximize this number after the swap, which means that we would want to select the *least significant* digit. Putting these observations together, we can clearly describe the greedy algorithm as the following:

- Consider each digit, starting with the most significant digit down to the least significant.
- For each digit, scan through all digits towards its right to identify the largest digit larger than the current digit.
- If multiple digits satisfy the previous condition, select the least significant digit.

`num` is given to us as an integer, which we can convert into a list of characters to make it easier to work with. If a swap occurs at any point during the loop, we perform the swap and immediately return the resulting value as we are permitted to perform only one swap at most. The loop will exit normally if `num` cannot be increased, at which point we can return `num` as is.  

#### Conclusion
This solution has a time complexity of $O(\log^2_{10}(n))$, where $n$ is `nums`. Conversion of `num` to the list of characters `num_digits` requires $O(\log_{10}(n))$ time to complete, as `num` is a base 10 integer. The search step that follows considers all digit pairs within `num`, thus taking $O(\log^2_{10}(n))$ time to complete. The space complexity is $O(\log_{10}(n))$, due to `num_digits`.  

