## 769. (M) Max Chunks To Make Sorted

### `solution.py`
We are given the list of integers `arr`, which contains a permutation of the integers in the range `[0, len(arr)-1]`. If `arr` were to be partitioned into multiple subarrays, where sorting and then concatenating each chunk would result in the elements of the entire resulting array being sorted, our task is to determine the maximum number of partitions that can be created. For example, consider the case where `arr = [3, 2, 1]`. Because the order of the chunks *cannot* be changed when they are concatenated, the partitioning `[3], [2], [1]` is invalid. Instead, we need to include all 3 elements into the same partition - which means that the correct value would be `1`.  
Instead of thinking about the problem as splitting `arr`, we can consider the problem as grouping up the elements of `arr` in multiple contiguous subarrays. This way, if we were to group elements while iterating over `arr`, we can say that each element can either be added to the current group of elements, or placed in a new partition. Our problem now becomes devising a method to determine which action should be performed for a given element.  
Because `arr` conveniently only contains integers from `0` to `len(arr)-1`, we can determine whether a value is in its 'correct' position by evaluating the expression `arr[i] == i`. Whether the `i`th element is subject to a sort, however, depends on other factors as well. For instance, if there exists an element `arr[j]`(where `i < j`) where `arr[i] > arr[j]`, `arr[i]` and `arr[j]` **must** be part of the same partition for `arr[j]` to be sorted into its correct position. Similar logic can be used for `arr[k]`, where `k < i` and `arr[i] < arr[k]`. While useful, this still does not tell us if we should add `arr[i]` to the current partition or create a new one. To determine this, we need to look at the subarrays `arr[:i+1]`(prefix of `arr` ending at `i`) and `arr[i:]`(suffix of `arr` starting with `i`). We mentioned earlier that even when `arr[i] == i`, `arr[i]` may be subject to sorting if there was an element with a larger value that comes before it(and vice versa). What if no such element existed, but there exists some element `arr[k]` where `i < k`, but `arr[k] < arr[j]` for some element `j` where `j < i`? In other words, there exists an element that comes after `arr[i]` that is smaller than *any* element in the subarray `arr[:i+1]`. In this case, `arr[k]` would obviously be needed to move to somewhere in `arr[:i+1]`, and since whichever element that would be replaced by `arr[k]` is to the left of `arr[i]`, `arr[i]` must also be subject to sorting. This logic can also be used in the other direction, where some value in the prefix is larger than all values in the suffix. Summarizing, some element `arr[i]` *must* be subject to sort if the largest value in `arr[:i+1]` is larger than the smallest value in `arr[i:]`. These two values can be easily precomputed for each and every element in `arr` by scanning through the array twice.  

#### Conclusion
This solution has a time complexity of $O(n)$, where $n$ is the length of `arr`. Three passes are made over `arr` in total; twice to populate `pre` and `suf`, and once to determine the number of splits that can be performed. The space complexity is also $O(n)$, due to `pre` and `suf`.  
  

