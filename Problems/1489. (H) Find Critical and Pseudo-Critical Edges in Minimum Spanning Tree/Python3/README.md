## 1489. (H) Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree

### `solution.py`
First we must make sure that we are familiar with [Kruskal's algorithm](https://en.wikipedia.org/wiki/Kruskal%27s_algorithm) whenever MSTs are mentioned. Kruskal's algorithm is a greedy algorithm that generates an MST given a connected graph (or a minimum spanning forest if not). It internally uses a union find data structure for bookkeeping, and tries to incorporate edges with the smallest weights first. Since `n` is relatively small, we can simply try checking the criticality of *every* edge by creating an MST that relates to that specific edge.  
A critical edge is one that will increase the weight of the MST if it is removed. That is, if we remove some edge `e` from `edges` and create an MST, we can determine whether `e` is a critical edge if the new MST weight is larger than the one generated from all edges. If `e` is not a critical edge, there is still a possibility of it being a pseudo-critical edge. To check for this, we can create an MST that includes edge `e` (notice that creating an MST with `edges` including `e` and *forcing* edge `e` to be part of an MST are two different things). If the new MST has the same weight as the first MST we generated using the entierity of `edges`, we know that edge `e` is part of at least one MST and thus is a pseudo-critical edge. We know that this is the case because we already know that `e` is not a critical edge, and if forcibly including it in an MST did not change the weight that would mean that it is part of *at least* one MST (remember that many different spanning trees of the same weight can exist) - hence `e` must be pseudo-critical.  
Once we have determined the criticality of all edges in `edges`, we can return the two lists of critical / pseudo-critical edge indices.  

#### Conclusion
The time complexity of this solution is $O(|E|^2\cdot \alpha(|V|))$, where $|E|$ is the number of edges (length of `edges`) and $|V|$ is the number of vertices (`n`). Sorting `edges` takes $O(|E|\log (|E|))$ time. If Kruskal's algorithm is implemented to internally use a union-find data structure its worst case time complexity is $O(|E|\cdot \alpha(|V|))$. And because we run this algorithm for each and every edge 2 times at most, the overall time complexity becomes $O(|E|\log(|E|) + |E|\cdot |E| \cdot \alpha(|V|))$(with $\alpha()$ being the [inverse Ackermann function](https://en.wikipedia.org/wiki/Ackermann_function#Inverse)). The space complexity is $O(|E|)$. Our implementation of union-find uses a single array of length `n` to keep track of the parents, and we keep at most 3 objects instantiated at a time. We also make a sorted copy of `edges`, which uses $O(|E|)$ memory. Because the graph is guaranteed to be connected, it must be the case that $|E| \geq |V|$ for any input and thus the overall space complexity becomes $O(|E| + |V|) = O(|E|)$.  
  

