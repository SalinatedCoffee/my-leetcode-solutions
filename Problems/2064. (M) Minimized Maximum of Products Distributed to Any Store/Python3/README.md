## 2064. (M) Minimized Maximum of Products Distributed to Any Store

### `solution.py`
Given the list of product stocks `quantities` and number of stores `n`, we must distribute all of the products to the stores. A single store can only have at most a single type of product in stock, and it is guaranteed to be possible to distribute all products. Our task is to determine and return the smallest possible stock for the store with the most stock after all products have been distributed. For example, let `quantities = [10]` and `n = 3`. The most optimal distribution is `4, 3, 3`, and so we return `4` as it is the largest number of stock amongst all stores. If we were to distribute a single type of product to some number of stores, we know that it is optimal to distribute the product as evenly across the stores as possible. Thus, we can determine what the maximum stock will be in the case where we are given the stock of a single product type and the number of available stores. We also obviously want to allocate more stores to the product type with greater stock, which means that the problem now becomes figuring out how many stores we should be allocating to each product type. As mentioned, we can determine the maximum stock for a single product type when allocating some number of stores. We also want to allocate stores in such a way that this value is minimized across all product types. If we were to store the maximum stock for each product type in a max heap, and assign the stores to the product types incrementally, the maximum stock of the first product type in the heap would be the desired value.  
We first initialize the max heap by creating a list of tuples and 'heapifying' it. The first value of the tuple will be the maximum stock of the product type, and the second will be the index of the product in `quantities`. We also have to keep track of the number of stores that have been allocated to each product type, which we can do by using a separate list of length `len(quantities)`. As we have effectively allocated `1` store for each product type while initializing the heap, we must also reflect this fact on `n` by subtracting `len(quantitites)` from it. We can now begin the allocation process by removing the first item from the heap, assigning an additional store to that product type, and recomputing the maximum stock before pushing the tuple back onto the heap. After decrementing `n` by `1`, we repeat this process until `n` becomes `0`, at which point we will have distributed all of the products. As previously mentioned the first tuple in the heap will contain the desired value, which can be returned after correcting its sign.  

#### Conclusion
This solution has a time complexity of $O((m+n)\log m)$, where $m$ is the length of `quantities` and $n$ is `n`. Initializing the heap takes $O(m\log m)$ time to complete as it contains the maximum stock for each product type. The allocation step that follows loops $O(n)$ times, interacting with the heap twice for every loop. A single insertion/removal from the heap complets in $O(\log m)$ time, making the allocation step require $O(n\log m)$ time to finish. Thus, the overall time complexity of this solution comes out to be $O(m\log m + n\log m) = O((m+n)\log m)$. The space complexity is $O(m)$, due to the heap and list of stores allocated to each type of product.  
  

### `solution_2.py`
We essentially simulated the distribution of products in the first solution, computing the maximum stock every time we allocated a single store. The problem can be approached in a different manner by thinking about the properties of the value we are asked to determine. As the maximum stock of a store decreases, we need more stores to distribute the products. At some point, it will become impossible to achieve a valid distribution - and because we want the minimum possible maximum stock, the value at this inflection point is exactly the one we are interested in. The 'maximum of products' exhibits monotonicity, meaning that if a valid distribution is not possible for some maximum stock `k`, it is also impossible for all values less than `k`. Similarly, if all products can be distributed for some value `k`, it is also possible to do so for any value greater than `k`. This behavior allows us to determine the minimum possible maximum stock through binary search. As the problem constraints guarantee that there will be at least `1` product to distribute, the lower bound of our initial search space will be `1`. The upper bound will be the largest element of `quantities`, since when distributing a product the worse case would be when there is only a single store available.  
Now that we have determined that binary search is viable along with the initial search space, the problem that remains is finding a method to evaluate whether a valid distribution is possible given some maximum stock `k`. Using a formula similar to the one used in the previous solution, we can determine the number of stores required to distribute a single type of product such that the maximum stock is equal to `k`. We simply divide the quantity of that product by `k`, and round it up to the nearest integer. If there are not enough available stores, it is impossible to achieve a valid distribution that has a maximum stock of `k`.  
We define the helper function `verify` that takes the arguments `k`, `q`, and `n`, which will return `True` if the list of products `q` can be distributed to `n` stores where the maximum stock is equal to `k`. After initializing the necessary variables for performing binary search(bounds `l` and `h`), we implement a simple binary search that finds the smallest maximum stock that is valid. When the search finishes, `res` will contain the desired value.  

#### Conclusion
The time complexity of this solution is $O(m\log k)$, where $k$ is the largest element in `quantities`. Evaluating whether a maximum stock is viable requires $O(m)$ time as we iterate over `quantities` while attempting to distribute each type of product. For the binary search step, the size of the initial search step is bound by $k$, which means that the search space will be halved $\log k$ times. As the evaluation of a maximum stock occurs once per halving, the overall time complexity of this solution will be $O(m\log k)$. The space complexity is $O(1)$.  
  

