## 486. (M) Predict the Winner

### `solution.py`
First off we can make things easier for us by realizing that the problem is asking whether player 1 can win or not, instead of the exact score. Because of this, we can think of this problem as searching for the maximum score difference between the two players. If this difference is larger than or equal to zero, player 1 wins, and vice versa.  
We can take a dynamic programming approach to this problem, because we can solve smaller subproblems that build up to the original problem. If we are given the array `nums`, and it is player 1's turn, player 1 can choose between either `nums[0]` and `nums[1]`. Whichever player 1 decides to take, the score difference will increase by either `nums[0]` or `nums[1]`. We now need the score difference of the smaller subproblems, that is, the score differences from where it is player 2's turn and the list of numbers is either `nums[1:]` or `nums[:-1]`. We can apply the same principle in this case since player 2 will exhibit the same optimal behavior as player 1, but now we must account for the score difference being in the perspective of player 2. Whenever player 2 scores, this means that player 1 effectively loses that amount of points, and the score difference from player 1 goes down by that amount. Thus, we need to subtract the score difference from the other player from whatever choice that has been made. Then the recursive function $f$ that returns the maximum score difference of the two players can be defined as $f(l, r) = \text{max}(\texttt{nums}[l]-f(l+1,r), \texttt{nums}[r]-f(l,r-1))$, with the base case being $l = r$ in which case there is no noice but to select $\texttt{nums}[l]$.  
Because $f$ can be called multiple times with the same arguments, we can memoize return values of $f$ to avoid performing redundant computation(achieved by utilizing Python's built-in `@cache` decorator).  
The value we want is from the function call `f(0, len(nums)-1)`, which we check against `0` and return `True` if it is greater than or equal to it.  

#### Conclusion
This solution has a time complexity of $O(n^2)$ where $n$ is the length of `nums`. We compute the maximum score difference for all possible subproblem states, which there are $n^2$ of since a state is represented by two values $l$ and $r$, both of which is in the range of $[0, n-1]$. The space complexity is also $O(n^2)$ since we keep the return value of each computed state in memory.  
  

### `solution_2.py`
A bottom-up solution is also possible. In the previous solution, we defined the base case as being `l == r`, since the player only has one choice that they can make. In a bottom-up solution, we can start from this state and eventually build up to the initial state. Defining a 2D list `dp` where `dp[i][j]` contains the maximum score difference between the two players when a game is played with `nums[i:j+1]`. The values in `dp[i][i]`, where `i` is in the range of $[0, n-1]$ would be analougous to the base cases from the first solution, so we initialize these values to `nums[i]`. We eventually want the value of `dp[0][n-1]`, so we must find a way to start from the diagonal of `dp` and eventually end up with that value. For some `dp[i][j]` the previous turn could have either been `dp[i+1][j]` or `dp[i][j-1]`, where the former being the result of the previous player choosing `nums[i]` and the latter `nums[j]`. As was the case in the previous solution, the maximum difference from the previous state must be subtracted from the score gained from that same turn since `dp` represents the score difference from the perspective of the first player. Thus `dp[i][j] = max(nums[i] - dp[i+1][j], nums[j] - dp[i][j-1])`. The direction of tabulation would be to fill `dp` row-first, towards the upper-right direction.  

#### Conclusion
The time complexity of this solution is $O(n^2)$ since we compute values for all values of `dp[i][j]` (where `i >= j`), and `dp` is a $n\times n$ 2D list. Due to this, the space complexity is also $O(n^2)$.  
Note that the space complexity can be further optimized down to $O(n)$, since the value of `dp[i][j]` only depends on the values `dp[i+1][j]` and `dp[i][j-1]` - that is, we actually only need to keep two rows of `dp` in memory.  
  

