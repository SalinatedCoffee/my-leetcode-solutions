## 1653. (M) Minimum Deletions to Make String Balanced

### `solution.py`
`s` is a string comprised of only `'a'`s and `'b'`s. `s` is 'balanced' when the integer pair `i`, `j` does not exist where `i < j` and `s[i] == 'b'` and `s[j] == 'a'`. In short, `s` is balanced when an index `i` exists such that`s[:i]` contains only `'a'`s and `s[i:]` contains only `'b'`s. A few examples of balanced strings would be `"aaaaaa"`, `"bbb"`, `"aabbbbbb"`, and `"aaaaaab"`. Given these conditions, we are asked to determine the minimum number of characters that can be removed to make `s` balanced. This can easily be achieved by counting the number of `'a'`s(or `'b'`s) for every prefix of `s`. Then, at every potential 'pivot' index(where the prefix of `'a'`s end and suffix of `'b'`s begin) we can compute the number of removals that need to occur to make `s` balanced at that index.  
The counts will be stored in the list `pre` of length `len(s) + 1`. `pre[i]` will contain the number of `'a'`s in the prefix string `s[:i]`. If we know the value of `pre[i]` we can determine the number of `'b'`s in `s[:i]` by evaluating the expression `i - pre[i]`. We can also compute the number of `'a'`s in `s[i:]` if we know the value of `pre[-1]`(the number of `'a'`s in `s`). This is simply the number of `'a'`s in the entirety of `s` subtracted by the number of `'a'`s in the prefix string `s[:i]`, or the evaluated value of `pre[-1] - pre[i]`. Combining the two expressions, we can define the number of removals required to make `s` balanced about the `i-1`th and `i`th characters as the expression `(i - pre[i]) + (pre[-1] - pre[i])`, or `i - 2*pre[i] + pre[-1]`. After precomputing the number of `'a'`s in each prefix of `s`, we iterate over the counts while computing the number of removals to make `s` balanced. We simply choose the smallest value among all possible pivots, which we can return directly once the iteration completes.  

#### Conclusion
This solution has a time complexity of $O(n)$, where $n$ is the length of `s`. Initalizing the empty list of prefix counts, as well as populating said list each requires $O(n)$ time to complete, hence the overall time complexity of $O(n)$. The space complexity is also $O(n)$ due to the list `pre`.  
  

