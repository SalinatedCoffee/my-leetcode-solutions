## 2742. (H) Painting the Walls

### `solution.py`
Clearly we can take a dynamic programming approach to this problem as we can divide the original problem into smaller sub-problems. At some wall `i`, there are 2 choices that we can make. We can either hire the paid painter or simply skip the current wall. This is possible because while the paid painter can only paint the `i`th wall spending `time[i]` time and `cost[i]` money, the free painter can paint *any* wall while the paid painter is occupied. Hence, we can freely choose the walls to call the paid painter on as long as `len(time)` walls are painted.  
The recurrence relation is rather straightforward. If we have some state with 2 parameters `i` and `rem`, where `i` represents the position of the current wall and `rem` represents the remaining number of walls to be painted, we can easily determine what the next states would be based on the choices we make for the current one. If we decide to hire the paid painter, they can paint `1` wall using `time[i]`, and the cost will increase by `cost[i]`. While the paid painter works, we can also call the free painter, who can paint `time[i]` walls at no extra cost. Thus, the cost of hiring the paid painter at the `i`th wall would be `cost[i] + dp(i+1, rem-1-time[i])`, where `dp` would be the recursion state mentioned earlier. On the other hand, if we decide to skip the current wall, the cost would simply be `dp(i+1, rem)` as `0` walls would have been painted. As we want to *minimize* the overall cost, we naturally want to select the choice that yields the smaller cost. Putting these all together, we get `dp(i, rem) = min(cost[i] + dp(i+1, rem-1-time[i]), dp(i+1, rem))`. Lastly, there are 2 base cases in this recurrence relation. When `rem <= 0` it means that we have finished painting all of the walls, and as such we return `0`. When `i == n`, it means that we have run out of walls to call the paid painter on, and so we return `inf` to denote that whichever choice that was made to get to the state is not viable.  
Each state is trivially memoizable, either by manually setting up a 2D list or using Python's `@cache` decorator. The desired value is the return value of `dp(0, len(cost))`, which we can simply return directly.  

#### Conclusion
The time complexity of this solution is $O(n^2)$, where $n$ is the number of walls to paint (`len(cost)`). Each state in the recurrence relation has 2 parameters, both of which are bound by $n$. Computing the value of a single state takes $O(1)$ time, and there are $n^2$ states in total - hence, the overall time complexity is $O(n^2)$. The space complexity is also $O(n^2)$, as we keep the return values of all of the states in memory. The recursion stack will use $O(n)$ space, and will be outscaled by the memoization.  
  

