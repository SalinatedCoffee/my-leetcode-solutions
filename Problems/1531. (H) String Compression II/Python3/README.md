## 1531. (H) String Compression II

### `solution.py`
At first glance it would seem that a greedy or naïve approach could work for this problem. Because know how we can reduce the compressed length by removing letters from runs it would seem trivial to devise an algorithm that performs these operations in an optimal manner. However we need to account for two runs merging together, which makes this problem difficult to solve. For example if we have the string `aabccdcc` and `k = 1`, a naïve approach could simply delete the `b` when deleting `d` would be more optmal as the two runs of `c` would be merged into one(`a2c2dc2` versus `a2bc4`).  
Because we have multiple choices at a given state, and we need to select the one that yields the most optimal value, we should be taking a dynamic programming approach to this problem. To do so, we need to first think about a brute force algorithm. Say we are considering the `i`th character of some string. We can either delete the current character, or not delete it. For the former, we use up a deletion and move on to the next. Otherwise we directly move on to the next character. How would we factor in run merging in this situation? First off, we cannot pass in the actual string as a parameter as that would inflate the number of states that we would need to process. We want a simpler way to relay some information about the examined portion of the string, and we can do so by adding two parameters to the recurrence relation; the character of the last run, and the length of that run. Now we can determine the compressed length whenever a run has been processed, and also make choices based on what the character of the last run is.  
We define a function `recurse(i, k, prev, prev_run)` that returns the minimum compressed length of `s[i:]` given `k` deletions where the previous run consists of the character `prev` and is `prev_run` long. If `s[i] == prev`, that is, the current character is the same as the character of the previous run, there is no need to remove the current character. We extend the previous run by `1`, adjust the compressed length if necessary, and move on to the next character. If `s[i] != prev`, we can either try deleting `s[i]` or skip over it and select the choice that returns the smaller value. When we decide to not delete `s[i]`, we are effectively 'capping off' the current run of characters, changing it with `s[i]`. Thus, we need to add `1` to the return value of the recursive call to account for the compressed length of the previous run. The special cases (run length of 1, 2, or 3 digits) are already handled when `s[i] == prev`, so we only need to add the minimum compressed length here.  
Determining the base cases, the obvious one is when `k < 0`. This  indicates that we have deleted a character in the previous state when there were no deletions remaining. As the current state is invalid, we return an arbitrarily large number. The other case is when `i == len(s) - k`, which means that we can remove all remaining characters. Since it is optimal to remove as much characters as possible, we return a compressed length of `0`.  

#### Conclusion
This solution has a time complexity of $O(n^2k)$, where $n$ is the length of `s` and $k$ is `k`. Analyzing the parameters of the recursive function, we see that `i` and `prev_run` are bound by $n$, `prev` by $26$, and `k` by $k$. Hence, there can be at most $26n^2k$ states, where computing the result of a single state takes $O(1)$ time. Thus the overall time complexity becomes $O(26n^2k) = O(n^2k)$. The space complexity is also $O(n^2k)$ since we memoize the return value of each state in memory.  
  

