## 1838. (M) Frequency of the Most Frequent Element

### `solution.py`
We can only increase the value of an element and are given a budget on the total amount we can increase values. Hence given some element `nums[i]` it is always optimal to try and increase the largest value that is smaller than `nums[i]`, and then the second largest, and so on until we run out of operations that we can perform. This can be solved by simply sorting `nums` in ascending order, after which `nums[i-1]` is guaranteed to be smaller than or equal to `nums[i]`. We could simply iterate over the sorted list and look back until our budget is exhausted, but we can see that this method is obviously not optimal as we would be considering the same element multiple times. Instead, we can take a sliding window approach - incrementally expanding the window and contracting it when the window incurs too much cost. The total cost of a window is the cost of adjusting all values in the window to the last value. Because `nums` is in ascending order, when we add a new element to the window it will be greater than or equal to the largest value in the previous window. Because we already know the cost required to increase the values in the window to the largest value, we can easily compute the additional cost required to increase these values to match that of the element being added. This is simply `(nums[i] - nums[i-1]) * (i - l)`, where `i` is the element being added to the window and `l` is the index of the first item of the window. If this cost is larger than our budget `k`, we incrementally contract the window by advancing `l` until the cost becomes acceptable. Finally, we update the length of the largest window `ret` if necessary.  
Once we have considered every element in `nums` the value of `ret` will be the length of the largest window, which we can return directly.  

#### Conclusion
This solution has a time complexity of $O(n\log n)$ where $n$ is the length of `nums`. We first sort `nums` in ascending order, which takes $O(n\log n)$ time to complete. The sliding window step effectively iterates over `nums` twice, with each iteration taking $O(n)$ time to complete. The space complexity is $O(n)$ due to the sorting step.  
  

