## 1395. (M) Count Number of Teams

### `solution.py`
Given the list of integers `ratings`, we are asked to count the number of subsequences of length 3 where the value of the elements are strictly increasing or decreasing. For example if `ratings = [1, 5, 2, 4, 3]` the valid subsequences would be `[1, 2, 4]`, `[1, 2, 3]`, and `[5, 4, 3]`, yielding a total count of `3`. Because the length of `ratings` is relatively short at `1000` being the maximum length, we can implement a brute force solution that scans `ratings` for each element. Since we are asked to count subsequences of length 3, we can easily count the number of valid subsequences that include some value `ratings[i]` as the 'middle' value if we know the number if values that are strictly smaller than `ratings[i]` to the left of `i` and that of those that are strictly larger to the right of `i`(and vice versa). If the former is `j` and the latter is `k`, the number of valid subsequences would simply be `j * k`.  
Iterating over `ratings`, we iterate over the left and right sections about the current element while counting the number of strictly larger/smaller values than the current one. Once the iteration completes, we compute the number of subsequences and add it to the total before moving onto the next element in `ratings`.  

#### Conclusion
This solution has a time complexity of $O(n^2)$ where $n$ is the length of `ratings`. `ratings` contains $n$ elements, where $n-1$ items are scanned for each and every value in `ratings`. Thus, the overall time complexity of this solution is $O(n^2)$. The space complexity is $O(1)$.  
  


### `solution_2.py`
In the previous solution we scanned the entirety of `ratings` to count the number of strictly larger/smaller values than the current element, making the counting step take $O(n)$ time to complete. Instead of manually counting these values every time, we can use something called a [Fenwick tree](https://en.wikipedia.org/wiki/Fenwick_tree)(or a binary indexed tree) to efficiently retrieve the cumulative frequency across a range of values. A Fenwick tree is an implied tree that uses a list as its underlying data structure. A node is annotated with the cumulative frequency of all elements less than or equal to it, with the tree being traversed by using the properties of binary numbers to compute the index of the child/parent node. Because these annotations behave a bit like buckets, the length of the list used to store a tree is equal to the largest value in the original list. A lookup/update operation on the tree takes logarithmic time with respect to the largest value in the original list since it is a balanced binary tree.  
Let the Fenwick tree `l_tree` contain the cumulative frequencies of the elements to the left of `ratings[i]`, and `r_tree` for the right. We can efficiently look up the cumulative frequency up to some value `j` where `j <= max(ratings)`. If we want the number of elements in `ratings[:i]` that are strictly less than `ratings[i]` we can simply look up the cumulative frequency up to `ratings[:i] - 1` on `l_tree`. The same can be said for the right side, with the difference being that the lookup should be performed on `r_tree`. To determine the number of elements that are strictly larger than `ratings[i]`, we can simply subtract the number of elements that are less than or equal to `ratings[i]` from the number of total elements on that side of `ratings`. Two utility functions `update(tree, idx, val)` and `prefix_sum(tree, idx)` will be implemented. `update(tree, idx, val)` will increment the frequency count of value `idx` in the tree `tree` by `val`, and `prefix_sum(tree, idx)` will return the cumulative frequency of all elements in `tree` less than or equal to `idx`. One tree is used for either side, with `l_tree` containing the frequencies for the left side and `r_tree` for the right. `r_tree` is first initialized with the contents of `ratings`, as we will iterate over `ratings` left to right. For each element `ratings[i]`, we first exclude that value from `r_tree`. The desired cumulative frequencies are then retrieved as described earlier, after which the number of valid selections with `ratings[i]` as the middle value is computed and added on to the sum as we did in the previous solution. Once the iteration completes, `ret` will contain the desired value.  
  
#### Conclusion
The time complexity of this solution is $O(n\log m)$, where $m$ is the largest value in `ratings`(`max(ratings)`). The space complexity is $O(m)$, due to `l_tree` and `r_tree`.  