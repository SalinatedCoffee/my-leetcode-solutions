## 2192. (M) All Ancestors of a Node in a Directed Acyclic Graph

### `solution.py`
Given a directed acyclic graph with `n` nodes and `edges` edges, we are asked to return a 2D list where the `i`th element contains the list of the ancestors of `i` in ascending order. Node `j` is an ancestor of node `i` if node `i` can be reached from node `j`. In other words, if we reverse all edges of the given graph, all nodes reachable from node `i` are the ancestors of `i`.  
`edges` is first converted into an adjacency list while reversing the edges. Then for all nodes from `0` to `n-1`, we perform a DFS traversal starting from each node. Naively traversing the entire graph for all nodes will take too long however, but we can reduce the running time by reusing the ancestor list of any encountered nodes. If during a traversal starting at node `i` we encounter a node `j`, we can say that the ancestors of node `j` are *also* the ancestors of node `i`. Hence, if we already know the ancestors for node `j`, we can simply use that information instead of traversing node `j` another time. Once the DFS traversal completes we remove the current node from the visited set, after which we convert it into a list, sort its contents, and add it to the return list `ret`.  

#### Conclusion
This solution has a time complexity of $O(n^2+n^2\log n+m)$, where $n$ is `n` and $m$ is the length of `edges`. Reversing all edges takes $O(m)$ time. Then a single DFS traversal is performed for each node, which takes $O(n)$ time. Once the DFS completes, sorting the list of ancestors will require $O(n\log n)$ time. Since the computation for a single node takes $O(n+n\log n)$ time, processing all `n` nodes will take $O(n(n+n\log n)) = O(n^2+n^2\log n)$ time overall. The space complexity is $O(n+m)$.  
A more optimal solution that eliminates the transpose step would involve approaching the problem in the opposite direction; that is, if node `i` is reachable from node `j`, `j` is an ancestor of node `i`. This has the added benefit of eliminating the sorting step for each node as well, as processing the nodes in ascending order will guarantee that the list of ancestors for each node will also be in ascending order.  

