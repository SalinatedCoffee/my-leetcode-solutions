## 1420. (H) Build Array Where You Can Find The Maximum Exactly K Comparisons

### `solution.py`
Rephrasing the problem, we want to find the number of possible arrays with length `n`, containing values in the range `[1, m]`, and where exactly `k` new maximum values will be found when iterating from left to right.  
Say we already know this value for an array of length `i`. We now naturally want to compute the value for arrays with length `i+1`, but how can we do this? When appending a value to an array, it can be one of two cases. Either the added number is a new maximum, or it is not. In order to determine which we need the maximum value of the array being appended to, which we will represent as `mx`. Using `mx`, we can also determine the number of possible choices that fall under each case. For the former, the appended value can be in the range `[1, mx]`, from which there are `mx` possible choices that can be made. For the latter, the range is `[mx+1, m]` - but for this case we need to compute the value for each possible maximum separately. The final piece of the puzzle is determining the number of comparisions. If there are `r` remaining comparisions that can be made, this value will change based on the value being appended to the end of the current array. If it is not a new maximum, the new array of length `i+1` will still have `r` comparisions remaining. Otherwise, the array will now have `r-1` comparisions. The base cases are when `i == n` or `r < 0`. `i == n` means that we have reached the desired length of the array. If `r == 0` it means that we also have no comparisions remaining, and the current array is valid; and so we return `1`. Otherwise, we return `0`. When `r < 0`, it means we have exceeded the number of comparisions and thus there is no point in appending values to the current array any further. We return `0`.  
Summarizing, we define a recursive function `recurse(i, mx, r)` that returns the number of valid arrays where `i` elements have been considered, has `mx` as their maximum value, and `r` comparisions remain. If `i == n`, we return `1` if `r == 0` or `0` otherwise. If `r < 0`, we return `0`. We then consider the case where the newly added value is not a new maximum by computing `mx * recurse(i+1, mx, r)`. Then we also consider the other case by summing the values of `recurse(i+1, n_mx, r-1)`, where `n_mx` is in the range `[mx+1, m]`. Finally, we sum the two values together and return the value modulo `10**9 + 7`.  

#### Conclusion
This solution has a time complexity of $O(nm^2k)$, where $n$ is `n`, $m$ is `m`, and $k$ is `k`. There are $O(nmk)$ possible states of our recursive function, and each state takes $O(m)$ time to compute since we have to refer to different states for each new maximum value. The space complexity os $O(nmk)$.  
  

