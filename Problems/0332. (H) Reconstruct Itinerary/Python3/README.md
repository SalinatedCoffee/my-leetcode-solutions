## 332. (H) Reconstruct Itinerary

### `solution.py`
Given a list of tickets, we want to find an itinerary that uses every ticket exactly once, and is lexicographically the smallest among all other possible itineraries. We can achieve this by simply traversing the graph represented by `tickets`. If we perform a DFS traversal while exploring neighbors in lexicographical order, we can immediately return whenever we can verify that all edges have been traversed.  
First we must convert `tickets` into a form where we can easily access a node's (airport) outgoing edges (tickets). Since the node labels are given to us as a string we can use a dictionary for the adjacency list where `adj[i]` will give us the list of destinations from airport `i`. While the problem does not explicitly state this, there may be multiple tickets with the same origin and destination. That is, `tickets = [["JFK","SFO"], ["SFO","JFK"], ["JFK","SFO"]]` is valid and the itinerary would be `["JFK", "SFO", "JFK"]`. Thus we must make each ticket unique by adding an arbitrary label. Here we simply number the edges based on the order they were processed, so that some ticket `j` in `adj[i]` is represented by a tuple where `j[0]` is the destination airport and `j[1]` is the ticket's unique label. Since we want the lexicographically smallest possible itinerary, we also want to traverse neighbors in lexicographical order. By pre-sorting the adjacency list we can naturally do so by simply exploring neighbors in the order they appear.  
Because a valid itinerary is guaranteed to exist, we know that we need to back out of an edge if there are no untraversed edges at a node. In this case we 'untake' the previously taken edge by popping it off from the DFS stack and try exploring the next neighbor. When the number of traversed edges becomes equal to the number of tickets, we can immediately return the current itinerary as we have guaranteed that the first valid itinerary will be the lexicographically smallest by pre-sorting the adjacency list.  

#### Conclusion
This solution has a time complexity of $O(|E|\log |E|)$, where $|E|$ is the number of edges, which is the length of `tickets`. We sort the adjacency list before traversal, and the list contains $O(|E|)$ lists where each list holds $O(|E|)$ items. The traversal step takes $O(|V|+|E|)$ as it performs a modified DFS traversal. In this case, $|V|$ is bound by $|E|$ and so the time complexity becomes $O(|E|+|E|) = O(|E|)$, hence the overall running time of $O(|E|\log |E|)$. The space complexity is $O(|E|)$, since `adj` and the recursion stack both use $O(|E|)$ memory.  
  

