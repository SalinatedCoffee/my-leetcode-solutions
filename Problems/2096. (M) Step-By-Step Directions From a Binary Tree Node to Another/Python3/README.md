## 2096. (M) Step-By-Step Directions From a Binary Tree Node to Another

### `solution.py`
Given the root of a binary tree and the integers `startValue` and `destValue`, we are asked to return the string representation of the shortest path between the nodes that have `startValue` and `destValue` as their value. The string representation of a path consists of the 3 characters `U`, `L`, and `R`. A `U` represents moving from a node to its parent, and an `L` or an `R` represents moving from a node to its left or right child, respectively. As the tree is linked in such a way that makes moving from a node to its parent non-trivial, we cannot run a simple BFS from `startValue` to find the shortest distance between it and `destValue`. Instead we can run a single DFS starting at the root, while keeping track of the nodes in the path between the root and the current node. Whenever a target node is encountered, this list is copied and stored separately for future reference. Once the DFS completes, we will have 2 ordered lists of nodes in the path between `root` and the `startValue` and `destValue` nodes. However, the shortest path between the two target nodes may not necessarily go through the root. We can determine the actual shortest path by using these paths by exploiting the fact that a path between any two nodes in the path is the shortest path between those two nodes. Because the given binary tree is valid, the two target nodes must be reachable from each other. Hence the paths from the node to each of the target nodes must also partially share the same path. If we truncate the identical sections between them, we will end up with two sections representing the path between `startValue` and some node `i`, and the path between node `i` and `destValue`. If these paths are concatenated at node `i`, the end result will be the shortest path between the two target nodes. Now that we know how to find the shortest path between `startValue` and `destValue`, the problem becomes devising a method to encode these paths into their correct string representation. The path from `startValue` to node `i` is trivial, since we can only move from a node to its parent. The other path is slightly more involved, since we are moving from a node to its child. Instead of traversing the tree again, we can use some extra memory during the DFS step to keep track of how each node was reached. A node in a path is represented by a tuple, with one element being the node's value and the other representing whether the node is a left or right child of its parent. After the truncation step, we will now have a ordered list of symbols that we can directly concatenate instead of traversing the path one more time.  

#### Conclusion
This solution has a time complexity of $O(n)$ where $n$ is the number of nodes in the tree rooted at `root`. A single DFS traversal is performed on the tree, which takes $O(n)$ time to complete. Each node takes $O(1)$ time to process, and copying the current path is performed twice with each copy taking $O(n)$ time to complete. The final step of encoding these paths into strings also takes $O(n)$ time to finish, which brings the overall time complexity of the solution to $O(n)$. The space complexity is also $O(n)$, due to the lists `self.path`, `self.start`, `self.dest`, and the recursion stack.  
  

