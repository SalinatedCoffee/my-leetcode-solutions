## 650. (M) 2 Keys Keyboard

### `solution.py`
Starting with a string comprising of a single letter, we are allowed to either copy the entire string or paste whatever we had last copied and append it to the end of the string. With either one of the operations costing 1 step to perform, we are asked to determine and return the minimum number of steps required to make the string be exactly `n` long. Looking at the constraints on `n`, we know that we could use recursion to solve the problem using backtracking. At any point in time we have 2 choices to choose from. We can either copy the current string, or paste from the clipboard. When making these choices there are 2 values that we must keep track of, which are the length of the current string and the length of the string in the clipboard. We of course also need to keep track of the current number of steps performed, as well as the current smallest number of steps taken to make the string be `n` long. Whenever the length of the current string is `n` long, we update the overall smallest number of steps accordingly before exiting out of the recursion. If the sum of the length of the current string and that in the clipboard exceeds `n`, we immediately return.  
The function `recurse` takes 2 arguments `s` and `c`, where `s` represents the length of the current string and `c` the length of the string currently in the clipboard. After checking for the base cases `s == n` and `s + c > n`, we increment the number of steps `self.steps` by `1` before recursing on each of the possible choices. Once the recursive calls exit, we also have to remember to revert the number of steps back to its previous value before exiting.  

#### Conclusion
The time complexity of this solution is $O(2^n)$, where $n$ is `n`. While `recurse(s, c)` has 2 parameters both bound by $n$, all 2 choices are always evaluated for each possible value of `s` leading to an overall time complexity of $O(2^n)$. The space complexity is $O(n)$, due to the recursion stack.  
  


### `solution_2.py`
If we think about the problem some more, there are a few things that become apparent. For starters, we know that any series of steps to make the string `n` long will take on the form of `CPPPP...`, where `C` represents a copy and `P` represents a paste. As a matter of fact, the series can be comprised of multiple 'sections' with the form `[CP...]`. The length of each section is the number of steps taken to transform a string to whatever it becomes after the operations are performed. Can we determine what the relationship between the string before and after the operations actually is? The first section is relatively simple since we start with a string with length `1`. After the first copy, we have a string of length `1` in our clipboard. Thus, after performing `i-1` pastes we will have a string of length `i`. This section will have 1 `C` and `i-1` `P`s, taking `i` steps to change the string from being `1` long to `i` long. The second section will now start with a string of length `i`. Copying this string puts the clipboard at a length of `i`, making subsequent pastes increase the length by `i`. If `j` steps are taken in this section, the string length after the section will be `i*j`, and so on for any subsequent sections. Using this property, if we let $s_i$ represent the number of steps for section $i$, we can see that the product of all $s_i$ should equal `n`, and the sum of all $s_i$ will be the total number of steps required. Approaching the problem like this, the problem now becomes reducing the length of each section as much as possible. Say we have a section that looks like `CPPPPP`, starting with a string of length `1`. After these operations we will end up with a string of length `6`, taking 6 steps in the process. Upon further investigation we can see that this section can be broken up into two sections `CP` and `CPP`, where the first section yields a string of length `2`, and the second a string of length `6` using 1 less step than before. At this point we realize that this is simply the prime factorization of `6` - turning the problem into finding the prime factorization of `n`.  
The prime factors of `n` can be determined incrementally by starting with the smallest prime number `2`. If `n` is divisible by the current value, the current value is a factor of `n`, and is added to the total number of steps `ret`. The quotient resulting from dividing `n` by the factor is assigned back to `n`, and these steps are repeated until the current value is not divisible by the current factor. The factor is then incremented by `1` to search for the next prime factor of `n`. This algorithm is vaguely related to the [Sieve of Erathosthenes](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes) in that we are searching for prime factors starting with the smallest values, which are repeatedly factored out of the value. Once we divide `n` by a prime factor until it becomes indivisible, the resulting quotient cannot be divided by the factor again, as well as any values that include that factor as one of its own factors. For example, if `n = 24` and the factor is `2`, we will end up with a quotient of `3`(dividing by `2` 3 times), which is not divisible by `2` or any other value that has `2` as a prime factor. Once `n` becomes `1`(which is guaranteed to happen as we start with a string of length `1`), we exit the loop, returning the total number of steps performed.  

#### Conclusion
This solution has a time complexity of $O(n)$. The algorithm terminates whenever `n` becomes `1`, and since `n` is reduced by dividing it by its prime factors, the worst case will be when `n` is a prime number itself. In this case the loop will repeat $n$ times, bringing the overall time complexity to $O(n)$. The space complexity is $O(1)$.  
  

