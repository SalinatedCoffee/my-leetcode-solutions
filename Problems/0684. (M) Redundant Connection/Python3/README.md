## 684. (M) Redundant Connection

### `solution.py`
The list of edges `edges` represents an undirected graph that started as a tree with `len(edges)` nodes labeled from `1` to `len(edges)`, with 1 additional edge added. If all edges in `edges` are unique, we are asked to return the edge that can be removed from the graph in order to make the graph a proper 'tree-like'(acyclic) graph. If there are multiple such edges, we should return the edge that appears last in `edges`.  
We know that a tree containing `n` nodes can contain up to `n-1` edges. Adding another edge to a tree already containing `n-1` edges would result in a cycle. This means that we can simply detect a cycle in the given graph, find the edge that appears last in `edges`, and return it. We can also see that the tree is a single connected component, and adding another edge to it would mean that the edge would connect the component to itself. At this point we realize that we can use the union-find data structure to solve this problem, as we are working with connected components. The premise is simple - if we were to incrementally build the graph by adding in each edge in `edges`, an edge can either connect two components, or connect one component to itself. Obviously, an edge that connects a connected component to itself will be part of a cycle within that component - and since it is guaranteed that only 1 cycle will exist in the given graph, it is also guaranteed that removing that edge will make the graph acyclic.  
The setup is typical of a union-find based solution. `ufind(a)` will return the label of the set containing `a`, and `uunion(a, b)` will merge the set containing `a` with the one containing `b`. `p` will keep track of which set each node belongs to. Iterating over `edges`, we retrieve the sets containing each node on either end of each edge. If the two sets are identical we know that adding in that edge will create a cycle in the graph; and since that edge is the last added edge among the edges that form the cycle, it is also the last edge that appears in `edges`(assuming `edges` is iterated over from left to right). Thus, we can return early by returning the current edge.  

#### Conclusion
This solution has a time complexity of $O(n)$, where $n$ is the length of `edges`. There are `len(edges)` in the given graph, which means initializing `p` is a $O(n)$ time operation. The entirety of `edges` is iterated over, and `ufind` is called twice for a single edge. Because `ufind` interacts with a union-find data structure that contains $n$ nodes, the time complexity of a single `ufind` operation is $O(\alpha(n)) \approx O(1)$, bringing the overall time complexity to $O(n)$. The space complexity is also $O(n)$, due to `p`.  
  

