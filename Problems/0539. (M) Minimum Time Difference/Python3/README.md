## 539. (M) Minimum Time Difference

### `solution.py`
`timePoints` is a list containing strings which represent a point in time. A timestamp is a 5-character long string with the format `HH:MM`. Given `timePoints`, we are asked to return the smallest time difference between any two timestamps in minutes. The brute force approach of examining all possible pairs of timestamps is not optimal, and we can obviously do better. If we sort `timePoints` in ascending order we can guarantee that the difference between `timePoints[i]` and `timePoints[i+1]` is less than or equal to that of `timePoints[i]` and `timePoints[i+2]`, allowing us to examine only the adjacent time stamp pairs. One thing to remember is that timestamps 'wrap around'; that is, adding 1 minute to `"23:59"` results in the timestamp of `"00:00"`. We need to manually take care of this case by computing the minute difference between the first and last items of the sorted `timePoints`. This can be achieved by adding the first timestamp to the difference between 24 hours and the last timestamp.  
`timePoints` is first sorted in ascending order, which can be done without supplying a custom value generator. All timestamps are then converted into their corresponding number of minutes to make them easier to work with, after which we iterate over `timePoints` while comparing each adjacent pair of values. After examining the last pair of timestamps with the expression `24*60 - timePoints[-1] + timePoints[0]`, the smallest time difference will be stored in `res`.  

#### Conclusion
This solution has a time complexity of $O(n\log n)$, where $n$ is the length of `timePoints`. `timePoints` is sorted before it is examined, which requires $O(n\log n)$ time using Python's built in sorting module. The `map` invocation and the iteration step that follows each take $O(n)$ time to run, bringing the overall time complexity to $O(n\log n)$. The space complexity is $O(n)$, due to the sorting step.  
A linear time solution is also possible by using bucket sort, since there are only 1440 unique timestamps that can exist. `timePoints` would be iterated over once, maintaining the number of previously seen timestamps in 1440 buckets. If a timestamp has already been seen, we can immediately return `0`. Otherwise, the buckets are scanned to determine the nearest timestamp. One thing worth mentioning in an interview setting would be how asymptotic analysis works, and how this solution would be faster because it will realistically only ever examine at most 1440 timestamps before it exits.  

