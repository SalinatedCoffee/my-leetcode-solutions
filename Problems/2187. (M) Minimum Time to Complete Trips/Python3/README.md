## 2187. (M) Minimum Time to Complete Trips

### `solution.py`
Before deciding on what approach to take for this problem, let's first go over the problem description. The buses can run in parallel, and can make consecutive trips without any downtime. We are asked to find the *minimum* amount of time it would take for the buses to make `totalTrips` trips, so the optimal behavior would be to make as much trips as possible for a given amount of time. Using this strategy we can compute the maximum number of possible trips for any amount of time. We simply iterate over `time` and compute the sum of `some_time // time[i]`.  
Now we need to figure out a way to actually determine the desired amount of time. A brute force approach would obviously not be optimal, but for now let's assume that that's what we are going for. The minimum time is 1 given the problem constraints, so we can incrementally start searching from 1. Having the range of a signed 4-byte integer as a search space seems like a bad idea though (not to mention that a Python integer doesn't even have a maximum value at all) - does a maximum time exist? You may be tempted to go for `max(time) * totalTrips` as that is the obvious maximum value, but we can further optimize the search space by noticing that `min(time) * totalTrips` can also be a valid maximum. This has to do with the fact that we are searching for the minimum amount of time given `totalTrips`. As an example (since I'm terrible with words), assume `time == [1, 10]` and `totalTrips == 3`. `max(time) * totalTrips == 30`, but the number of possible trips exceeds `totalTrips` since the first bus can make 30 trips and the second could make 3. `min(time) * totalTrips == 3` however is more optimal as it is a tighter bound over the search space.  
At this point it becomes obvious that we can perform a binary search since we have a linear search space that is bounded. We just need to be careful not to immediately return once we have a solution as we want the minimum amount of time (for example, 2 trips taking 3 hours each can be done in 8 hours, but the minimum is 6).  
  
#### Conclusion
This solution has a time complexity of $O(n\log m)$ where $n$ is the length of `time` and $m$ is `totalTrips` (pseudo-polynomial, but also technically $O(n)$ if `totalTrips` is of a data type with a maximum value). The search space $m$ is halved for each iteration and during a single iteration we iterate over the entirety of `time`. The space complexity is $O(1)$.  
  

