## 149. (H) Max Points on a Line

### `solution.py`
For two points to be on the same line, they must have the same slope and intercepts. A brute force approach would involve computing the slope and intercepts for a pair of points, iterating through all other points while checking if they are on that same line, and then repeating the two steps for all possible pairs of points. This however has two glaring issues: it's slow, and involves dealing with floating point math which computers are infamously known to be horrible at. First, we can reduce the running time by using a dictionary to keep track of the number of points. By using the slope and intercept as the key we can count the number of colinear points while computing the slope and intercepts. Restructuring the loops in this way also introduces a side-effect that benefits the second issue. The point from the outer loop is essentially treated as the origin, which implicitly 'translates' all other points. This eliminates the need for intercepts altogether, and because all coordinates are guaranteed to be integers the slopes can also be represented by integers(`(denominator, numerator)`) even after the divide-by-GCD step during computation.  
  
#### Conclusion
As the solution examines all possible pairs of points it will run in $O(n^2)$ time, which is an order of magnitude better than the brute force solution which would have taken $O(n^3)$ to run. In terms of space complexity, we reset a dictionary for every iteration of the outer loop. The worst case scenario in a single iteration is where no two points are on the same line; that is, each point has a unique slope. Thus, this solution uses $O(n)$ space.  
The math is trivial, and given the input constraints I'd daresay coming up with an algorithm is trivial as well(honestly though, I'm personally not the biggest fan of problems that involve math). Hazarding a guess, this problem was labeled as hard because solutions can potentially include floating point arithmetic.  
Another interesting tidbit is that Python 3's `math.gcd()` internally uses the [Euclidean algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm), which takes $O(\log(min(a, b)))$ time(which is simple enough to trivially implement if needed). There are faster methods when $a$ and $b$ are large, but the numbers would have to be *absolutely stratospheric* for this to be true - at which point you'd be looking at specialized hardware to even manipulate them.
