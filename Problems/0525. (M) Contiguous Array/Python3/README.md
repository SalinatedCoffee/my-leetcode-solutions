## 525. (M) Contiguous Array

### `solution.py`
The problem is almost instantly recognizable as either a prefix sum or sliding window problem. As there seems to be no clear criteria that we can use to resize a window, our next course of action is to try taking the prefix sum based approach. A naive algorithm that checks all possible subarrays would of course take quadratic time to complete. The problem with this approach is that for each element in `nums`, we would have to check all subarrays ending in (or starting with) that element. There are $O(n)$ such subarrays for each element, which is why this approach requires quadratic time to run. Can we somehow devise a way to reduce the checking step to $O(1)$ instead? Returning to the problem description, we are asked to return the length of the longest subarray that contains the same number of `0`s and `1`s each. That is, a valid array would only be comprised of some number of *pairs* of `0` and `1`. If we decrement by `1` for each `0` we encounter while computing the prefix sum, the prefix sum will *stay the same* after computing the prefix sum over a valid subarray. We can exploit this fact to trivially find the longest valid subarray ending at each element(if it exists).  
The previously discovered prefix sums will be stored in the dictionary `sums`, where `sums[i]` is the **earliest** index of an endpoint of a prefix array that sums up to `i`. We first check whether the current prefix sum is in the dictionary. If it is, then we have covered a valid array, and we update the longest length if applicable. Otherwise, this is the first time the current sum has been discovered, which also means that the current index is the earliest index at which the sum can occur. We add the appropriate key-value pair in `sums`. Once we finish iterating over `nums`, we do one last check against `sums` to account for the case where the longest subarray includes the very last element in `nums`; before finally returning the length of the longest valid array, which is stored in `ret`.  

#### Conclusion
This solution has a time and space complexity of $O(n)$, where $n$ is the length of `nums`. `nums` is iterated over exactly once, where each element takes constant time to process. The dictionary `sums` can at most contain $n$ number of key-value pairs(when `nums` contains either only `0`s or `1`s), hence the linear space complexity.  
  

