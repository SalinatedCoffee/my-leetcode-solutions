## 1482. (M) Minimum Number of Days to Make m Bouquets

### `solution.py`
Given a list of integers `bloomDay`, we are asked to determine the minimum number of days required to make `m` number of bouquets using `k` adjacent flowers for each one. `bloomDay` represents the date a flower in the garden will bloom. That is, the value of `bloomDay[i]` will be the number of days required for the `i`th flower to bloom. Verifying whether all bouquets can be made after waiting some number of days can be done in linear time with respect to the length of `bloomDay`. If we have waited `j` days, we simply iterate over `bloomDay` while keeping track of the number of consecutive flowers that have a bloom date of less than or equal to `j`. If a 'streak' is broken, we update the number of bouquets formed by dividing the length of the streak by `k` and adding it to the bouquet count. The problem is that there is no heuristic by which we can reliably guess the number of days required to make all `m` bouquets. Brute forcing this by verifying `bloomDay` against all possible days(which would be in the interval `[1, max(bloomDay)]`) would work, but we can do better. If we think about it, if all bouquets can be made after waiting `j` days, we can also say the same for `j+1` days. That is, if we lay each day on a number line, `j` being valid means that all days in the interval `[j, max(bloomDay)]` are also valid. This means that we can use binary search to determine the minimum number of days we have to wait, optimizing the search step down to logarithmic time instead of linear.  
We first check whether there are enough flowers to potentially make all `m` bouquets. If not, we immediately return `-1`. Otherwise, we prepare for the binary search step by initializing the search space, which is the interval `[1, max(bloomDay)]`. The actual binary search implementation is very standard, which involves determining the midpoint of the current search interval and verifying that midpoint in order to determine which half to continue searching. As briefly mentioned earlier, `bloomDay` is traversed to verify the midpoint. If it is valid we store the midpoint value into a separate variable before discarding the right half, since there may be a value less than it that is also valid. Otherwise, we simply discard the left half and repeat the steps above.  

#### Conclusion
This solution has a time complexity of $O(n\log m)$ where $n$ is the length of `bloomDay` and $m$ is the largest value in `bloomDay`. Because the initial search space is `[1, max(bloomDay)]`, `log(max(bloomDay))` halvings will occur until the interval is exhausted. For each halving, we determine whether the midpoint is valid. This step involves interating over `bloomDay`, which takes $O(n)$ time to complete. Thus the overall time complexity for this solution becomes $O(n\log m)$. The space complexity is $O(1)$.  
  

