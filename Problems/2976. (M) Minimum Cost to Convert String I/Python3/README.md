## 2976. (M) Minimum Cost to Convert String I

### `solution.py`
We want to convert the string `source` to `target`, where all possible conversions are described in `original`, `changed`, and `cost`. The letter `original[i]` can be converted to `changed[i]`, incurring a cost of `cost[i]`. Say we want to change some letter `i` to `j`. It may be the case that the conversion can be achieved in a single operation; that is, `original[k] == i` and `changed[k] == j` for some index `k`. In this case, the conversion would cost `cost[k]` to perform. However it may also be the case that the conversion can be achieved through multiple operations, in which case the total cost would simply be the sum of the costs of all intermediate operations. There may be of course multiple sets of operations that can convert `i` to `j`, with each set having different total costs. Among all of these choices we need to choose the one that would cost us the least, which we realize can be achieved by modeling the conversions as a graph. The graph will have the lowercase English letters as the nodes, and single operations as weighted directed edges(`original[i]` would be the source node, `changed[i]` the destination node, and `cost[i]` the weight). Now the minimum conversion cost between two letters is simply the sum of all weights of the edges in the shortest path between the two nodes. Because we want to be able to determine the minimum conversion cost for all pairs of letters, we should be implementing a Floyd-Warshall based solution to achieve this.  
The complete solution will be comprised of 3 steps. It will first initialize the distance matrix using the elements of `original`, `changed`, and `cost`. The edge relaxation will then be run on the initialized distance matrix, after which the actual cost computation will be performed. `costs` will be a 26 by 26 2D list with all of its elements initialized as infinity. `original`, `changed`, and `cost`(with iteration variables `u`, `v`, and `w`) will then be traversed simultaneously while updating the contents of `costs`. `w` will be assigned to `costs[u][v]` only if it is less than the previous value of `costs[u][v]`(this check is necessary since there may be multiple edges between two nodes). The edges in the graph are then relaxed, populating `costs` with the minimum costs. Finally, `source` and `target` are iterated simultaneously as well, with the conversion cost of each letter pair being added into the sum `ret`. If a letter pair has a conversion cost of infinity that letter from `source` cannot be converted to its counterpart in `target`, rendering the entire conversion impossible. In this case, we simply return `-1` immediately as described by the problem. If the iteration exits normally, the value of `ret` will be the desired value.  

#### Conclusion
The time complexity of this solution is $O(m+k^3+n)$, where $k$ is the size of the alphabet of the strings `source` and `target`, $m$ the length of `original`(number of edges in the graph), and $n$ the length of `source`. All edges are examined in order to initialize the distance matrix `costs`, with each edge taking $O(1)$ time to process. The edge relaxation step takes $O(k^3)$, with the final cost computation requiring $O(n)$ time to complete. One could argue that there are a fixed number of lowercase English letters, and thus `k` should be considered constant. In that case, the overall time complexity becomes $O(m+n)$. The space complexity is $O(k^2)$, or $O(1)$ if `k` is considered constant.  
  

