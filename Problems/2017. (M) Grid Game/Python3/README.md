## 2017. (M) Grid Game

### `solution.py`
2 robots traverse a `2*n` grid, starting at the square at `(0, 0)` moving towards the one at `(1, n-1)`. Both robots can only move towards the right or downwards. Each cell on the grid is assigned a positive score, which is awarded to the first robot that moves over the cell. The robots take turns moving over the grid; that is, the second robot must wait until the first robot reaches its destination before it can start moving. The goal of the robots is to maximize their total score. This means that the first robot would want to **deny** the second robot from as many points as possible, and the second robot would want to **score** as many points as possible. Given the 2D list of integers `grid` representing the grid, we are asked to return the total score of the second robot assuming that both robots play optimally.  
Because of the shape of `grid` and restrictions on the movement on the robots, it is not that difficult to realize that either robot will move downwards *exactly once* during their traversal over `grid`. We can also easily compute the score of the first robot given the index at which it moves downwards on the grid. If this index is `i`, the score is simply `sum(grid[0][:i+1]) + sum(grid[1][i:])`. Using the same thought process for the second robot, we know that there are 2 cases that can be considered regarding its path along `grid`. It can either move downwards before `i`, or it can move after `i`(moving downwards *at* `i` would result in a score of `0`, but we want to maximize the score of the second robot). Say the second robot moves downwards at index `j`. If `j < i`, the score of the second robot would be `sum(grid[1][j:i])`. This is because the cells in `grid[0][:i+1]` and `grid[1][i:]` all have a score of `0` since the first robot has already visited them. Similarly, the score of the second robot is `sum(grid[0][i+1:j+1])` if `j > i`. Looking at the cells contributing to the second robot's score, we notice that it would be optimal to make `j` `0` when `j < i`, and `j` `n-1` when `j > i` since all scores in `grid` are positive. Thus, we can definitively say that the second robot has exactly 2 choices to consider when trying to move downwards - it can either move at index `0` or `n-1`.  
Using this property, we can see that we only need to focus on the path of the first robot since the second robot only has 2 possible paths. By maintaining the suffix sum of the `0`th row and the prefix sum of the `1`th row while iterating over the columns of `grid`, we can instantly compute the projected score of the second robot, among which we select the largest value.  

#### Conclusion
This solution has a time complexity of $O(n)$, where $n$ is the number of columns in `grid`. Initializing the suffix sum of the first row of `grid` finishes in $O(n)$ time. Computing the score of the second robot given the sum of `grid[1][:i+1]` and `grid[0][i:]` is a constant time operation which occurs $n$ times, bringing the overall time complexity of this solution to $O(n)$. The space complexity is $O(1)$.  
  

