## 885. (M) Spiral Matrix II

### `solution.py`
Given the coordinates of the starting position (`rStart`, `cStart`) on a 2D matrix with `rows` rows and `cols` columns, we are asked to return the list of coordinates of each cell in the matrix in order in which they were visited. The matrix is traversed in a spiral, first moving towards the right by 1, then down by 1, left by 2, up by 2, right by 3... until all cells have been traversed. Whenever we exit the boundaries of the matrix, the traversal should continue until it is entered again. The most straightforward method of solving this problem would be to simply simulate the spiraling motion, adding a coordinate if it is within bounds and returning once we have the desired number of coordinates.  
Further investigating this spiraling motion, we see that the direction alternates between right, down, left, and up, after which it wraps around to right and continues indefinitely. The distance in which we should move before changing direction starts at 1, and increases by 1 whenever the direction is changed twice. Finally, a direction change occurs whenever we have moved the required distance in the current direction.  
The 4 directions will be represented by the list of unit vectors `VEC = [(0, 1), (1, 0), (0, -1), (-1, 0)]`. `v` will be the index of the current direction, which can be advanced to the next direction by setting it to `(v+1) % len(VEC)`. `reach` will be the distance required to move before changing direction, and is initialized as `1`. After initializing the initial coordinate as `y, x = rStart, cStart` and distance as `d = 0`, we can start simulating the traversal. We first check whether the current position is within the matrix bounds. If it is, we add the coordinate to the list `ret`. Next, we determine whether all squares have been traverse by looking at the length of `ret`. If they have, we can return immediately. The next cell is then traversed to, updating the coordinates and distance accordingly. We then change the direction and `reach` as necessary, before moving onto processing the current cell.  

#### Conclusion
This solution has a time complexity of $O(\max(m, n)^2)$, where $m$ and $n$ are `rows` and `cols`, respectively. Because we move in a spiraling motion and want to visit all cells in the $m\times n$ matrix, the width of the simulated square being traversed will be $2\cdot\max(m, n)$. And since all cells are traversed regardless of whether they are inside the bounds of the matrix, the time it takes to complete the simulation becomes $O(\max(m, n)^2)$. The space complexity is $O(1)$ not counting `ret`, since `VEC` and all other variables have a fixed size regardless of the size of the input.  
  

