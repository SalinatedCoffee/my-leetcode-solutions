## 773. (H) Sliding Puzzle

### `solution.py`
A game is played on a 2 by 3 board, which contains numbers from 1 to 5 and an empty cell represented by a `0`. In each turn, the empty cell can be swapped with any of its neighbors in the cardinal directions. The goal of the game is to arrange the contents of the board to match that of `[[1, 2, 3], [4, 5, 0]]`. When the initial configuration of the board is given to us as the 2D list `board`, we are asked to return the minimum number of turns required to solve the puzzle. If it is impossible to do so, we should return `-1`.  
At first glance, it may seem that there may be some optimal way that we can follow when searching for a solution. Looking at the problem description however, we realize that we can take a brute force based approach as the problem space is relatively small. If we think of the problem as a graph, with a node representing some specific configuration of the board and edges as transitions between configurations, we can see that the problem can be solved by running BFS on this graph.  
As each node represents a specific configuration of the board, we want to represent a game state using something easier to use than a 2D list. Since the board size is fixed, we can simply use a string of length 6 to represent the board, with the first 3 characters representing the first row and the next 3, the second row. Since converting the 2D list representation of a game state to a string requires multiple lines of code to implement, we will wrap this code in a separate helper function. We can also see that the set of neighbors for each possible position of the empty cell is fixed, and can be predetermined beforehand. After initializing the empty set of visited nodes and queue with the root(the state of `board`), we can start running BFS. For each state, we iterate over the list of possible moves given the current state, adding the new state to the queue if it has not been seen before. If the state equals that of the goal at any point during the traversal, we immediately return the depth of the current node. Otherwise, the puzzle is impossible to solve with the initial state of `board`, and we return `-1`.  

#### Conclusion
This solution has a time complexity of $O((mn)!mn)$, where $m$ and $n$ are the dimensions of the game board. Each cell on the board can be one of 6 possible states, and because there are 6 cells in total, there are $(mn)!$ possible states. Evaluating each state involves iterating over the string representation of that state, which takes $O(mn)$ time. As the BFS traversal exhaustively explores all possible game states, the overall time complexity of this solution is $O((mn)!mn)$. The space complexity is $O((mn)!)$, due to the set `visited` and queue of future nodes `nodes`.  
  

