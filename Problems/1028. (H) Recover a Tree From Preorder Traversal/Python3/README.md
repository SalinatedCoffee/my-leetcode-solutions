## 1028. (H) Recover a Tree From Preorder Traversal

### `solution.py`
Given a string generated by performing a preorder (NLR) traversal on a binary tree, we are asked to reconstruct the tree. In the string, a series of dashes(`-`) precedes a node value, representing the depth of that node by the number of dashes. For example, the string `'---12'` would represent a node with value 12 at a depth of 3. The root node has a depth of 0. Because a non-existent node is implied in the string representation, a node reconstructed from a string can never only have a right child. For example, if in the original tree the root `1` has a right child `2`, encoding the tree would result in the string `1-2`. When reconstructing a tree from this string, we would get a tree where the root has a value of `1` but has node `2` as its *left* child. Keeping this quirk in mind, devising a reconstruction algorithm is surprisingly easy. Because the string is generated by performing a preorder traversal on a tree, the first node in the string will always be the root of the subtree represented by the remaining substring. We can then recursively apply the same notion to the remaining portion of `traversal` until either the end of the string is reached or we encounter a node that does not belong at the current depth. Determining whether a node should be at the current depth is rather straightforward; we simply check whether the node's depth is exactly `1` larger than its parent's.  
Before doing anything else, we preprocess `traversal` into a form that makes it easier to work with. `depths` contains the depth of each node, and `values` contains the value. Because the root node does not have a depth, `values` will be 1 element longer than `depths` and as a result. After creating the root node and initializing a pointer `self.idx` that points to the first node yet to be decoded, we can start defining our reconstruct function `recurse`. `recurse` will take 2 arguments `p` and `d`, where `p` is the reference to the parent node and `d` is the depth of `p`. If the depth of the current node is greater by `d` by `1`, we instanstate a `TreeNode` and link it to `p`. After incrementing `self.idx` by `1`, we recurse down on the remaining unprocessed nodes using the node that we just created as the parent node. We do the same for the right child.  

#### Conclusion
This solution has a time complexity of $O(n)$ where $n$ is the length of `traversal`. Preprocessing `traversal` using regular expressions takes $O(n)$ time. The reconstruction step also takes $O(n)$ time as it essentially iterates along `depths` and `values`, which are both $O(n)$ long. Since instantiating a `TreeNode` and linking it to its parent takes $O(1)$ time, the overall time complexity is $O(n)$. The space complexity is also $O(n)$ due to `depths`, `values`, and the recursion stack.  
  

