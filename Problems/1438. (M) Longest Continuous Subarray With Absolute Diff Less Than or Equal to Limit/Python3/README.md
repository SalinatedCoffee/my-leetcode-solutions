## 1438. (M) Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit

### `solution.py`
Given a list of positive integers `nums` and an integer `limit`, we are asked to determine the length of the longest subarray of `nums` where the absolute difference between any pair of values in it is less than or equal to `limit`. As is usually the case, the brute force approach will take too long. First off, we can say that we are only concerned with the absolute difference of the largest and smallest values in a subarray as this it is guaranteed that the absolute difference of all other pairs will be less than this value. Hence, if we know that the absolute difference of the largest and smallest value in a subarray is less than or equal to `limit`, we can decidedly say that the subarray is valid. Intuition also tells us that we could take a sliding window based approach, as we want to find the length of the longest **subarray** without resorting to checking all possible ones. With this information, the task now becomes implementing a sliding window algorithm that contracts the window whenever the absolute difference between the largest and smallest values in the window exceeds `limit`. Naively keeping track of the minimum and maximum values is not ideal, as evicting the smallest value from the window will make the second-smallest value the smallest, which requires scanning through the window to find. We want to be able to keep track of the element in the window in ascending order in order to determine what the new minimum(or maximum) is after evicting the current value from the window. We also want to know whether the new minimum is within the window, for obvious reasons. This can be solved by storing the contents of the window in a heap(or priority queue), which naturally maintains its contents in sorted order. Since we can only access one 'side' of a heap, we need to maintain two seperate heaps; one that pops its elements in ascending order and one that does so in descending order. Whenever the window is expanded, the new element is added to both heaps along with its index. If the absolute difference between the top-most elements of each heap is larger than `limit`, than the window is invalid and we need to contract the window. This process is repeated until all elements of `nums` have been examined, by which point we will have the length of the longest valid subarray.  
The window will be incrementally expanded by simply iterating over the elements of `nums`. The integer `l` will be the index of the first element in the current window, and the lists `min_h` and `max_h` will be the min/max heaps containing the elements within(or outside) the current window. Upon iterating over to a new element, it is first added to both heaps alongside its index as previously described. The window is then verified, with the length of the longest subarray `ret` being updated accordingly. Otherwise, the window is shrinked from the left. This is done by simply looking at the top-most elements on both heaps. We choose the element that has the smaller index, pop it off of its heap, and advance the pointer to that index + `1`. After removing invalidated values(values that are now outside the window) from both heaps, the validity of the window is checked again, with these steps being repeated until it becomes valid. Once the iteration completes, `ret` will contain the desired value.  

#### Conclusion
The time complexity of this solution is $O(n\log n)$, where $n$ is the length of `nums`. `nums` is iterated over exactly once, and `l` is bound by $n$. Each element in `nums` will interact with the heaps at most twice, with each insertion/removal taking $O(\log n)$ to complete. Hence, the overall time complexity of this solution is $O(n\log n)$. The space complexity is $O(n)$, due to the two heaps.  
This solution can be optimized even further if monotonic queues are used instead of heaps. Since insert/remove operations on a queue take $O(1)$ time instead of $O(\log n)$, this will bring the overall time complexity down to $O(n)$.  
  

