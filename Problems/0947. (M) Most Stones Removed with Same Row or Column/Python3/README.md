## 947. (M) Most Stones Removed with Same Row or Column

### `solution.py`
Regarding stones on a 2D grid, we can only remove a stone if there is a stone on the grid that shares either the same row or column. Given the list of stone coordinates `stones`, we are asked to return the maximum number of stones that can be removed from the grid.  
At first glance this may seem like a backtracking solution - for each row(or column) we know which columns(or rows) that we can 'access' through each stone on the row. Hence, we know the number of stones that we lose access to be removing a stone and thus we try removing a stone unless it negatively impacts the total number of stones that can be removed. However this approach only considers a single point of access, whereas in reality a column reachable from a row could still be reachable through some other path. As a matter of fact, if we 'cluster' all of the stones that are reachable from one another we can remove all stones save for `1`. Thus, if we can find all clusterings of the stones we can trivially compute the number of stones that can be removed. At this point, we can clearly see that this problem is actually a graph problem. There are many ways that this problem can be solved, but here we will opt for a union-find based algorithm since it is most easy to understand.  
Simply put, we want the total number of connected components in the graph where each stone is represented by a single node. Because there are `n` nodes the graph will initially contain `n` components, with two nodes being merged if they share the same row or column. If the pair of nodes to be merged are not already in the same component, two separate components have now been connected, thereby reducing the number of components by `1`. Once all pairs of nodes have been considered, we simply subtract the number of components from the total number of stones to get our answer.  

#### Conclusion
This solution has a time complexity of $O(n^2)$, where $n$ is the length of `stones`. All possible pairs of stones in `stones` are considered, with the union-find being interacted with at most twice for each pair. Operations on the union-find each takes $O(\alpha(n))$ to complete, which in the worst case can be interpreted as $O(1)$. Hence the overall time complexity comes out to be $O(n^2)$. The space complexity is $O(n)$, due to the dictionary `p`.  
  

