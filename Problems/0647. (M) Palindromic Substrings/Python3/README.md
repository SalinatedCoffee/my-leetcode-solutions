## 647. (M) Palindromic Substrings

### `solution.py`
The intuitive solution is to try and find the longest palindromic substrings at every possible center in `s`. We define a function `count` that takes 2 integers representing the proposed center to start the search from. The reason that this is represented by 2 integers instead of 1 is to account for the case where the palindrome has an even length. For palindromes that are centered at the `i`th character, we would call `count(i, i)`. For palindromes that are centered at the interstice between the `i`th and `i+1`th characters, we would call `count(i, i+1)`. `count` simply expands outwards incrementally, until a mismatching pair of characters is found. Every time a matching pair is found, it also means that a new palindromic substring has been discovered, and a global counter `self.ret` is incremented by `1`.  
When all possible centers have been considered we simply return the value `self.ret`, as it will contain the total number of palindromic substrings in `s`.  

#### Conclusion
This solution has a time complexity of $O(n^2)$, where $n$ is the length of `s`. There are $2n-1$ possible centers in string `s`. For each center we expand outwards in an attempt to find the longest palindrome about that center, the length of which is bound by $n$. Therefore, this search will take $O(n)$ time to complete - hence the overall time complexity of $O(n^2)$. The space complexity is $O(1)$.  
A linear time solution exists for this problem, which is known as [Manacher's algorithm](https://cp-algorithms.com/string/manacher.html). This algorithm takes a dynamic programming approach and exploits the properties of palindromes to achieve its linear time complexity. Simply put, it makes clever use of the properties of palindromes nested within another palindrome to use previously computed results in the computation of new ones. The linked article (as well as Manacher's original paper published in 1975) is an interesting read. Revisiting this problem using this approach would be a good follow-up exercise.  
  


### `solution_2.py`
This solution implements the aforementioned Manacher's algorithm. As briefly mentioned, Manacher's algorithm takes advantage of the properties of palindromes. For example, consider the string `acbcdcbcf`. We know that `cbcdcbc` is palindromic, and we know that the palindrome centered at the first `b` has a size of `3`. If we didn't know if the second `b` was a palindrome, we can deduce this from the information we already have. The palindrome centered at `d` has a length of `7`, and it extends beyond the second `b`, up to the following `c`. If we find the 'mirrored' center of the second `b` about `d`, it will be the first `b`, which we already know is the center of a palindrome of length `3`. As this palindrome lies 'inside' the larger palindrome, we know that the second `b` is also a center of a palindrome of length `3` since by definition of palindromes if a substring on one side of a palindrome is palindromic, its mirror about the center is also palindromic. Thus, we can say that the second `b` is a center of a palindrome of length `3` without actually checking the next character.  
There are 2 more cases to consider for the mirrored center. The first is when the mirrored center's palindrome extends beyond that of the 'outer' palindrome. Because we know that the character that comes before and after the outer palindrome is different, the palindrome of the current center would extend right up against the end of the outer palindrome. The second case is when the mirrored palindrome extends right up to the range of the outer palindrome. In this case, we do not know if adding the character that comes after the current palindrome would extend its length. Thus we set the outer palindrome as the current one, and 'fall back' to the trivial algorithm by examining the character that comes after the new outer palindrome.  
Once this algorithm finishes running, we will be left with a list `rad` where `rad[i]` contains the radius of the palindrome centered at `i`, inclusive. Using this list we can trivially count the number of palindromic substrings of `s`.  
The algorithm discussed up to this point assumes palindromes with odd length, and will not work on those with even length. Instead of devising a separate algorithm that works on even length palindromes, we can simply reduce these palindromes into odd length palindromes by interleaving them with an arbitrary character. For example, the string `abccba` would be converted to `|a|b|c|c|b|a|`. Before the conversion the string contained even length palindromes, after the conversion these palindromes now have an odd length as they are now centered at one of the `|`s. As this changes the radii stored in `rad`, we would need to take this account when counting the substrings. Interleaving `s` with a new character would essentially double the radii for each palindrome. If the palindrome had an even length the new length would be double the length + 1, which we can easily account for by performing integer division by 2.  
  

#### Conclusion
The time complexity of this solution is $O(n)$. Because the boundary of the outer palindrome can only increase, `s` (as well as the preprocessed string `s_i`) will only be iterated over once. The preprocessing and counting steps also take $O(n)$ time. The space complexity is also $O(n)$, due to the list `rad`.  
  
  