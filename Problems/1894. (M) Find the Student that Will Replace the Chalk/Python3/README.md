## 1894. (M) Find the Student that Will Replace the Chalk

### `solution.py`
There are `len(child)` children in a classroom, and they start working on problems starting with the `0`-th child up to the `len(child)`-th child. Once the last child solves their problem, we wrap around to the `0`-th child. A child will use a certain number of chalk when solving a problem, and the array `chalk` contains the number of chalk a child will use with `chalk[i]` being the number of chalk the `i`-th child will use while solving a problem. When there is not enough pieces of chalk left for a child to solve a problem, the child is asked to replace the chalk. If we have `k` chalk when the `0`-th child starts working on their problem, we are asked to return the child that will have to replace the chalk.  
We can easily simulate the problem by iterating over `chalk` and subtracting each value from `k`. Whenever we encounter a value that is larger than the current `k`, we immediately return the index of that value. This approach however requires multiple passes over `chalk` and is not at all efficient in cases where the values of `chalk` are very small compared to `k`. Instead, we can perform binary search to find the appropriate index by observing two key properties of the problem. One is that a single pass over `chalk` simply subtracts `sum(chalk)` from `k`. Second is that the number of chalk required until the `i`-th child solves their problem is simply `sum(chalk[:i+1])`, or the sum of the prefix array `chalk[:i+1]`. We can reduce `k` by using the first property, and we can apply binary search on the reduced `k` and the list of prefix sums of `chalk`, which can be trivially precomputed.  
We fill the list `pre`, which will contain the prefix sums of `chalk` with the value of `pre[i]` being the sum of the prefix array `chalk[:i+1]`. `k` is then reduced by assigning the value `k % pre[-1]` if `k` is larger than or equal to `pre[-1]`. Finally, binary search of `k` is performed on `pre` with the initial search space being the entirety of `pre`. Since a vanilla binary search algorithm works in this case, we have opted to use Python's built in `bisect` module instead of implementing our own. One thing to keep in mind is to use `bisect_right` instead of `bisect_left` to account for the case where a value equal to `k` is present in `pre`. In this case, if `pre[i] == k`, the `i`-th child will use up all pieces of chalk leaving not enough chalk for the the *next* child to solve their problem.  

#### Conclusion
This solution has a time complexity of $O(n)$ where $n$ is the length of `chalk`. Precomputing the prefix sums requires $O(n)$ time to complete, and the following binary search step takes $O(\log n)$ time to finish. The space complexity is $O(n)$, due to the list `pre`.  
  

