## 2641. (M) Cousins in Binary Tree II

### `solution.py`
Given a binary tree rooted at `root`, we are asked to modify the node values so that they contain the sum of the values of their cousins. Node A is a cousin of node B if it exists on the same level but does not have the same parent. Upon reading the problem description we immediately realize that we can compute the cousin sum for some node `i` if we know what the parent of node `i` is, and the sum of all node values on the same level as node `i`. The latter can easily be computed by making a BFS pass over the tree, and the former can be achieved by simply traversing all nodes in the binary tree.  
We make two passes over the tree; once to compute the level sums, and another to modify the node values. The first pass involves traversing the tree using BFS, computing the level sums by using a dictionary. For this problem we have opted to implement the iterative version of BFS, using a deque to enqueue future nodes. The depth of the node is pushed along with the node itself, which is used to index into the dictionary of level sums. Once the traversal completes, we make a second pass over the tree while modifying the value of each node. As described earlier, we can compute the cousin sum of a node `j` if we have access to its parent `i`, and the level sum of node `j`. For some node `i`, we first compute the sum of the values of its children. The cousin sum of its children is simply the value we just computed subtracted from the sum of level `d+1`, with `d` being the level of node `i`. We traverse the tree using DFS while updating the value of each node appropriately. Once the traversal completes, we change the value of the root to `0` before returning it.  

#### Conclusion
This solution has a time complexity of $O(n)$ where $n$ is the number of nodes in the binary tree rooted at `root`. Each traversal requires $O(n)$ time to complete as each node is visited exactly once, and a visited node requires $O(1)$ time to process. The space complexity is $O(n+h)$, where $h$ is the height of the given binary tree. A deque is used to store nodes to be traversed during the first traversal, and a stack is used during the second. During each step, these data structures each use $O(n)$ memory. The dictionary `level_sum` contains $h$ key-value pairs and is kept in memory until the algorithm exits, bringing the overall space complexity to $O(n+h)$.  
  

