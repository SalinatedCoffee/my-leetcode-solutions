## 2940. (H) Find Building Where Alice and Bob Can Meet

### `solution.py`
A series of buildings are laid out in a line, with the `i`th building from the left having the height `heights[i]`. If a person currently resides in some building `i`, that person can move to *any* building `j` where `i < j` and `heights[i] < heights[j]` are both true. That is, a person can only move to a building if it is to the right of the current building and is strictly taller. `queries` is a list of queries to be performed on these buildings, with each query consisting of 2 integers. The first integer is the index of the building that Alice currently resides in, and the second integer is the index of the building where Bob is in. For a single query, the returned value should be the index of the *leftmost* building where Alice and Bob can meet. If it is impossible for the two to rendezvous, the result of the query is `-1`.  
Breaking down the problem description, we essentially want to find the earliest value in `heights` that is larger than or equal to the larger value between the two given integers of a query. Because Alice and Bob can only move towards the right, we know that a valid building can only exist in the subarray `heights[max(a, b):]` where `a` and `b` are the indices of the buildings where Alice and Bob are currently in. If we were to take a brute force approach, we would have to scan through `heights` for every query. Could we do better? Indeed we can - if we think about the problem in reverse, we would be answering queries per building instead of searching for the correct building per query. Iterating over the list of buildings, we can see that the current building could be a potential answer for all relevant queries. 'Relevant' in this case would mean that the query contains indices that are less than or equal to the index of the current building. If we were to store these queries inside a priority queue, we could process queries as long as the height of the taller building is less than the current one. We can achieve this by preprocessing `queries`, assigning the appropriate building height to the appropriate building index. This way we can defer adding queries to the heap while iterating over `buildings`, only adding them until they become relevant.  
The solution largely consists of two steps. In the first step, `queries` will be preprocessed into the list `height_to_query`, where `height_to_query[i]` is a list of tuples representing queries. As briefly discussed earlier, we know the subarray range in which an answer may exist given a single query. If we call this index `i`, the tuple representing the `j`th query in `queries` would be `(max(heights[queries[j][0]], heights[queries[j][1]]), j)`. Once all queries have been processed, we can move onto the next step, where we iterate over `heights` to answer the relevant queries. The priority queue is first polled, removing and answering queries that can have the current building as the correct answer. After that, the queries corresponding to the current building are added to the priority queue to be answered later. When all buildings have been considered, we return the list of answered queries regardless of the status of the priority queue.  

#### Conclusion
This solution has a time complexity of $O(m\log m)$ where $m$ is the length of `queries`. While the second step loops over `heights`, if we look at what is happening inside the loop we can see that the total number of operations performed scales linearly with the number of queries, instead of the buildings. Since the priority queue can hold up to $m$ items, a single add/remove operation on `heap` will take $O(\log m)$ time to finish. Therefore, the overall time complexity of this solution clocks in at $O(m\log m)$. The space complexity is $O(n+m)$, where $n$ is the length of `heights`. This is due to the list `height_to_query`($O(n)$), and the min heap `heap`($O(m)$).  
  

