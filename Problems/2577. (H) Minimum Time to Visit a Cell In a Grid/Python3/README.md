## 2577. (H) Minimum Time to Visit a Cell In a Grid

### `solution.py`
On a grid of non-negative integers, we want to start at the upper-leftmost cell(0th row, 0th column) at time 0 and travel to the bottom-rightmost cell. We are allowed to travel to the four neighboring cells in the cardinal directions, only if the value of a cell is less than or equal to the current time *at the time it is visited*. Given these conditions and the 2D list representation of the grid `grid`, we are asked to determine the minimum time required to reach the goal. If the goal is impossible to reach, we should return `-1` instead.  
Intuition tells us that we could treat the grid as a graph. If we could devise a method that somehow weighs the edges using the value of each cell, we could run Dijkstra's algorithm on the generated graph to determine the cost of the shortest path from the origin to the destination. When traversing `grid`, we should consider the case where we cannot travel to a neighboring cell as the other case is trivial. When none of the neighbors(excluding the previous) are available for traversal, we would have to backtrack to the previously visited cell and return to the current one to 'stall' until a neighbor becomes traversable. Because a cell can be traveled to when the current time becomes greater than or equal to the cell's value **at the time it is visited**, we would need to stall for a neighboring cell `grid[i][j]` until the current time becomes `grid[i][j] - 1`. There are two possible scenarios when stalling for a neighbor; it either becomes traversable when we are occupying the current cell, or it becomes available when we are on the previously traversed cell. We also know that if we stall an odd unit of time we end up at the previous cell, and we end up at the current cell otherwise. Combining this information, we get that the neighboring cell `grid[i][j]` can be visited at exactly `grid[i][j]` time if the difference between that value and current time `t` is **odd** since we would be occupying the current cell when the current time is `grid[i][j] - 1`. Otherwise, we would be occupying the previously visited cell at time `grid[i][j] - 1` thus requiring us to spend `1` unit of time to return to the current cell before traveling to `grid[i][j]`. In short, `grid[i][j]` can be reached at time `grid[i][j]` if the value of `grid[i][j] - t` is odd, or at time `grid[i][j] + 1` otherwise.  
Now that we have devised a method to properly weight transitions between cells, we can implement the priority queue based version of Dijkstra's algorithm, using the total time required to reach a certain position as the sorting criteria.  

#### Conclusion
This solution has a time complexity of $O(mn\log(mn))$, where $m$ and $n$ are the dimensions of `grid`. The priority queue may contain $mn$ nodes at most, meaning that insertions and removals from said queue will complete in $O(\log(mn))$ time. Dijkstra's algorithm visits all vertices in the graph in the worst case. Since each element in `grid` serves as a vertex, and `grid` contains $mn$ elements, the overall time complexity comes out to be $O(mn\log(mn))$. The space complexity is $O(mn)$, due to the priority queue `nodes` and set `visited`.  
  

