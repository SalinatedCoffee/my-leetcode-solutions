## 2699. (H) Modify Graph Edge Weights

### `solution.py`
The list of edges `edges` form a connected weighted undirected graph with `n` nodes(0-indexed). Some edges have a weight of `-1`, which means that the weight can be set to any positive integer. All other edges already have a positive weight. Given `edges` and the integers `source`, `destination`, and `target`, we are asked to return the list of edges of the graph where the shortest distance between the nodes `source` and `destination` is exactly equal to `target`.  
First off, we need to deal with the fact that the 'wildcard' edges have a negative weight of `-1`. Because we are working with shortest weighted paths, we know that we should be using Dijkstra's algorithm on the graph but cannot do so as the algorithm fails on graphs with negative weighted edges. Let's first think about a path that contains at least one wildcard edge. After modifying the weights of all wildcard edges, all edge weights in the graph should be positive. Because of this, the smallest weight that a wildcard edge can have is `1`, and we know that the smallest possible path weight will be the sum of the weights of the non-wildcard edges plus the number of wildcard edges. Thus, when running Dijkstra's algorithm on the graph, we can regard the weight of a wildcard edge as being `1`. Using this logic, there are a few definitive things we can say about the graph. First off, if the shortest path between `source` and `destination` does not contain wildcard edges but has a total weight less than `target`, it is impossible to modify the graph to make it meet the desired condition. The same can be said for when the shortest path does contain wildcard edges but has a total weight that is larger than `target`. If the sum of weights of the shortest path is already equal to `target`, we can simply modify the wildcard edges to have an arbitrarily large weight and return the list of edges. But what if the shortest path contains wildcard edges, and has a total weight that is smaller than `target`? We can modify the wildcard edges so that the weight sum matches `target`, but it may be the case that the next-shortest path also has a weight sum less than `target`. After modifying the shortest path the next-shortest path will now be the shortest path, making our modifications irrelevant. If the next-shortest path does not contain wildcard edges, it is impossible to modify the graph. If it does, we need to modify the edges and check the graph again to confirm that the modified path was indeed the shortest path. These steps are repeated until it is determined that either it is impossible to modify the graph, or the graph satisfies the conditions, at which point the remaining wildcard edges are assigned an arbitrarily large weight. The problem with this algorithm however, is that it is quite difficult(read: annoying) to keep track of the wildcard edges within a path since they have practically been assigned a weight of `1`. Instead of trying do deal with this problem, we can simply create the graph without the wildcard edges, and try adding them in one by one.  
`edges` is first converted into the adjacency list `adj`, excluding the wildcard edges. Because we will be running Dijkstra on the graph multiple times, we implement it as the separate function `shortest_path` which takes no arguments and returns the weight of the shortest path between `source` and `destination` within the current graph. We first check the shortest path consisting of only non-wildcard edges by running `shortest_path` before adding any wildcard edges to the graph. If this length is less than `target`, we return `[]` as it is impossible to modify the graph. If this length is exactly `target`, we assign an arbitrarily large weight to the wildcard edges and return the list of edges. Otherwise, we start adding in wildcard edges one by one. For each wildcard edge, we assign it a weight of `1` and add it to the graph before running `shortest_path`. If the weight sum of the shortest path is less than or equal to `target`, we re-adjust the weight of the newly added wildcard edge so that the weight of the path matches `target` before modifying the remaining wildcard edges and returning the list of edges.  

#### Conclusion
This solution has a time complexity of $O(m(n+m)\log n)$ where $m$ is the length of `edges` and $n$ is `n`. `shortest_path`, which implements a min heap based Dijkstra's algorithm, can be run at most $m+1$ times. A single pass of Dijkstra's on a graph with $m$ edges and $n$ vertices requires $O((n+m)\log n)$ time to complete, bringing the overall time complexity to $O(m(n+m)\log n)$. The space complexity is $O(m+n)$, due to `adj` and `dist`, `heap` in `shortest_path`.  
  

