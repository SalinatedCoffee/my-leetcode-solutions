## 3133. (M) Minimum Array End

### `solution.py`
Given two integers `n` and `x`, we are asked to return the minimum possible value of `nums[n-1]` where `nums` is a strictly increasing list of integers where the bitwise AND of all elements is equal to `x`. Since the bitwise AND of all elements should be equal to `x`, this means that every element in `nums` should also have raised bits in the same binary digits as `x`. We can also say that the first element of `nums` is always `x`, as `x` itself is the smallest possible integer that has the same set of raised binary digits as `x`. Starting with `x` then, we want to generate `n` integers that contain the set of raised binary digits of `x` in ascending order. Because we want to keep the raised bits of `x` intact, we are essentially incrementing the integer resulting by concatenating all binary digits in `x` that are *not* raised. For example, let `x = 9` and `n = 5`. `x` in binary is `1001`, which means that all elements of `nums` must have the first and 4th bits raised. The first element of `nums` is `x` itself, as described earlier. The next element is `1011`, the third is `1101`, the fourth is `1111`, and the fifth is `11001`. If we examine this sequence and 'remove' the bits that are raised in `x` from each element, we would end up with the sequence `000`, `001`, `010`, `011`, and `100`. This sequence is obviously the sequence of integers starting with `0` in ascending order; which means that we can generate `nums` incrementally by taking the current element and concatenating the bits not raised in `x`, incrementing this value by `1`, and then redistributing the bits back into their original digits. We can avoid having to generate all elements of `nums` however, by noticing that the integer formed by the unset bits of the `n`th element of `nums` is simply `n-1`. This means that we can construct the `n`th element directly by filling in the unset bits of `x` with the binary representation of `n-1`.  
We initialize 3 integers before we start constructing the `n`th element of `nums`. `n` is decremented by `1`, `res` is assigned the value of `x`, and `mask` the value of `1`. While `n` still contains raised bits, we examine the current digit by bitwise ANDing `res` and `mask`. If the bit is not raised we examine the LSB of `n`, raising it only if it is raised. Regardless, `n` is shifted `1` bit towards the right as the current bit in `n` has been assigned to the appropriate unset bit within `x`. `mask` is shifted `1` bit towards the left, and the process is repeated until `n` becomes `0`. When the `while` loop exits, the value of `res` will be the value of the `n`th element of `nums`.  

#### Conclusion
This solution has a time complexity of $O(\log n)$, where $n$ is `n`. The space complexity is $O(1)$.  
  

