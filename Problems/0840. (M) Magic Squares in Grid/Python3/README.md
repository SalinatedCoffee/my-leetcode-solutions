## 840. (M) Magic Squares in Grid

### `solution.py`
A 'magic square' is a 3 by 3 grid that contains one of each integers in the range `[1, 9]`, and the sum of each of its rows, columns, and diagonals are all equal. Given the 2D list `grid`, we are asked to return the number of magic squares in `grid`. The straightforward method(but not necessarily simple to implement) would be to check all 3 by 3 squares in `grid`, evaluating whether they are magic or not by looking at the sums of each row, column, and diagonal. While we cannot change the fact that all squares in `grid` have to be examined, we can exploit some of the mathematical properties of a magic square to make the implementation a lot simpler.  
Let's first consider the first property of a magic square, which is that it must contain 1 of each of the values in the range `[1, 9]`. This naturally means that a magic square must sum up to $9\cdot(9+1) / 2 = 45$, which in turn also means that the sum of each row, column, and diagonal should be 15. Given these constraints we can easily enumerate all possible selections of values that sum up to 15, which are `[1, 5, 9]`, `[1, 6, 8]`, `[2, 4, 9]`, `[2, 5, 8]`, `[2, 6, 7]`, `[3, 4, 8]`, `[3, 5, 7]`, and `[4, 5, 6]`. If we examine these selections, we can see that 4 of them have `5` as the middle value. If we were to map these 8 selections onto a square, we can see that the only way for a value to appear in 4 selections would be when it is in the center of the square, since the two diagonals and the second row and column include the center value. Using similar logic, we see that the even numbers each appear exactly thrice across all selections. `2` appears in `[2, 4, 9]`, `[2, 5, 8]`, and `[2, 6, 7]`, `4` appears in `[2, 4, 9]`, `[3, 4, 8]`, and `[4, 5, 6]`, and so on. The cells that are shared by exactly 3 selections are those in the 4 corners, which tells us that the value of those squares of a valid square must all be even. Doing the same for the odd numbers, we know that they must go in the 4 cells in the cardinal directions of the center cell. These observations can be leveraged to find all magic squares, of which there are 8 of(not listed here). Examining these squares, we notice that the sequence of the values on the edges always follow `2, 9, 4, 3, 8, 1, 6, 7` when traversed either clockwise or counter-clockwise. Hence, we conclude that a 3 by 3 square must be a magic square if its edge cells form the sequence `2, 9, 4, 3, 8, 1, 6, 7` **and** the value of the center node is `5`.  
We can now start implementing the solution, which we start off by declaring the magic sequence of values as constants. In order to make the implementation as simple as possible, we will compare the string representations of sequences as Python already supports substring searching. Each square will be traversed in the same order, but since we know the pattern we are looking for, we can formulate the constants to compensate for this. For example, we will be scanning the square in clockwise order, starting at the square on the upper left. As previously mentioned, the square can contain any even number. However since the *ordering* of the values that follow are the same regardless, we can append the sequence to itself and determine whether the sequence of the square is a substring of the expected string. We can also handle the counter-clockwise case by simply reversing the expected string and performing a substring search on that. If this operation returns `True`, and the upper left square is even, and the middle square is `5`, the current square is indeed magic and thus we increment the counter `ret` by `1`.  

#### Conclusion
The time complexity of this solution is $O(mn)$ where $m$ and $n$ are the dimensions of `grid`. While the evaluation of a square involves substring searches and traversing the square itself, these operations all cost constant time as the size of the square is fixed. Since there are $O(mn)$ number of squares in `grid`, the overall time complexity comes out to be $O(mn)$. The space complexity is also $O(1)$, since all variables used either have a fixed size or upper bound.  
  

