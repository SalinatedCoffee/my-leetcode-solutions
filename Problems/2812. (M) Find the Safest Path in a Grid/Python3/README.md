## 2812. (M) Find the Safest Path in a Grid

### `solution.py`
first pass over grid to find all thief cells and process them accordingly (grid is used as visited set)  
first BFS over grid to assign the safeness factor of all non-thief cells  
second pass over grid to find highest safeness factor to use as upper bound for initial search space  
binary search over search space defined in the previous step, evaluating each midpoint by running BFS on grid to determine whether a path with higher safeness factor exists  
once binary search completes ret will contain the desired value  
Given a 2D list of `0`s and `1`s, we are asked to return the maximum 'safeness factor' of a path starting at the upper leftmost cell and ending at the lower rightmost cell. The safeness factor of a square is simply the minimum manhattan distance from it and a cell containing a `1`. The safeness factor of a path is the smallest safeness factor of all squares that comprise it. Obviously, computing the safeness factor of each square on the fly as we try finding a path would take too much time. The hint here is realizing that the safeness factor of a cell does not change no matter how `grid` is traversed, and hence can be precomputed by using BFS. Starting at a 'thief' cell(a cell that has a value of `1`), we can run BFS to assign every non-thief cell an appropriate safeness factor. Since there are multiple thieves in `grid` however, we need to perform a multi-source BFS by initializing the queue with each and every thief cell. Instead of using a separate set to keep track of the visited cells, we will use `grid` to store this information, where a unvisited node will have a value of `-1`. A single pass is made over `grid`, adding the thief cells to the queue and initializing the value of each cell appropriately. `grid` will now contain the safeness factor of each cell, and we can move on to the next step.  
We now need to determine the highest safeness factor for a path that starts at `grid[0][0]` and ends at `grid[-1][-1]`. Given some safeness factor `k`, we know that we can easily determine whether a path that is safer(or less safe) exists by simply traversing `grid` while checking each cell's safeness factor. However, we do not know which safeness value to verify, and checking each cell also does not help as we want the safeness value of a path between two cells. Instead, since we can verify the existence of a valid path given an arbitrary safeness factor, we can perform binary search using safeness factor as the search space to find the value we want. The initial search space is `[0, max([max(row) for row in grid])]`, as the theoretical maximum safeness factor of a path is naturally the maximum safeness factor in `grid`. The binary search step can now be performed, halving the search space until it becomes smaller than `1`. The midpoint is verified by performing yet another BFS traversal starting at `grid[0][0]`. If the traversal makes it to `grid[-1][-1]` using the midpoint as the target safeness factor, a path that is at least safe as the midpoint value exists, and we discard the lower half of the search space. Otherwise, we discard the higher half. When the binary search completes, the last valid midpoint is the largest safeness factor for a valid path.  

#### Conclusion
This solution has a time complexity of $O(n^2\log n)$, where $n$ is the length of one side of `grid`. Two passes are made over the entirety of `grid`; once to find the thief cells and initialize the value of each cell, and once to determine the upper limit of the initial binary search space. BFS is performed multiples times on `grid`, with each run taking $O(n^2)$ time to complete. The upper bound for the initial search space for the binary search step can be at most $2n$, since the safeness factor is the manhattan distance between a thief cell and a non-thief cell. Hence, the search space will be halved $O(\log n)$ times; and since a BFS traversal is performed on `grid` for each halving, the overall time complexity comes out to be $O(n^2\log n)$. The space complexity is $O(n^2)$.  
  

