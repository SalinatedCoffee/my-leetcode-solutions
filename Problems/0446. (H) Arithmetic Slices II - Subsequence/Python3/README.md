## 446. (H) Arithmetic Slices II - Subsequence

### `solution.py`
An arithmetic sequence is defined as a sequence of at least 3 integers where the difference between any two consecutive elements are the same. We are asked to return the number of all such sequences, where the elements form a subsequence of the array `nums`. Different elements with the same value are considered distinct, so if `nums = [1, 2, 3, 3]`, there would be 2 arithmetic subsequences instead of 1. Intuition tells us that we should try taking a dynamic programming approach for this problem, as we can gradually build on top of previously determined subsequences. This is one of those relatively few dynamic programming problems where the bottom-up approach is easier than the top-down approach.  
The first order of business would be determining the number of parameters that should be used to represent each DP state. We want to be able to identify the difference of a sequence in order to determine whether we can extend it with a new element in `nums`, and we also want to keep track of exactly which element we are currently considering within `nums`. Each state of our recurrence relation will be represented by 2 integers; one representing the index of the element in `nums` currently being considered, and the other the difference of the arithmetic sequence ending with that element. This way, we can keep track of different subsequences ending with the same element; for example, the `6` in `nums = [1, 2, 3, 4, 5, 6]`. The value of each state should be the number of arithmetic subsequences with the specified stride ending with the element at the specified index. We will store the values of each state in `dp`, a list of dictionaries where the value `dp[i][j]` will be the number of 'arithmetic subsequences' ending with `nums[i]` with difference `j`. Note that we must use dictionaries to store the differences as there is no way of knowing beforehand what the actual values will be.  
The premise of the algorithm itself is rather simple. When computing the values for `dp[i]`, we iterate over all values before `nums[i]` while examining the difference between them and `nums[i]`(let's call one such value `nums[j]`, where `j < i`). We first increment the value of `dp[i][nums[i] - nums[j]]` by `1`, as we have found a pair of values that would count as an arithmetic subsequence with difference `nums[i] - nums[j]`. Next, we see whether a previous subsequence can be extended by checking for subsequences with the same difference that ends at `nums[j]`. If so, we increment `dp[i][nums[i] - nums[j]]` by `dp[j][nums[i] - nums[j]]`. We also update the total number of subsequences during this step, as `dp` also counts subsequences with a length of 2 whereas the problem asks us to count those with a length of at least 3. These steps are repeated until `i` reaches the end of `nums`, at which point we will have counted all valid subsequences within `nums`.  

#### Conclusion
This solution has a time complexity of $O(n^2)$, where $n$ is the length of `nums`. In our state definition `dp[i][j]`, `i` is bound by $n$. `j` is the difference between `nums[i]` and `nums[j]`, but since $0 \leq \texttt{j} \lt \texttt{i}$ `j` also ends up being bound by $n$. Hence, the overall time complexity becomes $O(n^2)$. The space complexity is also $O(n^2)$, due to the same reason.  
  

