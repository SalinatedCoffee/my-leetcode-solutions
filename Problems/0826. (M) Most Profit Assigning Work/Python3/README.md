## 826. (M) Most Profit Assigning Work

### `solution.py`
Given a list of jobs and workers, with each job having a profit value and difficulty value, we are asked to return the most achievable profit by assigning workers a job. A single job can be assigned to multiple workers, but a worker can only be assigned a single job. A job can also be assigned to a worker only if its difficulty value is less than or equal to the ability value of the worker. The difficulty and profit value of each job is given in the lists `difficulty` and `profit`, and the 'ability' value of each worker is given in the list `workers`.  
Because a job cannot have a negative profit, it is optimal to assign a job to as many workers as possible. In a similar vein, we want to assign the job that yields the most profit to each worker. The difficulty of a job however is not correlated with its profit, which means that a job with a lower difficulty could actually return a higher profit. This means that we want to examine a job based on its profit instead of its difficulty. If we examine each job starting with the one with the highest profit, we can assign that job to as many workers as possible to maximize the profit yield of that single job. We do this until either we run out of jobs or run out of workers, at which point we will know the maximum amount of profit that can be achieved.  
The lists `profit` and `difficulty` are `zip`ed together into a single list, which is then sorted by `profit` in descending order. `workers` is sorted as well, so that we can use binary search to determine the most number of workers that can take on the job. Apart from the currently accrued profit, we also keep track of the index of the unavailable worker that has the smallest ability value(assuming that `workers` is sorted in ascending order). This is because a job with a higher profit could have a lower difficulty than another job. In order to avoid assigning multiple jobs to a single worker, we need to keep track of all the workers that are not available for assignment. Finally, starting with the job with the highest profit, we use binary search(using Python's built in `bisect` module) to find the index of the first worker that can be assigned the job. If this person is available, we greedily assign the current job to that worker as well as all other available workers that can take the job, updating the pointer and total profit accordingly. Before moving onto the next job we check if there are any available workers left, and return the total profit immediately if there are none.  

#### Conclusion
This solution has a time complexity of $O(m\log m+n\log n+n\log m)$, where $m$ is the number of workers and $n$ is the number of jobs. `profit` and `difficulty` are zipped and sorted, which takes $O(n\log n + n)$ time to complete. Similarly, sorting `workers` will take $O(m\log m)$ time to finish. The assignment step iterates over the list of jobs, with each job performing a binary search on the list of workers. As the list of jobs is $n$ long and a single binary search on the list of workers takes $O(\log m)$ time, this step will take $O(n\log m)$ time to compute. Thus, the overall time complexity of this solution is $O(m\log m+n\log n+n\log m)$. The space complexity is $O(\max(m, n))$, as the sorting step uses $O(\max(m, n))$ memory and the zipped list of jobs uses $O(n)$ space. The $\max$ term is there because each step happens sequentially; that is, as Python's built in sort frees any used memory after it finishes, the most amount of memory the solution will use during its runtime will be the larger term between $m$ and $n$.  
  

