## 295. (H) Find Median from Data Stream

### `solution.py`
Ideally, we would like to be able to retrieve the median in constant time. We could use a linked list based array to ensure constant time access, but since we need to keep the items in sorted order insertions would take $O(n)$ time as we need to find the insert location. Coming back to the definition of the median we know that there are two cases; one where there are an odd number of items and one with an even number. In both cases, we can see that the list is split in half. These lists will also be in ascending order, and to get to the middle value of the original list we know that we should look at the last element of the left half, and the first element of the right half. For this we can use two heaps - a max heap for the left half, and a min heap for the right half. Then we can ensure that insertions will be fast, and we have constant time access to the two values metioned earlier by virtue of using a heap.  
Retrieving the median is trivial - if both heaps have the same size that means that there are an even number of items total, and so we take the top of both heaps and return the average. If not, we simply return the top of the larger heap.  
For insertion, we want to guarantee that the left half contains only the k-smallest items, where k is the number of inserted elements divided by half. So if the item to be inserted is larger than the top of the left heap, it obviously does not belong in the left half and so we insert it into the right heap. After insertion we also need to enforce the bound on the size difference between the two heaps. If one heap contains more than 1 element than the other, we rebalance the heaps by popping an item from it and pushing it into the smaller one.  
  
#### Conclusion
`addNum()` has a running time of $O(\log m)$ where $m$ is the number of items added to `MedianFinder`. `findMedian()` takes $O(1)$ time to run as retrieving the first item of a heap runs in $O(1)$ time. `MedianFinder` overall will have a space complexity of $O(n)$ where $n$ is the number of items added to it.  
Follow-up questions involve optimizing `MedianFinder` if inputs are in the range of $[0,100]$, or how it would be implemented if the data stream is too large to fit in memory.  
The former can be solved by keeping a count of numbers in the suggested range(extended by -1 and 101 if 1% of inputs are outside of that range). For the latter it is impossible to find the **exact** answer, but we can find the best approximation by only keeping track of the $n$ recently inserted items. Of course, the actual approach will be different [depending on what we know](https://stackoverflow.com/questions/10657503/find-running-median-from-a-stream-of-integers) about the expected input.  