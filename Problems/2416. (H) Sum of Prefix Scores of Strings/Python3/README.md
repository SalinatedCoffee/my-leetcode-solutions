## 2416. (H) Sum of Prefix Scores of Strings

### `solution.py`
A word is a string in the list `words`. Each prefix of a word can be given a score, where the score is the number of words in `words` that also have that prefix. The score of a word is simply the sum of the scores of its prefixes. For example, let `words = ["abc", "ab", "bc"]`. To assign a score to `"abc"` we first look at its prefixes, which are `"a"`, `"ab"`, and `"abc"`. `2` words have `"a"` as its prefix(`"abc"` and `"ab"`), `2` words have `"ab"` as its prefix(`"abc"` and `"ab"`), and `1` word has `"abc"` as its prefix(`"abc"`). Hence, the word `"abc"` would be assigned a score of `2 + 2 + 1 = 5`. Given `words` and the described scoring method, we are asked to return a list containing the score of each word in `words`.  
The first thing that should come to mind is a trie. We first generate a trie using the contents of `words`, and iterate over `words` a second time to compute the score of each word. Because we want to count the number of words that share the same prefix, we need to make a small addition to the trie so that each node keeps track of the number of times it was visited during the initial generation of the trie. During the score computation step, we simply take this value from each node that is visited and sum them to calculate the score of the word.  
A `TrieNode` object represents a single node in the trie, with `TrieNode.children` being a dictionary mapping a letter to the corresponding `TrieNode`, and `TrieNode.count` representing the number of times the node was visited during the trie building phase. After initializing the root node of the trie `root`, we iterate over `words`, inserting each word into the trie rooted at `root`. Each word is then iterated over, and if the `TrieNode` object corresponding to the current letter does not exist a new node is created and linked to its parent. After traversing to the appropriate node, its count is incremented by `1`. Once all words have been inserted into the trie, we make a second pass over `words`, this time to compute the score for each word. While traversing the trie using each word, we accumulate the value of `TrieNode.count` for each visited node. Once the traversal is complete, the value of this sum will be the score of the word, and is appended to the end of the list-to-be-returned `res`.  

#### Conclusion
This solution has a time complexity of $O(nk)$, where $n$ is the length of `words` and $k$ is the average length of the strings in `words`. Generating a trie from the contents of `words` requires $O(nk)$ time to complete, as well as computing the score for each word. The space complexity is also $O(nk)$, since the trie is kept in memory until the algorithm exits.  
  

