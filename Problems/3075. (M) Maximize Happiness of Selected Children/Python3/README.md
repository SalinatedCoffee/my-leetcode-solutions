## 3075. (M) Maximize Happiness of Selected Children

### `solution.py`
At first glance it would seem as if this problem could be solved by taking a dynamic programming approach, which is indeed correct. However, upon further ideation we can see that a greedy solution can be implemented for this problem. The key is realizing that the amount of decreased happiness is the same regardless of the order in which we select `k` children. While there are instances where this statement is not true, we can easily argue that selecting `k` children in this manner is not optimal.  
Let `happiness` be a list of happiness values for each child with length `k`, where `happiness[i] >= k` for all `i` in the range `[0, k-1]`. Selecting the first child `i` will accrue a happiness value of `happiness[i] - selected` where `selected` is the number of children already selected, which in this case is `0`. The next child `j` will increase the total by `happiness[j] - selected`, with the value of `selected` being `1`. This continues until every child is selected, with the last child `k` contributing `happiness[k] - (k - 1)` to the total. Because all values in `happiness` is larger than or equal to `k`, it can be said that the selection order does not affect the total amount of happiness. This argument can be extended to cases where `len(happiness) > k` and `happiness` contains `k` or more values larger than or equal to `k`. If we select only the children that has `k` or more happiness, the order in which we do so will not affect the total amount of happiness among the selected children. But what happens when `len(happiness) == k` and `happiness` contains values smaller than `k`?  Again, the ordering does not matter as long as we select children with greater happiness than the number of currently selected children. However, selecting a child that adds `0` to the total amount of happiness is not optimal. If, at the time of selection, there are other children that does increase the sum of happiness, selecting a child that does not contribute to the sum will *decrease* the values for the other children, reducing the possible sum. Since the happiness value of a child cannot be negative, selecting a different child will *not* decrease the happiness sum, and will be the more optimal action to take. Hence, we can solve this problem by simply selecting children in descending order of their happiness values.  
We first sort `happiness` in descending order of its values, after which we iterate over the sorted list up to the `k`th element(1-indexed). For each element, we add `max(0, happiness[i] - i)` to the happiness sum. `i` is 0-indexed, and thus represents the number of children we have already selected. The `max()` is used to enforce a floor value of `0` to the adjusted amount of happiness, since a child's happiness cannot be negative. Once the iteration completes, we simply return the sum of happiness directly.  

#### Conclusion
This solution has a time complexity of $O(n\log n)$, where $n$ is the length of `happiness`. `happiness` is first sorted in descending order, which takes $O(n\log n)$ time using Python's built-in `list.sort()`. The iteration step that follows takes $O(n)$ time since `k >= len(happiness)`. The space complexity is $O(n)$, due to the sorting step.  
  

