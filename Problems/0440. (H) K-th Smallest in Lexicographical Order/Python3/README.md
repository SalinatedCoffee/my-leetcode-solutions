## 440. (H) K-th Smallest in Lexicographical Order

### `solution.py`
From the list of lexicographically ordered integers in the interval `[1, n]`, we are asked to return the `k`th value. While generating the lexicographically ordered list of the integers in that interval is trivial, the upper bound on the inputs `k` and `n` is $10^9$, which makes generating all values take too long for it to be a viable approach. We need to devise a method that skips intermediate values when necessary to avoid generating all values up to `k`, bringing the time complexity below linear.  
There are two parts to this problem. The first is figuring out when and how to skip intermediate values, and the second is figuring out how to count the supposedly intermediate values. If we think about what a lexicographic ordering actually is, we can see that the values can be imagined as a trie. A node with a value of `i` has 10 children, starting with `i0` and ending with `i9`. In the ordered list, the children of `i` would appear between `i` and `i+1` - which means that we can count the number of values between `i` and `i+1` when the ordered list contains all integers in the range `[1, n]`. If we know the remaining number of values that have to be generated in order to reach the desired value, we can make a decision based on the counted number of values. If there are more values than the remaining number of values, it means that the desired value is also between `i` and `i+1`, which means that skipping them would also skip the desired value. In this case, we move down a level in the trie by adding another digit to `i`. If the value count is less than the number of remaining values, we can skip all of them.  
Counting the values between `i` and `i+1` is surprisingly simple(but elegant). We essentially want to count the values in level order, moving down a level until the values exceed `n`.  
We can now start implementing the solution, first initializing the current value to `1` and decrementing `k` by `1` to account for the initial value. The function `count` takes 2 integers `a` and `b`, and will return the number of values between them. We count the number of values in the current level using the expression `min(n+1, b) - a`, with `min` preventing the overcounting of values. After descending down one level by adding a digit to `a` and `b`, we repeat these steps until `a` becomes larger than `n`. We can accurately count the number of values by only adding digits to `a` and `b` since we only care about the number of values and not their order. Imagine an empty list of ordered values between `a` and `b`. By counting the values in each level, we are filling this empty list in a 'sparse' manner until it becomes fully populated - that is, `a` becomes larger than `n`. At this point, the counter `res` will contain the number of values between `a`(inclusive) and `b`(exclusive), which is returned. With `count` implemented, we can finally move onto determining the `k`th lexicographical number. As described above, we count the number of values between the current value `cur` and `cur+1` by calling `count(cur, cur+1)`. If this value is less than `k` these intermediate values can be skipped, which is done by incrementing `cur` by `1` and subtracting the value of `count(cur, cur+1)` from `k`. If the value is larger than `k`, we descend down the trie by adding a digit to `cur` and decrementing `k` by `1` to account for this change. Once there are no more values left to consider(`k == 0`), the value of `cur` will be the desired number.  

#### Conclusion
This solution has a time complexity of $O(\log_{10}(n)^2)$ where $n$ is `n`. Each call to `count` takes $O(\log_{10} n)$ time to complete, since we keep adding a digit to `a` until it becomes larger than `n`. The `while` loop repeats until `k` becomes `0` - in other words, until `cur` becomes the `k`th number. Because `cur` is either incremented by `1` or gets a digit attached to it, the loop will run $O(\log_{10} n)$ times in the worst case, resulting in the overall time complexity of $O(\log_{10}(n)^2)$. The space complexity is $O(1)$.  
  

