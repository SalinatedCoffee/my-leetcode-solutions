## 2872. (H) Maximum Number of K-Divisible Components

### `solution.py`
We are given an undirected tree-like graph, described by the values `n`, `edges` and `values`. The tree contains `n` nodes, labeled from `0` to `n-1`. Each node has a value associated with it, with `values[i]` representing the value of the `i`-th node. Finally, `edges` is a 2D list of edges, with `edges[i]` meaning that an edge exists between nodes `edges[i][0]` and `edges[i][1]`. The graph is initially a single connected component, with the value of a component being the sum of all node values comprising that component. Our task is to determine the maximum number of connected components that can be created by removing edges, where the value of each component is divisible by `k`.  
Upon reading the problem description, the problem may seem to be quite difficult. Even so, we start reasoning about the problem by first considering the fact that the given graph is guaranteed to be a valid tree. Thinking about the graph as a tree, we know that we can only detach a subtree from the entire tree(thus making a new connected component) when the sum of all nodes of the subtree is divisible by `k`. Because the value of the initial tree is guaranteed to be divisible by `k`, detaching a subtree with value `i` from the tree with value `j` means that the remainder of the tree will have the value `j - i`. Since `j % k == 0` and `i % k == 0` are both true, we can say that `(j - i) % k == 0` is also true. Thus, we can traverse the tree from an arbitrary root, computing the sum modulo `k` of the subtrees starting at the leaves. After adding the sum mod `k` of all descendant nodes and the value of the current node, we compute the value of this sum mod `k`. If it is `0`, this node can be detached from the original tree to create 1 new connected component. Otherwise, we do nothing and return this value for the parent node to utilize. Once the traversal completes, we simply return the number of connected components created.  

#### Conclusion
This solution has a time complexity of $O(m+n)$, where $m$ is the length of `edges` and $n$ is `n`. Populating the adjacency list `adj` finishes in $O(m)$ time. Traversing the graph using DFS takes $O(V+E)$ time, where $V$ is the number of vertices and $E$ is the number edges in the graph being traversed. Since the given graph has $m$ edges and $n$ vertices, a DFS traversal over the graph in question will require $O(m+n)$ time to complete, putting the overall time complexity at $O(m+n)$. The space complexity is also $O(m+n)$. `adj` will use $O(m)$ memory as it contains the edges contained in the given graph. The graph is then traversed recursively, with the maximum height of the recursion stack scaling linearly with the height of the graph. Since the tree-like graph is a generic tree and is not guaranteed to be balanced, the height is bound by $n$.  
  

