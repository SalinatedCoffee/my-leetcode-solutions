## 310. (M) Minimum Height Trees

### `solution.py`
We should first start off by thinking about the number of minimum height trees(MHTs) that a tree graph can have. If we select a node as the root, we are essentially 'folding' all paths going through it at that node. For example, if the path is `0, 1, 2, 3, 4` and `1` is selected as the root, the path is 'folded' at node `1`, with `1, 0` as one branch and `1, 2, 3, 4` as the other. In order to use this property to minimize the height of the given tree graph then, it would stand to argue that we should be folding the longest path in the graph in half. Hence, we can say that a tree graph can have only 1 MHT when its diameter is odd and 2 MHTs when it is even. For the former, the middle node of the longest path of the tree would be the root. For the latter, the two nodes about the center of the longest path would be the roots.  
Now that we know what nodes to search for, we need to figure out how to search for them. The given graph is undirected and is guaranteed to be a tree, which means that it is acyclic and there is only 1 connected component. Determining the diameter of such a tree is a two-part process. Starting at a random node, we first find the node furthest away from that random node. Then, starting at that furthest node, we find the node that is furthest away from that node. The two nodes should be the source and destination nodes(and vice versa) of the shortest path between the two furthest nodes(which we shall refer to as the 'diameter path' of the graph). Once we know what these nodes are, we can produce a list of all nodes that comprise the diameter path in order of which they were traversed. As explained above, we return the middle node if this path has an odd length, or the two nodes about the center if it is even.  
The list of edges `edges` is first converted into an adjacency list `adj`. We then perform DFS on the graph thrice, determining the diameter with the first two, and finding the diameter path with the last traversal. Once we have the list of nodes in the diameter path, we simply return the list of appropriate nodes as described previously.  

#### Conclusion
This solution has a time complexity of $O(n)$, where $n$ is `n`. Each DFS traversal takes $O(|V|+|E|)$ time, where $V$ is the set of vertices and $E$ the set of edges in the graph being traversed. There are `n` vertices in the given graph, and because it is guaranteed that the graph is a tree-like graph, the number of vertices are also on the order of $O(n)$. Since processing each node during traversal takes $O(1)$ time, the overall time complexity becomes $O(n)$. The space complexity is also $O(n)$, due to the use of DFS and the list `path`, which stores the nodes comprising the diameter path of the graph.  
A different approach(but based on similar logic) would involve 'pruning' the tree in level order starting at its leaf nodes.  
  

