## 1552. (M) Magnetic Force Between Two Balls

### `solution.py`
Given a list of bucket positions `position` and the number of balls to distribute `m`, we are asked to return the largest minimum magnetic force between two balls. The force applied between two balls is simply the absolute difference of their positions; in other words, the force increases inversely with distance. As such, we want to 'space out' the balls as widely as possible in order to maximize the minimum force between the distributed balls. We realize that we can determine whether some minimum distance `d` can be achieved by distributing `m` balls in linear time if `position` is first sorted in ascending order. Since we want to maximize the minimum distance, placing a ball in the first bucket is always optimal, which we do before distributing the others. Then, while iterating over `position` we place a ball in a bucket as soon as the distance between the bucket where a ball was last placed and the current one exceeds `d`. If by the end of the iteration at least `m` balls can be placed, we know that distributing `m` balls where the minimum force is at least `d` is possible. At this point, we can also see that if we are able to distribute `m` balls with a force of at least `d`, we are able to distribute `m` balls with a force of at least `e` also, where `e < d`. Because of this property, we know that we can perform a binary search on the force to find the largest possible value of `d` that allows us to distribute `m` balls. The initial search space is `[1, max(position) // (m-1)]`. If a midpoint is valid we select the right half since a larger valid force may exist. Otherwise, we select the left half.  

#### Conclusion
The time complexity of this solution is $O(n\log n + n\log m)$, where $n$ is the length of `position` and $m$ is the largest value within `position`. `position` is first sorted in order to prepare it for the search step, which takes $O(n\log n)$ time using Python's built in sort. Binary search is then performed on the minimum force(distance) with the initial search space `[1, max(position)//(m-1)]`. Because the search space is bound by `max(position)`, $O(\log m)$ halvings will occur before the binary search completes. Determining which half to discard requires evaluating the midpoint against `position` which is a linear time operation, taking $O(n)$ time to complete. Hence, the search step will take $O(n\log m)$ time to complete, bringing the overall time complexity to $O(n\log n + n\log m)$. The space complexity is $O(n)$, due to the sorting step.  
  

