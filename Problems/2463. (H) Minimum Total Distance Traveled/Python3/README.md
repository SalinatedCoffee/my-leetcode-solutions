## 2463. (H) Minimum Total Distance Traveled

### `solution.py`
Factories and robots exist on a number line. The position of each robot and factory is unique(but a robot and a factory may share the same position), and is given in the lists `robot` and `factory`. Each factory can perform a limited number of repairs, which is given to us as the second element of each list in the list `factory`. `factory[i][0]` corresponds to the position of the `i`th factory, and `factory[i][1]` represents the number of repairs that factory can perform. At the beginning of time, all robots are broken. A broken robot will continue moving in the direction it was facing until it encounters a factory that can perform repairs, at which point the robot is repaired by the factory and stops moving. Before time starts passing, we can arbitrarily choose the initial direction each robot is pointing towards. Given these conditions, we are asked to determine and return the minimum distance the robots travel before they are all repaired.  
Reading through the problem description, it initially seems like the problem could be solved by simulation. However, the constraints on the input size makes this approach infeasible as each robot has 2 possible choices, which means that there are $2^{\texttt{len(robot)}}$ possible combinations that have to be evaluated. Thinking about the problem, we can see that we would want to send a robot to the closest available factory to minimize the distance traveled. To do this, we can sort the robots and factories by their position and iterate over both lists simultaneously while trying to send a robot to the nearest available factory. Brute forcing this problem would involve iterating over `factory` for each robot, which would take too long. Instead, we can take a dynamic programming approach by realizing that we can set up a recurrence relation between states. If we are currently considering the `i`th robot and `j`th factory, there are 2 possible choices that we can make. We can either send the robot to the `j`th factory, or we can skip this factory and send it to the next one. But wait, you may ask - a robot(or a factory) cannot *choose* whether to perform a repair, so how is it that we can decide to skip a factory? Surely, if a robot is at position `1` and there is a factory at `3` and another at `4`, it would be impossible for the robot to reach the factory at position `4`?  
To solve this conundrum, we need to think about the implications of each choice. Let's first assume that we are currently considering some robot `i` and factory `j`. Both lists are already sorted in ascending order, which means that the position of factory `j+1` is larger than or equal to that of `j`. If they are equal, skipping the `j`th factory has no effect, so we will also assume that the position of the `j+1`st factory is strictly larger than that of the `j`th. There are 3 possible configurations of the robot and factories in terms of their relative positions. The robot can either be on the left of both factories, between the `j`th and `j+1`th factories, or to the right of both factories. For the first case, skipping the `j`th factory would obviously result in a longer travel distance, which means that not skipping the `j`th factory will be chosen over this choice. For the second case, we do not mind if we skip the `j`th factory as the `j+1`th factory is already reachable by the robot as-is(though it may not be the optimal choice). The third case is the first case but mirrored, with the `j`th factory being unreachable instead of the `j+1`th factory. Here, skipping the `j`th factory is the optimal choice as it is further away from the robot.  
Now that we have established that a robot can be arbitrarily assigned to a factory when robots and factories are considered in ascending order of their positions, we need to figure out a way to reformat `factory` to make it work with our recurrence relation. To achieve this, we can simply duplicate the position of a factory by the number of repairs it can perform, flattening the 2D list into a list of integers. A state can now be represented by two integers `r` and `f`, representing the index of the robot and factory currently being considered. To compute the minimum distance traveled for some state `(r, f)`, we compare the distance between `robot[r]` and `factory[f]` added to the distance for the state `(r+1, f+1)`(assign robot `r` to factory `f`), and the distance of the state `(r, f+1)`(skip factory `f`). Among the two values, we select whichever one is smaller.  
The desired distance is the value of the state `(0, 0)`, which we can directly return.  

#### Conclusion
This solution has a time complexity of $O(mn)$, where $m$ and $n$ are the lengths of `robot` and `factory` after flattening, respectively. Each state is represented by two integers, which are bound by $m$ and $n$. Computing the value of a single state takes $O(1)$ time, and since all possible states are evaluated the overall time complexity of this solution is $O(mn)$. The space complexity is also $O(mn)$, as the value of each intermediate state is memoized in memory until the algorithm completes.  
Note that the number of repairs a single factory can perform is bound by the number of robots, which means that the time and space complexities can also be written as $O(kn^2)$, where $k$ is the number of factories(length of `factory`).  

